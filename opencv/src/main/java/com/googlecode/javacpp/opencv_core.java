/* DO NOT EDIT THIS FILE - IT IS MACHINE GENERATED */

package com.googlecode.javacpp;

import com.googlecode.javacpp.*;
import com.googlecode.javacpp.annotation.*;
import java.nio.*;

public class opencv_core extends com.googlecode.javacpp.presets.opencv_core {
    static { Loader.load(); }

/* Wrapper for header file /usr/local/include/opencv2/core/types_c.h */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef __OPENCV_CORE_TYPES_H__
// #define __OPENCV_CORE_TYPES_H__

// #if !defined _CRT_SECURE_NO_DEPRECATE && defined _MSC_VER
// #  if _MSC_VER > 1300
// #    define _CRT_SECURE_NO_DEPRECATE /* to avoid multiple Visual Studio 2005 warnings */
// #  endif
// #endif


// #ifndef SKIP_INCLUDES

// #include <assert.h>
// #include <stdlib.h>
// #include <string.h>
// #include <float.h>

// #if !defined _MSC_VER && !defined __BORLANDC__
// #  include <stdint.h>
// #endif

// #if defined __ICL
// #elif defined __ICC
// #elif defined __ECL
// #elif defined __ECC
// #elif defined __INTEL_COMPILER
// #endif

// #if defined CV_ICC && !defined CV_ENABLE_UNROLLED
// #  define CV_ENABLE_UNROLLED 0
// #else
// #  define CV_ENABLE_UNROLLED 1
// #endif

// #if (defined _M_X64 && defined _MSC_VER && _MSC_VER >= 1400) || (__GNUC__ >= 4 && defined __x86_64__)
// #  if defined WIN32
// #    include <intrin.h>
// #  endif
// #  if defined __SSE2__ || !defined __GNUC__
// #    include <emmintrin.h>
// #  endif
// #endif

// #if defined __BORLANDC__
// #  include <fastmath.h>
// #else
// #  include <math.h>
// #endif

// #ifdef HAVE_IPL
// #  ifndef __IPL_H__
// #    if defined WIN32 || defined _WIN32
// #    else
// #      include <ipl/ipl.h>
// #    endif
// #  endif
// #elif defined __IPL_H__
// #  define HAVE_IPL
// #endif

// #endif // SKIP_INCLUDES

// #if defined WIN32 || defined _WIN32
// #else
// #  define CV_CDECL
// #  define CV_STDCALL
// #endif

// #ifndef CV_EXTERN_C
// #  ifdef __cplusplus
// #  else
// #  endif
// #endif

// #ifndef CV_EXTERN_C_FUNCPTR
// #  ifdef __cplusplus
// #  else
// #    define CV_EXTERN_C_FUNCPTR(x) typedef x
// #  endif
// #endif

// #ifndef CV_INLINE
// #  if defined __cplusplus
// #    define CV_INLINE inline
// #  elif defined _MSC_VER
// #  else
// #    define CV_INLINE static
// #  endif
// #endif /* CV_INLINE */

// #if (defined WIN32 || defined _WIN32 || defined WINCE) && defined CVAPI_EXPORTS
// #  define CV_EXPORTS __declspec(dllexport)
// #else
// #  define CV_EXPORTS
// #endif

// #ifndef CVAPI
// #  define CVAPI(rettype) CV_EXTERN_C CV_EXPORTS rettype CV_CDECL
// #endif

// #if defined _MSC_VER || defined __BORLANDC__
// #  define CV_BIG_INT(n)   n##I64
// #  define CV_BIG_UINT(n)  n##UI64
// #else
// #  define CV_BIG_INT(n)   n##LL
// #  define CV_BIG_UINT(n)  n##ULL
// #endif

// #ifndef HAVE_IPL
// #endif

/* special informative macros for wrapper generators */
// #define CV_CARRAY(counter)
// #define CV_CUSTOM_CARRAY(args)
// #define CV_EXPORTS_W CV_EXPORTS
// #define CV_EXPORTS_W_SIMPLE CV_EXPORTS
// #define CV_EXPORTS_AS(synonym) CV_EXPORTS
// #define CV_EXPORTS_W_MAP CV_EXPORTS
// #define CV_IN_OUT
// #define CV_OUT
// #define CV_PROP
// #define CV_PROP_RW
// #define CV_WRAP
// #define CV_WRAP_AS(synonym)
// #define CV_WRAP_DEFAULT(value)

/* CvArr* is used to pass arbitrary
 * array-like data structures
 * into functions where the particular
 * array type is recognized at runtime:
 */
@Opaque public static class CvArr extends Pointer {
    public CvArr() { }
    public CvArr(Pointer p) { super(p); }
}

public static class Cv32suf extends Pointer {
    static { Loader.load(); }
    public Cv32suf() { allocate(); }
    public Cv32suf(int size) { allocateArray(size); }
    public Cv32suf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv32suf position(int position) {
        return (Cv32suf)super.position(position);
    }

    public native int i(); public native Cv32suf i(int i);
    public native @Cast("unsigned") int u(); public native Cv32suf u(int u);
    public native float f(); public native Cv32suf f(float f);
}

public static class Cv64suf extends Pointer {
    static { Loader.load(); }
    public Cv64suf() { allocate(); }
    public Cv64suf(int size) { allocateArray(size); }
    public Cv64suf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv64suf position(int position) {
        return (Cv64suf)super.position(position);
    }

    public native @Cast("int64") long i(); public native Cv64suf i(long i);
    public native @Cast("uint64") int u(); public native Cv64suf u(int u);
    public native double f(); public native Cv64suf f(double f);
}

/** enum  */
public static final int
 CV_StsOk= 0,  /* everithing is ok                */
 CV_StsBackTrace= -1,  /* pseudo error for back trace     */
 CV_StsError= -2,  /* unknown /unspecified error      */
 CV_StsInternal= -3,  /* internal error (bad state)      */
 CV_StsNoMem= -4,  /* insufficient memory             */
 CV_StsBadArg= -5,  /* function arg/param is bad       */
 CV_StsBadFunc= -6,  /* unsupported function            */
 CV_StsNoConv= -7,  /* iter. didn't converge           */
 CV_StsAutoTrace= -8,  /* tracing                         */
 CV_HeaderIsNull= -9,  /* image header is NULL            */
 CV_BadImageSize= -10, /* image size is invalid           */
 CV_BadOffset= -11, /* offset is invalid               */
 CV_BadDataPtr= -12, /**/
 CV_BadStep= -13, /**/
 CV_BadModelOrChSeq= -14, /**/
 CV_BadNumChannels= -15, /**/
 CV_BadNumChannel1U= -16, /**/
 CV_BadDepth= -17, /**/
 CV_BadAlphaChannel= -18, /**/
 CV_BadOrder= -19, /**/
 CV_BadOrigin= -20, /**/
 CV_BadAlign= -21, /**/
 CV_BadCallBack= -22, /**/
 CV_BadTileSize= -23, /**/
 CV_BadCOI= -24, /**/
 CV_BadROISize= -25, /**/
 CV_MaskIsTiled= -26, /**/
 CV_StsNullPtr= -27, /* null pointer */
 CV_StsVecLengthErr= -28, /* incorrect vector length */
 CV_StsFilterStructContentErr= -29, /* incorr. filter structure content */
 CV_StsKernelStructContentErr= -30, /* incorr. transform kernel content */
 CV_StsFilterOffsetErr= -31, /* incorrect filter ofset value */
 CV_StsBadSize= -201, /* the input/output structure size is incorrect  */
 CV_StsDivByZero= -202, /* division by zero */
 CV_StsInplaceNotSupported= -203, /* in-place operation is not supported */
 CV_StsObjectNotFound= -204, /* request can't be completed */
 CV_StsUnmatchedFormats= -205, /* formats of input/output arrays differ */
 CV_StsBadFlag= -206, /* flag is wrong or not supported */
 CV_StsBadPoint= -207, /* bad CvPoint */
 CV_StsBadMask= -208, /* bad format of mask (neither 8uC1 nor 8sC1)*/
 CV_StsUnmatchedSizes= -209, /* sizes of input/output structures do not match */
 CV_StsUnsupportedFormat= -210, /* the data format/type is not supported by the function*/
 CV_StsOutOfRange= -211, /* some of parameters are out of range */
 CV_StsParseError= -212, /* invalid syntax/structure of the parsed file */
 CV_StsNotImplemented= -213, /* the requested function/feature is not implemented */
 CV_StsBadMemBlock= -214, /* an allocated block has been corrupted */
 CV_StsAssert= -215, /* assertion failed */
 CV_GpuNotSupported= -216,
 CV_GpuApiCallError= -217,
 CV_OpenGlNotSupported= -218,
 CV_OpenGlApiCallError= -219,
 CV_OpenCLDoubleNotSupported= -220,
 CV_OpenCLInitError= -221,
 CV_OpenCLNoAMDBlasFft= -222;

/****************************************************************************************\
*                             Common macros and inline functions                         *
\****************************************************************************************/

// #ifdef HAVE_TEGRA_OPTIMIZATION
// #  include "tegra_round.hpp"
// #endif

public static final double CV_PI =   3.1415926535897932384626433832795;
public static final double CV_LOG2 = 0.69314718055994530941723212145818;

// #define CV_SWAP(a,b,t) ((t) = (a), (a) = (b), (b) = (t))

// #ifndef MIN
// #  define MIN(a,b)  ((a) > (b) ? (b) : (a))
// #endif

// #ifndef MAX
// #  define MAX(a,b)  ((a) < (b) ? (b) : (a))
// #endif

/* min & max without jumps */
// #define  CV_IMIN(a, b)  ((a) ^ (((a)^(b)) & (((a) < (b)) - 1)))

// #define  CV_IMAX(a, b)  ((a) ^ (((a)^(b)) & (((a) > (b)) - 1)))

/* absolute value without jumps */
// #ifndef __cplusplus
// #  define  CV_IABS(a)     (((a) ^ ((a) < 0 ? -1 : 0)) - ((a) < 0 ? -1 : 0))
// #else
// #endif
// #define  CV_CMP(a,b)    (((a) > (b)) - ((a) < (b)))
// #define  CV_SIGN(a)     CV_CMP((a),0)

public static native int cvRound( double value );

// #if defined __SSE2__ || (defined _M_IX86_FP && 2 == _M_IX86_FP)
// #  include "emmintrin.h"
// #endif

public static native int cvFloor( double value );


public static native int cvCeil( double value );

// #define cvInvSqrt(value) ((float)(1./sqrt(value)))
// #define cvSqrt(value)  ((float)sqrt(value))

public static native int cvIsNaN( double value );


public static native int cvIsInf( double value );


/*************** Random number generation *******************/

public static final long CV_RNG_COEFF = 4164903690L;

public static native @Cast("CvRNG") int cvRNG( @Cast("int64") long seed/*CV_DEFAULT(-1)*/);

/* Return random 32-bit unsigned integer: */
public static native @Cast("unsigned") int cvRandInt( @Cast("CvRNG*") IntPointer rng );
public static native @Cast("unsigned") int cvRandInt( @Cast("CvRNG*") IntBuffer rng );
public static native @Cast("unsigned") int cvRandInt( @Cast("CvRNG*") int[] rng );

/* Returns random floating-point number between 0 and 1: */
public static native double cvRandReal( @Cast("CvRNG*") IntPointer rng );
public static native double cvRandReal( @Cast("CvRNG*") IntBuffer rng );
public static native double cvRandReal( @Cast("CvRNG*") int[] rng );

/****************************************************************************************\
*                                  Image type (IplImage)                                 *
\****************************************************************************************/

// #ifndef HAVE_IPL

/*
 * The following definitions (until #endif)
 * is an extract from IPL headers.
 * Copyright (c) 1995 Intel Corporation.
 */
public static final int IPL_DEPTH_SIGN = 0x80000000;

public static final int IPL_DEPTH_1U =     1;
public static final int IPL_DEPTH_8U =     8;
public static final int IPL_DEPTH_16U =   16;
public static final int IPL_DEPTH_32F =   32;

public static final int IPL_DEPTH_8S =  (IPL_DEPTH_SIGN| 8);
public static final int IPL_DEPTH_16S = (IPL_DEPTH_SIGN|16);
public static final int IPL_DEPTH_32S = (IPL_DEPTH_SIGN|32);

public static final int IPL_DATA_ORDER_PIXEL =  0;
public static final int IPL_DATA_ORDER_PLANE =  1;

public static final int IPL_ORIGIN_TL = 0;
public static final int IPL_ORIGIN_BL = 1;

public static final int IPL_ALIGN_4BYTES =   4;
public static final int IPL_ALIGN_8BYTES =   8;
public static final int IPL_ALIGN_16BYTES = 16;
public static final int IPL_ALIGN_32BYTES = 32;

public static final int IPL_ALIGN_DWORD =   IPL_ALIGN_4BYTES;
public static final int IPL_ALIGN_QWORD =   IPL_ALIGN_8BYTES;

public static final int IPL_BORDER_CONSTANT =   0;
public static final int IPL_BORDER_REPLICATE =  1;
public static final int IPL_BORDER_REFLECT =    2;
public static final int IPL_BORDER_WRAP =       3;

public static class IplImage extends CvArr {
    static { Loader.load(); }
    public IplImage() { allocate(); }
    public IplImage(int size) { allocateArray(size); }
    public IplImage(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public IplImage position(int position) {
        return (IplImage)super.position(position);
    }

    public native int nSize(); public native IplImage nSize(int nSize);             /* sizeof(IplImage) */
    public native int ID(); public native IplImage ID(int ID);                /* version (=0)*/
    public native int nChannels(); public native IplImage nChannels(int nChannels);         /* Most of OpenCV functions support 1,2,3 or 4 channels */
    public native int alphaChannel(); public native IplImage alphaChannel(int alphaChannel);      /* Ignored by OpenCV */
    public native int depth(); public native IplImage depth(int depth);             /* Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,
                               IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported.  */
    public native @Cast("char") byte colorModel(int i); public native IplImage colorModel(int i, byte colorModel);
    @MemberGetter public native @Cast("char*") BytePointer colorModel();     /* Ignored by OpenCV */
    public native @Cast("char") byte channelSeq(int i); public native IplImage channelSeq(int i, byte channelSeq);
    @MemberGetter public native @Cast("char*") BytePointer channelSeq();     /* ditto */
    public native int dataOrder(); public native IplImage dataOrder(int dataOrder);         /* 0 - interleaved color channels, 1 - separate color channels.
                               cvCreateImage can only create interleaved images */
    public native int origin(); public native IplImage origin(int origin);            /* 0 - top-left origin,
                               1 - bottom-left origin (Windows bitmaps style).  */
    public native int align(); public native IplImage align(int align);             /* Alignment of image rows (4 or 8).
                               OpenCV ignores it and uses widthStep instead.    */
    public native int width(); public native IplImage width(int width);             /* Image width in pixels.                           */
    public native int height(); public native IplImage height(int height);            /* Image height in pixels.                          */
    public native IplROI roi(); public native IplImage roi(IplROI roi);    /* Image ROI. If NULL, the whole image is selected. */
    public native IplImage maskROI(); public native IplImage maskROI(IplImage maskROI);      /* Must be NULL. */
    public native Pointer imageId(); public native IplImage imageId(Pointer imageId);                 /* "           " */
    public native IplTileInfo tileInfo(); public native IplImage tileInfo(IplTileInfo tileInfo);  /* "           " */
    public native int imageSize(); public native IplImage imageSize(int imageSize);         /* Image data size in bytes
                               (==image->height*image->widthStep
                               in case of interleaved data)*/
    public native @Cast("char*") BytePointer imageData(); public native IplImage imageData(BytePointer imageData);        /* Pointer to aligned image data.         */
    public native int widthStep(); public native IplImage widthStep(int widthStep);         /* Size of aligned image row in bytes.    */
    public native int BorderMode(int i); public native IplImage BorderMode(int i, int BorderMode);
    @MemberGetter public native IntPointer BorderMode();     /* Ignored by OpenCV.                     */
    public native int BorderConst(int i); public native IplImage BorderConst(int i, int BorderConst);
    @MemberGetter public native IntPointer BorderConst();    /* Ditto.                                 */
    public native @Cast("char*") BytePointer imageDataOrigin(); public native IplImage imageDataOrigin(BytePointer imageDataOrigin);  /* Pointer to very origin of image data
                               (not necessarily aligned) -
                               needed for correct deallocation */
}

@Opaque public static class IplTileInfo extends Pointer {
    public IplTileInfo() { }
    public IplTileInfo(Pointer p) { super(p); }
}

public static class IplROI extends Pointer {
    static { Loader.load(); }
    public IplROI() { allocate(); }
    public IplROI(int size) { allocateArray(size); }
    public IplROI(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public IplROI position(int position) {
        return (IplROI)super.position(position);
    }

    public native int coi(); public native IplROI coi(int coi); /* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*/
    public native int xOffset(); public native IplROI xOffset(int xOffset);
    public native int yOffset(); public native IplROI yOffset(int yOffset);
    public native int width(); public native IplROI width(int width);
    public native int height(); public native IplROI height(int height);
}

public static class IplConvKernel extends Pointer {
    static { Loader.load(); }
    public IplConvKernel() { allocate(); }
    public IplConvKernel(int size) { allocateArray(size); }
    public IplConvKernel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public IplConvKernel position(int position) {
        return (IplConvKernel)super.position(position);
    }

    public native int nCols(); public native IplConvKernel nCols(int nCols);
    public native int nRows(); public native IplConvKernel nRows(int nRows);
    public native int anchorX(); public native IplConvKernel anchorX(int anchorX);
    public native int anchorY(); public native IplConvKernel anchorY(int anchorY);
    public native IntPointer values(); public native IplConvKernel values(IntPointer values);
    public native int nShiftR(); public native IplConvKernel nShiftR(int nShiftR);
}

public static class IplConvKernelFP extends Pointer {
    static { Loader.load(); }
    public IplConvKernelFP() { allocate(); }
    public IplConvKernelFP(int size) { allocateArray(size); }
    public IplConvKernelFP(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public IplConvKernelFP position(int position) {
        return (IplConvKernelFP)super.position(position);
    }

    public native int nCols(); public native IplConvKernelFP nCols(int nCols);
    public native int nRows(); public native IplConvKernelFP nRows(int nRows);
    public native int anchorX(); public native IplConvKernelFP anchorX(int anchorX);
    public native int anchorY(); public native IplConvKernelFP anchorY(int anchorY);
    public native FloatPointer values(); public native IplConvKernelFP values(FloatPointer values);
}

public static final int IPL_IMAGE_HEADER = 1;
public static final int IPL_IMAGE_DATA =   2;
public static final int IPL_IMAGE_ROI =    4;

// #endif/*HAVE_IPL*/

/* extra border mode */
public static final int IPL_BORDER_REFLECT_101 =    4;
public static final int IPL_BORDER_TRANSPARENT =    5;

public static native @MemberGetter int IPL_IMAGE_MAGIC_VAL();
public static final int IPL_IMAGE_MAGIC_VAL = IPL_IMAGE_MAGIC_VAL();
public static final String CV_TYPE_NAME_IMAGE = "opencv-image";

// #define CV_IS_IMAGE_HDR(img)
//     ((img) != NULL && ((const IplImage*)(img))->nSize == sizeof(IplImage))

// #define CV_IS_IMAGE(img)
//     (CV_IS_IMAGE_HDR(img) && ((IplImage*)img)->imageData != NULL)

/* for storing double-precision
   floating point data in IplImage's */
public static final int IPL_DEPTH_64F =  64;

/* get reference to pixel at (col,row),
   for multi-channel images (col) should be multiplied by number of channels */
// #define CV_IMAGE_ELEM( image, elemtype, row, col )
//     (((elemtype*)((image)->imageData + (image)->widthStep*(row)))[(col)])

/****************************************************************************************\
*                                  Matrix type (CvMat)                                   *
\****************************************************************************************/

public static final int CV_CN_MAX =     512;
public static final int CV_CN_SHIFT =   3;
public static final int CV_DEPTH_MAX =  (1 << CV_CN_SHIFT);

public static final int CV_8U =   0;
public static final int CV_8S =   1;
public static final int CV_16U =  2;
public static final int CV_16S =  3;
public static final int CV_32S =  4;
public static final int CV_32F =  5;
public static final int CV_64F =  6;
public static final int CV_USRTYPE1 = 7;

public static final int CV_MAT_DEPTH_MASK =       (CV_DEPTH_MAX - 1);
public static native int CV_MAT_DEPTH(int flags);

public static native int CV_MAKETYPE(int depth, int cn);
public static native int CV_MAKE_TYPE(int arg1, int arg2);

public static final int CV_8UC1 = CV_MAKETYPE(CV_8U,1);
public static final int CV_8UC2 = CV_MAKETYPE(CV_8U,2);
public static final int CV_8UC3 = CV_MAKETYPE(CV_8U,3);
public static final int CV_8UC4 = CV_MAKETYPE(CV_8U,4);
public static native int CV_8UC(int n);

public static final int CV_8SC1 = CV_MAKETYPE(CV_8S,1);
public static final int CV_8SC2 = CV_MAKETYPE(CV_8S,2);
public static final int CV_8SC3 = CV_MAKETYPE(CV_8S,3);
public static final int CV_8SC4 = CV_MAKETYPE(CV_8S,4);
public static native int CV_8SC(int n);

public static final int CV_16UC1 = CV_MAKETYPE(CV_16U,1);
public static final int CV_16UC2 = CV_MAKETYPE(CV_16U,2);
public static final int CV_16UC3 = CV_MAKETYPE(CV_16U,3);
public static final int CV_16UC4 = CV_MAKETYPE(CV_16U,4);
public static native int CV_16UC(int n);

public static final int CV_16SC1 = CV_MAKETYPE(CV_16S,1);
public static final int CV_16SC2 = CV_MAKETYPE(CV_16S,2);
public static final int CV_16SC3 = CV_MAKETYPE(CV_16S,3);
public static final int CV_16SC4 = CV_MAKETYPE(CV_16S,4);
public static native int CV_16SC(int n);

public static final int CV_32SC1 = CV_MAKETYPE(CV_32S,1);
public static final int CV_32SC2 = CV_MAKETYPE(CV_32S,2);
public static final int CV_32SC3 = CV_MAKETYPE(CV_32S,3);
public static final int CV_32SC4 = CV_MAKETYPE(CV_32S,4);
public static native int CV_32SC(int n);

public static final int CV_32FC1 = CV_MAKETYPE(CV_32F,1);
public static final int CV_32FC2 = CV_MAKETYPE(CV_32F,2);
public static final int CV_32FC3 = CV_MAKETYPE(CV_32F,3);
public static final int CV_32FC4 = CV_MAKETYPE(CV_32F,4);
public static native int CV_32FC(int n);

public static final int CV_64FC1 = CV_MAKETYPE(CV_64F,1);
public static final int CV_64FC2 = CV_MAKETYPE(CV_64F,2);
public static final int CV_64FC3 = CV_MAKETYPE(CV_64F,3);
public static final int CV_64FC4 = CV_MAKETYPE(CV_64F,4);
public static native int CV_64FC(int n);

public static final int CV_AUTO_STEP =  0x7fffffff;
public static final CvSlice CV_WHOLE_ARR =  cvSlice( 0, 0x3fffffff );

public static final int CV_MAT_CN_MASK =          ((CV_CN_MAX - 1) << CV_CN_SHIFT);
// #define CV_MAT_CN(flags)        ((((flags) & CV_MAT_CN_MASK) >> CV_CN_SHIFT) + 1)
public static final int CV_MAT_TYPE_MASK =        (CV_DEPTH_MAX*CV_CN_MAX - 1);
// #define CV_MAT_TYPE(flags)      ((flags) & CV_MAT_TYPE_MASK)
public static final int CV_MAT_CONT_FLAG_SHIFT =  14;
public static final int CV_MAT_CONT_FLAG =        (1 << CV_MAT_CONT_FLAG_SHIFT);
public static native int CV_IS_MAT_CONT(int flags);
public static native int CV_IS_CONT_MAT(int arg1);
public static final int CV_SUBMAT_FLAG_SHIFT =    15;
public static final int CV_SUBMAT_FLAG =          (1 << CV_SUBMAT_FLAG_SHIFT);
// #define CV_IS_SUBMAT(flags)     ((flags) & CV_MAT_SUBMAT_FLAG)

public static final int CV_MAGIC_MASK =       0xFFFF0000;
public static final int CV_MAT_MAGIC_VAL =    0x42420000;
public static final String CV_TYPE_NAME_MAT =    "opencv-matrix";

public static class CvMat extends CvArr {
    static { Loader.load(); }
    public CvMat() { allocate(); }
    public CvMat(int size) { allocateArray(size); }
    public CvMat(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMat position(int position) {
        return (CvMat)super.position(position);
    }

    public native int type(); public native CvMat type(int type);
    public native int step(); public native CvMat step(int step);

    /* for internal use only */
    public native IntPointer refcount(); public native CvMat refcount(IntPointer refcount);
    public native int hdr_refcount(); public native CvMat hdr_refcount(int hdr_refcount);

        @Name({"data", ".ptr"}) public native @Cast("uchar*") BytePointer data_ptr(); public native CvMat data_ptr(BytePointer data_ptr);
        @Name({"data", ".s"}) public native ShortPointer data_s(); public native CvMat data_s(ShortPointer data_s);
        @Name({"data", ".i"}) public native IntPointer data_i(); public native CvMat data_i(IntPointer data_i);
        @Name({"data", ".fl"}) public native FloatPointer data_fl(); public native CvMat data_fl(FloatPointer data_fl);
        @Name({"data", ".db"}) public native DoublePointer data_db(); public native CvMat data_db(DoublePointer data_db);

// #ifdef __cplusplus
// #else
    public native int rows(); public native CvMat rows(int rows);
    public native int cols(); public native CvMat cols(int cols);
// #endif

}


// #define CV_IS_MAT_HDR(mat)
//     ((mat) != NULL &&
//     (((const CvMat*)(mat))->type & CV_MAGIC_MASK) == CV_MAT_MAGIC_VAL &&
//     ((const CvMat*)(mat))->cols > 0 && ((const CvMat*)(mat))->rows > 0)

// #define CV_IS_MAT_HDR_Z(mat)
//     ((mat) != NULL &&
//     (((const CvMat*)(mat))->type & CV_MAGIC_MASK) == CV_MAT_MAGIC_VAL &&
//     ((const CvMat*)(mat))->cols >= 0 && ((const CvMat*)(mat))->rows >= 0)

// #define CV_IS_MAT(mat)
//     (CV_IS_MAT_HDR(mat) && ((const CvMat*)(mat))->data.ptr != NULL)

// #define CV_IS_MASK_ARR(mat)
//     (((mat)->type & (CV_MAT_TYPE_MASK & ~CV_8SC1)) == 0)

// #define CV_ARE_TYPES_EQ(mat1, mat2)
//     ((((mat1)->type ^ (mat2)->type) & CV_MAT_TYPE_MASK) == 0)

// #define CV_ARE_CNS_EQ(mat1, mat2)
//     ((((mat1)->type ^ (mat2)->type) & CV_MAT_CN_MASK) == 0)

// #define CV_ARE_DEPTHS_EQ(mat1, mat2)
//     ((((mat1)->type ^ (mat2)->type) & CV_MAT_DEPTH_MASK) == 0)

// #define CV_ARE_SIZES_EQ(mat1, mat2)
//     ((mat1)->rows == (mat2)->rows && (mat1)->cols == (mat2)->cols)

// #define CV_IS_MAT_CONST(mat)
//     (((mat)->rows|(mat)->cols) == 1)

/* Size of each channel item,
   0x124489 = 1000 0100 0100 0010 0010 0001 0001 ~ array of sizeof(arr_type_elem) */
// #define CV_ELEM_SIZE1(type)
//     ((((sizeof(size_t)<<28)|0x8442211) >> CV_MAT_DEPTH(type)*4) & 15)

/* 0x3a50 = 11 10 10 01 01 00 00 ~ array of log2(sizeof(arr_type_elem)) */
// #define CV_ELEM_SIZE(type)
//     (CV_MAT_CN(type) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> CV_MAT_DEPTH(type)*2) & 3))

// #define IPL2CV_DEPTH(depth)
//     ((((CV_8U)+(CV_16U<<4)+(CV_32F<<8)+(CV_64F<<16)+(CV_8S<<20)+
//     (CV_16S<<24)+(CV_32S<<28)) >> ((((depth) & 0xF0) >> 2) +
//     (((depth) & IPL_DEPTH_SIGN) ? 20 : 0))) & 15)

/* Inline constructor. No data is allocated internally!!!
 * (Use together with cvCreateData, or use cvCreateMat instead to
 * get a matrix with allocated data):
 */
public static native @ByVal CvMat cvMat( int rows, int cols, int type, Pointer data/*CV_DEFAULT(NULL)*/);


// #define CV_MAT_ELEM_PTR_FAST( mat, row, col, pix_size )
//     (assert( (unsigned)(row) < (unsigned)(mat).rows &&
//              (unsigned)(col) < (unsigned)(mat).cols ),
//      (mat).data.ptr + (size_t)(mat).step*(row) + (pix_size)*(col))

// #define CV_MAT_ELEM_PTR( mat, row, col )
//     CV_MAT_ELEM_PTR_FAST( mat, row, col, CV_ELEM_SIZE((mat).type) )

// #define CV_MAT_ELEM( mat, elemtype, row, col )
//     (*(elemtype*)CV_MAT_ELEM_PTR_FAST( mat, row, col, sizeof(elemtype)))


public static native double cvmGet( @Const CvMat mat, int row, int col );


public static native void cvmSet( CvMat mat, int row, int col, double value );


public static native int cvIplDepth( int type );


/****************************************************************************************\
*                       Multi-dimensional dense array (CvMatND)                          *
\****************************************************************************************/

public static final int CV_MATND_MAGIC_VAL =    0x42430000;
public static final String CV_TYPE_NAME_MATND =    "opencv-nd-matrix";

public static final int CV_MAX_DIM =            32;
public static final int CV_MAX_DIM_HEAP =       1024;

public static class CvMatND extends CvArr {
    static { Loader.load(); }
    public CvMatND() { allocate(); }
    public CvMatND(int size) { allocateArray(size); }
    public CvMatND(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMatND position(int position) {
        return (CvMatND)super.position(position);
    }

    public native int type(); public native CvMatND type(int type);
    public native int dims(); public native CvMatND dims(int dims);

    public native IntPointer refcount(); public native CvMatND refcount(IntPointer refcount);
    public native int hdr_refcount(); public native CvMatND hdr_refcount(int hdr_refcount);

        @Name({"data", ".ptr"}) public native @Cast("uchar*") BytePointer data_ptr(); public native CvMatND data_ptr(BytePointer data_ptr);
        @Name({"data", ".fl"}) public native FloatPointer data_fl(); public native CvMatND data_fl(FloatPointer data_fl);
        @Name({"data", ".db"}) public native DoublePointer data_db(); public native CvMatND data_db(DoublePointer data_db);
        @Name({"data", ".i"}) public native IntPointer data_i(); public native CvMatND data_i(IntPointer data_i);
        @Name({"data", ".s"}) public native ShortPointer data_s(); public native CvMatND data_s(ShortPointer data_s);

        @Name({"dim", ".size"}) public native int dim_size(int i); public native CvMatND dim_size(int i, int dim_size);
        @Name({"dim", ".step"}) public native int dim_step(int i); public native CvMatND dim_step(int i, int dim_step);
}

// #define CV_IS_MATND_HDR(mat)
//     ((mat) != NULL && (((const CvMatND*)(mat))->type & CV_MAGIC_MASK) == CV_MATND_MAGIC_VAL)

// #define CV_IS_MATND(mat)
//     (CV_IS_MATND_HDR(mat) && ((const CvMatND*)(mat))->data.ptr != NULL)


/****************************************************************************************\
*                      Multi-dimensional sparse array (CvSparseMat)                      *
\****************************************************************************************/

public static final int CV_SPARSE_MAT_MAGIC_VAL =    0x42440000;
public static final String CV_TYPE_NAME_SPARSE_MAT =    "opencv-sparse-matrix";

public static class CvSparseMat extends CvArr {
    static { Loader.load(); }
    public CvSparseMat() { allocate(); }
    public CvSparseMat(int size) { allocateArray(size); }
    public CvSparseMat(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSparseMat position(int position) {
        return (CvSparseMat)super.position(position);
    }

    public native int type(); public native CvSparseMat type(int type);
    public native int dims(); public native CvSparseMat dims(int dims);
    public native IntPointer refcount(); public native CvSparseMat refcount(IntPointer refcount);
    public native int hdr_refcount(); public native CvSparseMat hdr_refcount(int hdr_refcount);

    public native CvSet heap(); public native CvSparseMat heap(CvSet heap);
    public native Pointer hashtable(int i); public native CvSparseMat hashtable(int i, Pointer hashtable);
    @MemberGetter public native @Cast("void**") PointerPointer hashtable();
    public native int hashsize(); public native CvSparseMat hashsize(int hashsize);
    public native int valoffset(); public native CvSparseMat valoffset(int valoffset);
    public native int idxoffset(); public native CvSparseMat idxoffset(int idxoffset);
    public native int size(int i); public native CvSparseMat size(int i, int size);
    @MemberGetter public native IntPointer size();
}

// #define CV_IS_SPARSE_MAT_HDR(mat)
//     ((mat) != NULL &&
//     (((const CvSparseMat*)(mat))->type & CV_MAGIC_MASK) == CV_SPARSE_MAT_MAGIC_VAL)

// #define CV_IS_SPARSE_MAT(mat)
//     CV_IS_SPARSE_MAT_HDR(mat)

/**************** iteration through a sparse array *****************/

public static class CvSparseNode extends Pointer {
    static { Loader.load(); }
    public CvSparseNode() { allocate(); }
    public CvSparseNode(int size) { allocateArray(size); }
    public CvSparseNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSparseNode position(int position) {
        return (CvSparseNode)super.position(position);
    }

    public native @Cast("unsigned") int hashval(); public native CvSparseNode hashval(int hashval);
    public native CvSparseNode next(); public native CvSparseNode next(CvSparseNode next);
}

public static class CvSparseMatIterator extends Pointer {
    static { Loader.load(); }
    public CvSparseMatIterator() { allocate(); }
    public CvSparseMatIterator(int size) { allocateArray(size); }
    public CvSparseMatIterator(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSparseMatIterator position(int position) {
        return (CvSparseMatIterator)super.position(position);
    }

    public native CvSparseMat mat(); public native CvSparseMatIterator mat(CvSparseMat mat);
    public native CvSparseNode node(); public native CvSparseMatIterator node(CvSparseNode node);
    public native int curidx(); public native CvSparseMatIterator curidx(int curidx);
}

// #define CV_NODE_VAL(mat,node)   ((void*)((uchar*)(node) + (mat)->valoffset))
// #define CV_NODE_IDX(mat,node)   ((int*)((uchar*)(node) + (mat)->idxoffset))

/****************************************************************************************\
*                                         Histogram                                      *
\****************************************************************************************/

public static final int CV_HIST_MAGIC_VAL =     0x42450000;
public static final int CV_HIST_UNIFORM_FLAG =  (1 << 10);

/* indicates whether bin ranges are set already or not */
public static final int CV_HIST_RANGES_FLAG =   (1 << 11);

public static final int CV_HIST_ARRAY =         0;
public static final int CV_HIST_SPARSE =        1;
public static final int CV_HIST_TREE =          CV_HIST_SPARSE;

/* should be used as a parameter only,
   it turns to CV_HIST_UNIFORM_FLAG of hist->type */
public static final int CV_HIST_UNIFORM =       1;

public static class CvHistogram extends Pointer {
    static { Loader.load(); }
    public CvHistogram() { allocate(); }
    public CvHistogram(int size) { allocateArray(size); }
    public CvHistogram(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHistogram position(int position) {
        return (CvHistogram)super.position(position);
    }

    public native int type(); public native CvHistogram type(int type);
    public native CvArr bins(); public native CvHistogram bins(CvArr bins);
    public native float thresh(int i, int j); public native CvHistogram thresh(int i, int j, float thresh);
    @MemberGetter public native @Cast("float(*)[2]") FloatPointer thresh();  /* For uniform histograms.                      */
    public native FloatPointer thresh2(int i); public native CvHistogram thresh2(int i, FloatPointer thresh2);
    @MemberGetter public native @Cast("float**") PointerPointer thresh2();                /* For non-uniform histograms.                  */
    public native @ByVal CvMatND mat(); public native CvHistogram mat(CvMatND mat);                    /* Embedded matrix header for array histograms. */
}

// #define CV_IS_HIST( hist )
//     ((hist) != NULL  &&
//      (((CvHistogram*)(hist))->type & CV_MAGIC_MASK) == CV_HIST_MAGIC_VAL &&
//      (hist)->bins != NULL)

// #define CV_IS_UNIFORM_HIST( hist )
//     (((hist)->type & CV_HIST_UNIFORM_FLAG) != 0)

// #define CV_IS_SPARSE_HIST( hist )
//     CV_IS_SPARSE_MAT((hist)->bins)

// #define CV_HIST_HAS_RANGES( hist )
//     (((hist)->type & CV_HIST_RANGES_FLAG) != 0)

/****************************************************************************************\
*                      Other supplementary data type definitions                         *
\****************************************************************************************/

/*************************************** CvRect *****************************************/

public static class CvRect extends Pointer {
    static { Loader.load(); }
    public CvRect() { allocate(); }
    public CvRect(int size) { allocateArray(size); }
    public CvRect(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvRect position(int position) {
        return (CvRect)super.position(position);
    }

    public native int x(); public native CvRect x(int x);
    public native int y(); public native CvRect y(int y);
    public native int width(); public native CvRect width(int width);
    public native int height(); public native CvRect height(int height);
}

public static native @ByVal CvRect cvRect( int x, int y, int width, int height );


public static native @ByVal IplROI cvRectToROI( @ByVal CvRect rect, int coi );


public static native @ByVal CvRect cvROIToRect( @ByVal IplROI roi );

/*********************************** CvTermCriteria *************************************/

public static final int CV_TERMCRIT_ITER =    1;
public static final int CV_TERMCRIT_NUMBER =  CV_TERMCRIT_ITER;
public static final int CV_TERMCRIT_EPS =     2;

public static class CvTermCriteria extends Pointer {
    static { Loader.load(); }
    public CvTermCriteria() { allocate(); }
    public CvTermCriteria(int size) { allocateArray(size); }
    public CvTermCriteria(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvTermCriteria position(int position) {
        return (CvTermCriteria)super.position(position);
    }

    public native int type(); public native CvTermCriteria type(int type);  /* may be combination of
                     CV_TERMCRIT_ITER
                     CV_TERMCRIT_EPS */
    public native int max_iter(); public native CvTermCriteria max_iter(int max_iter);
    public native double epsilon(); public native CvTermCriteria epsilon(double epsilon);
}

public static native @ByVal CvTermCriteria cvTermCriteria( int type, int max_iter, double epsilon );


/******************************* CvPoint and variants ***********************************/

public static class CvPoint extends Pointer {
    static { Loader.load(); }
    public CvPoint() { allocate(); }
    public CvPoint(int size) { allocateArray(size); }
    public CvPoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPoint position(int position) {
        return (CvPoint)super.position(position);
    }

    public native int x(); public native CvPoint x(int x);
    public native int y(); public native CvPoint y(int y);
}


public static native @ByVal CvPoint cvPoint( int x, int y );


public static class CvPoint2D32f extends Pointer {
    static { Loader.load(); }
    public CvPoint2D32f() { allocate(); }
    public CvPoint2D32f(int size) { allocateArray(size); }
    public CvPoint2D32f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPoint2D32f position(int position) {
        return (CvPoint2D32f)super.position(position);
    }

    public native float x(); public native CvPoint2D32f x(float x);
    public native float y(); public native CvPoint2D32f y(float y);
}


public static native @ByVal CvPoint2D32f cvPoint2D32f( double x, double y );


public static native @ByVal CvPoint2D32f cvPointTo32f( @ByVal CvPoint point );


public static native @ByVal CvPoint cvPointFrom32f( @ByVal CvPoint2D32f point );


public static class CvPoint3D32f extends Pointer {
    static { Loader.load(); }
    public CvPoint3D32f() { allocate(); }
    public CvPoint3D32f(int size) { allocateArray(size); }
    public CvPoint3D32f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPoint3D32f position(int position) {
        return (CvPoint3D32f)super.position(position);
    }

    public native float x(); public native CvPoint3D32f x(float x);
    public native float y(); public native CvPoint3D32f y(float y);
    public native float z(); public native CvPoint3D32f z(float z);
}


public static native @ByVal CvPoint3D32f cvPoint3D32f( double x, double y, double z );


public static class CvPoint2D64f extends Pointer {
    static { Loader.load(); }
    public CvPoint2D64f() { allocate(); }
    public CvPoint2D64f(int size) { allocateArray(size); }
    public CvPoint2D64f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPoint2D64f position(int position) {
        return (CvPoint2D64f)super.position(position);
    }

    public native double x(); public native CvPoint2D64f x(double x);
    public native double y(); public native CvPoint2D64f y(double y);
}


public static native @ByVal CvPoint2D64f cvPoint2D64f( double x, double y );


public static class CvPoint3D64f extends Pointer {
    static { Loader.load(); }
    public CvPoint3D64f() { allocate(); }
    public CvPoint3D64f(int size) { allocateArray(size); }
    public CvPoint3D64f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPoint3D64f position(int position) {
        return (CvPoint3D64f)super.position(position);
    }

    public native double x(); public native CvPoint3D64f x(double x);
    public native double y(); public native CvPoint3D64f y(double y);
    public native double z(); public native CvPoint3D64f z(double z);
}


public static native @ByVal CvPoint3D64f cvPoint3D64f( double x, double y, double z );


/******************************** CvSize's & CvBox **************************************/

public static class CvSize extends Pointer {
    static { Loader.load(); }
    public CvSize() { allocate(); }
    public CvSize(int size) { allocateArray(size); }
    public CvSize(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSize position(int position) {
        return (CvSize)super.position(position);
    }

    public native int width(); public native CvSize width(int width);
    public native int height(); public native CvSize height(int height);
}

public static native @ByVal CvSize cvSize( int width, int height );

public static class CvSize2D32f extends Pointer {
    static { Loader.load(); }
    public CvSize2D32f() { allocate(); }
    public CvSize2D32f(int size) { allocateArray(size); }
    public CvSize2D32f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSize2D32f position(int position) {
        return (CvSize2D32f)super.position(position);
    }

    public native float width(); public native CvSize2D32f width(float width);
    public native float height(); public native CvSize2D32f height(float height);
}


public static native @ByVal CvSize2D32f cvSize2D32f( double width, double height );

public static class CvBox2D extends Pointer {
    static { Loader.load(); }
    public CvBox2D() { allocate(); }
    public CvBox2D(int size) { allocateArray(size); }
    public CvBox2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBox2D position(int position) {
        return (CvBox2D)super.position(position);
    }

    public native @ByVal CvPoint2D32f center(); public native CvBox2D center(CvPoint2D32f center);  /* Center of the box.                          */
    public native @ByVal CvSize2D32f size(); public native CvBox2D size(CvSize2D32f size);    /* Box width and length.                       */
    public native float angle(); public native CvBox2D angle(float angle);          /* Angle between the horizontal axis           */
                          /* and the first side (i.e. length) in degrees */
}


/* Line iterator state: */
public static class CvLineIterator extends Pointer {
    static { Loader.load(); }
    public CvLineIterator() { allocate(); }
    public CvLineIterator(int size) { allocateArray(size); }
    public CvLineIterator(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLineIterator position(int position) {
        return (CvLineIterator)super.position(position);
    }

    /* Pointer to the current point: */
    public native @Cast("uchar*") BytePointer ptr(); public native CvLineIterator ptr(BytePointer ptr);

    /* Bresenham algorithm state: */
    public native int err(); public native CvLineIterator err(int err);
    public native int plus_delta(); public native CvLineIterator plus_delta(int plus_delta);
    public native int minus_delta(); public native CvLineIterator minus_delta(int minus_delta);
    public native int plus_step(); public native CvLineIterator plus_step(int plus_step);
    public native int minus_step(); public native CvLineIterator minus_step(int minus_step);
}



/************************************* CvSlice ******************************************/

public static class CvSlice extends Pointer {
    static { Loader.load(); }
    public CvSlice() { allocate(); }
    public CvSlice(int size) { allocateArray(size); }
    public CvSlice(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSlice position(int position) {
        return (CvSlice)super.position(position);
    }

    public native int start_index(); public native CvSlice start_index(int start_index);
    public native int end_index(); public native CvSlice end_index(int end_index);
}

public static native @ByVal CvSlice cvSlice( int start, int end );

public static final int CV_WHOLE_SEQ_END_INDEX = 0x3fffffff;
public static final CvSlice CV_WHOLE_SEQ =  cvSlice(0, CV_WHOLE_SEQ_END_INDEX);


/************************************* CvScalar *****************************************/

public static class CvScalar extends Pointer {
    static { Loader.load(); }
    public CvScalar() { allocate(); }
    public CvScalar(int size) { allocateArray(size); }
    public CvScalar(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvScalar position(int position) {
        return (CvScalar)super.position(position);
    }

    public native double val(int i); public native CvScalar val(int i, double val);
    @MemberGetter public native DoublePointer val();
}

public static native @ByVal CvScalar cvScalar( double val0, double val1/*CV_DEFAULT(0)*/,
                               double val2/*CV_DEFAULT(0)*/, double val3/*CV_DEFAULT(0)*/);


public static native @ByVal CvScalar cvRealScalar( double val0 );

public static native @ByVal CvScalar cvScalarAll( double val0123 );

/****************************************************************************************\
*                                   Dynamic Data structures                              *
\****************************************************************************************/

/******************************** Memory storage ****************************************/

public static class CvMemBlock extends Pointer {
    static { Loader.load(); }
    public CvMemBlock() { allocate(); }
    public CvMemBlock(int size) { allocateArray(size); }
    public CvMemBlock(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMemBlock position(int position) {
        return (CvMemBlock)super.position(position);
    }

    public native CvMemBlock prev(); public native CvMemBlock prev(CvMemBlock prev);
    public native CvMemBlock next(); public native CvMemBlock next(CvMemBlock next);
}

public static final int CV_STORAGE_MAGIC_VAL =    0x42890000;

public static class CvMemStorage extends Pointer {
    static { Loader.load(); }
    public CvMemStorage() { allocate(); }
    public CvMemStorage(int size) { allocateArray(size); }
    public CvMemStorage(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMemStorage position(int position) {
        return (CvMemStorage)super.position(position);
    }

    public native int signature(); public native CvMemStorage signature(int signature);
    public native CvMemBlock bottom(); public native CvMemStorage bottom(CvMemBlock bottom);           /* First allocated block.                   */
    public native CvMemBlock top(); public native CvMemStorage top(CvMemBlock top);              /* Current memory block - top of the stack. */
    public native CvMemStorage parent(); public native CvMemStorage parent(CvMemStorage parent); /* We get new blocks from parent as needed. */
    public native int block_size(); public native CvMemStorage block_size(int block_size);               /* Block size.                              */
    public native int free_space(); public native CvMemStorage free_space(int free_space);               /* Remaining free space in current block.   */
}

// #define CV_IS_STORAGE(storage)
//     ((storage) != NULL &&
//     (((CvMemStorage*)(storage))->signature & CV_MAGIC_MASK) == CV_STORAGE_MAGIC_VAL)


public static class CvMemStoragePos extends Pointer {
    static { Loader.load(); }
    public CvMemStoragePos() { allocate(); }
    public CvMemStoragePos(int size) { allocateArray(size); }
    public CvMemStoragePos(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMemStoragePos position(int position) {
        return (CvMemStoragePos)super.position(position);
    }

    public native CvMemBlock top(); public native CvMemStoragePos top(CvMemBlock top);
    public native int free_space(); public native CvMemStoragePos free_space(int free_space);
}


/*********************************** Sequence *******************************************/

public static class CvSeqBlock extends Pointer {
    static { Loader.load(); }
    public CvSeqBlock() { allocate(); }
    public CvSeqBlock(int size) { allocateArray(size); }
    public CvSeqBlock(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSeqBlock position(int position) {
        return (CvSeqBlock)super.position(position);
    }

    public native CvSeqBlock prev(); public native CvSeqBlock prev(CvSeqBlock prev); /* Previous sequence block.                   */
    public native CvSeqBlock next(); public native CvSeqBlock next(CvSeqBlock next); /* Next sequence block.                       */
  public native int start_index(); public native CvSeqBlock start_index(int start_index);         /* Index of the first element in the block +  */
                              /* sequence->first->start_index.              */
    public native int count(); public native CvSeqBlock count(int count);             /* Number of elements in the block.           */
    public native @Cast("schar*") BytePointer data(); public native CvSeqBlock data(BytePointer data);              /* Pointer to the first element of the block. */
}


// #define CV_TREE_NODE_FIELDS(node_type)
//     int       flags;             /* Miscellaneous flags.     */
//     int       header_size;       /* Size of sequence header. */
//     struct    node_type* h_prev; /* Previous sequence.       */
//     struct    node_type* h_next; /* Next sequence.           */
//     struct    node_type* v_prev; /* 2nd previous sequence.   */
//     struct    node_type* v_next  /* 2nd next sequence.       */

/*
   Read/Write sequence.
   Elements can be dynamically inserted to or deleted from the sequence.
*/
// #define CV_SEQUENCE_FIELDS()
//     CV_TREE_NODE_FIELDS(CvSeq);
//     int       total;          /* Total number of elements.            */
//     int       elem_size;      /* Size of sequence element in bytes.   */
//     schar*    block_max;      /* Maximal bound of the last block.     */
//     schar*    ptr;            /* Current write pointer.               */
//     int       delta_elems;    /* Grow seq this many at a time.        */
//     CvMemStorage* storage;    /* Where the seq is stored.             */
//     CvSeqBlock* free_blocks;  /* Free blocks list.                    */
//     CvSeqBlock* first;        /* Pointer to the first sequence block. */

public static class CvSeq extends CvArr {
    static { Loader.load(); }
    public CvSeq() { allocate(); }
    public CvSeq(int size) { allocateArray(size); }
    public CvSeq(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSeq position(int position) {
        return (CvSeq)super.position(position);
    }

    public native int flags(); public native CvSeq flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvSeq header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvSeq h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvSeq h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvSeq v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvSeq v_next(CvSeq v_next);                                           
    public native int total(); public native CvSeq total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvSeq elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvSeq block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvSeq ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvSeq delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvSeq storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvSeq free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvSeq first(CvSeqBlock first);        /* Pointer to the first sequence block. */
}

public static final String CV_TYPE_NAME_SEQ =             "opencv-sequence";
public static final String CV_TYPE_NAME_SEQ_TREE =        "opencv-sequence-tree";

/*************************************** Set ********************************************/
/*
  Set.
  Order is not preserved. There can be gaps between sequence elements.
  After the element has been inserted it stays in the same place all the time.
  The MSB(most-significant or sign bit) of the first field (flags) is 0 iff the element exists.
*/
// #define CV_SET_ELEM_FIELDS(elem_type)
//     int  flags;
//     struct elem_type* next_free;

public static class CvSetElem extends Pointer {
    static { Loader.load(); }
    public CvSetElem() { allocate(); }
    public CvSetElem(int size) { allocateArray(size); }
    public CvSetElem(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSetElem position(int position) {
        return (CvSetElem)super.position(position);
    }

    public native int flags(); public native CvSetElem flags(int flags);                         
    public native CvSetElem next_free(); public native CvSetElem next_free(CvSetElem next_free);
}

// #define CV_SET_FIELDS()
//     CV_SEQUENCE_FIELDS()
//     CvSetElem* free_elems;
//     int active_count;

public static class CvSet extends Pointer {
    static { Loader.load(); }
    public CvSet() { allocate(); }
    public CvSet(int size) { allocateArray(size); }
    public CvSet(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSet position(int position) {
        return (CvSet)super.position(position);
    }

    public native int flags(); public native CvSet flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvSet header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvSet h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvSet h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvSet v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvSet v_next(CvSeq v_next);                                           
    public native int total(); public native CvSet total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvSet elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvSet block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvSet ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvSet delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvSet storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvSet free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvSet first(CvSeqBlock first);        /* Pointer to the first sequence block. */     
    public native CvSetElem free_elems(); public native CvSet free_elems(CvSetElem free_elems);   
    public native int active_count(); public native CvSet active_count(int active_count);
}


public static final int CV_SET_ELEM_IDX_MASK =   ((1 << 26) - 1);
public static native @MemberGetter int CV_SET_ELEM_FREE_FLAG();
public static final int CV_SET_ELEM_FREE_FLAG = CV_SET_ELEM_FREE_FLAG();

/* Checks whether the element pointed by ptr belongs to a set or not */
// #define CV_IS_SET_ELEM( ptr )  (((CvSetElem*)(ptr))->flags >= 0)

/************************************* Graph ********************************************/

/*
  We represent a graph as a set of vertices.
  Vertices contain their adjacency lists (more exactly, pointers to first incoming or
  outcoming edge (or 0 if isolated vertex)). Edges are stored in another set.
  There is a singly-linked list of incoming/outcoming edges for each vertex.

  Each edge consists of

     o   Two pointers to the starting and ending vertices
         (vtx[0] and vtx[1] respectively).

   A graph may be oriented or not. In the latter case, edges between
   vertex i to vertex j are not distinguished during search operations.

     o   Two pointers to next edges for the starting and ending vertices, where
         next[0] points to the next edge in the vtx[0] adjacency list and
         next[1] points to the next edge in the vtx[1] adjacency list.
*/
// #define CV_GRAPH_EDGE_FIELDS()
//     int flags;
//     float weight;
//     struct CvGraphEdge* next[2];
//     struct CvGraphVtx* vtx[2];


// #define CV_GRAPH_VERTEX_FIELDS()
//     int flags;
//     struct CvGraphEdge* first;


public static class CvGraphEdge extends Pointer {
    static { Loader.load(); }
    public CvGraphEdge() { allocate(); }
    public CvGraphEdge(int size) { allocateArray(size); }
    public CvGraphEdge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphEdge position(int position) {
        return (CvGraphEdge)super.position(position);
    }

    public native int flags(); public native CvGraphEdge flags(int flags);                      
    public native float weight(); public native CvGraphEdge weight(float weight);                   
    public native CvGraphEdge next(int i); public native CvGraphEdge next(int i, CvGraphEdge next);
    @MemberGetter public native @Cast("CvGraphEdge**") PointerPointer next();    
    public native CvGraphVtx vtx(int i); public native CvGraphEdge vtx(int i, CvGraphVtx vtx);
    @MemberGetter public native @Cast("CvGraphVtx**") PointerPointer vtx();
}

public static class CvGraphVtx extends Pointer {
    static { Loader.load(); }
    public CvGraphVtx() { allocate(); }
    public CvGraphVtx(int size) { allocateArray(size); }
    public CvGraphVtx(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphVtx position(int position) {
        return (CvGraphVtx)super.position(position);
    }

    public native int flags(); public native CvGraphVtx flags(int flags);                      
    public native CvGraphEdge first(); public native CvGraphVtx first(CvGraphEdge first);
}

public static class CvGraphVtx2D extends CvGraphVtx {
    static { Loader.load(); }
    public CvGraphVtx2D() { allocate(); }
    public CvGraphVtx2D(int size) { allocateArray(size); }
    public CvGraphVtx2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphVtx2D position(int position) {
        return (CvGraphVtx2D)super.position(position);
    }

    public native int flags(); public native CvGraphVtx2D flags(int flags);                      
    public native CvGraphEdge first(); public native CvGraphVtx2D first(CvGraphEdge first);
    public native CvPoint2D32f ptr(); public native CvGraphVtx2D ptr(CvPoint2D32f ptr);
}

/*
   Graph is "derived" from the set (this is set a of vertices)
   and includes another set (edges)
*/
// #define  CV_GRAPH_FIELDS()
//     CV_SET_FIELDS()
//     CvSet* edges;

public static class CvGraph extends CvSet {
    static { Loader.load(); }
    public CvGraph() { allocate(); }
    public CvGraph(int size) { allocateArray(size); }
    public CvGraph(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraph position(int position) {
        return (CvGraph)super.position(position);
    }

    public native int flags(); public native CvGraph flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvGraph header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvGraph h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvGraph h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvGraph v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvGraph v_next(CvSeq v_next);                                           
    public native int total(); public native CvGraph total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvGraph elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvGraph block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvGraph ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvGraph delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvGraph storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvGraph free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvGraph first(CvSeqBlock first);        /* Pointer to the first sequence block. */     
    public native CvSetElem free_elems(); public native CvGraph free_elems(CvSetElem free_elems);   
    public native int active_count(); public native CvGraph active_count(int active_count);          
    public native CvSet edges(); public native CvGraph edges(CvSet edges);
}

public static final String CV_TYPE_NAME_GRAPH = "opencv-graph";

/*********************************** Chain/Countour *************************************/

public static class CvChain extends CvSeq {
    static { Loader.load(); }
    public CvChain() { allocate(); }
    public CvChain(int size) { allocateArray(size); }
    public CvChain(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvChain position(int position) {
        return (CvChain)super.position(position);
    }

    public native int flags(); public native CvChain flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvChain header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvChain h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvChain h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvChain v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvChain v_next(CvSeq v_next);                                           
    public native int total(); public native CvChain total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvChain elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvChain block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvChain ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvChain delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvChain storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvChain free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvChain first(CvSeqBlock first);        /* Pointer to the first sequence block. */
    public native @ByVal CvPoint origin(); public native CvChain origin(CvPoint origin);
}

// #define CV_CONTOUR_FIELDS()
//     CV_SEQUENCE_FIELDS()
//     CvRect rect;
//     int color;
//     int reserved[3];

public static class CvContour extends CvSeq {
    static { Loader.load(); }
    public CvContour() { allocate(); }
    public CvContour(int size) { allocateArray(size); }
    public CvContour(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvContour position(int position) {
        return (CvContour)super.position(position);
    }

    public native int flags(); public native CvContour flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvContour header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvContour h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvContour h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvContour v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvContour v_next(CvSeq v_next);                                           
    public native int total(); public native CvContour total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvContour elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvContour block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvContour ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvContour delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvContour storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvContour free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvContour first(CvSeqBlock first);        /* Pointer to the first sequence block. */     
    public native @ByVal CvRect rect(); public native CvContour rect(CvRect rect);             
    public native int color(); public native CvContour color(int color);               
    public native int reserved(int i); public native CvContour reserved(int i, int reserved);
    @MemberGetter public native IntPointer reserved();
}

/****************************************************************************************\
*                                    Sequence types                                      *
\****************************************************************************************/

public static final int CV_SEQ_MAGIC_VAL =             0x42990000;

// #define CV_IS_SEQ(seq)
//     ((seq) != NULL && (((CvSeq*)(seq))->flags & CV_MAGIC_MASK) == CV_SEQ_MAGIC_VAL)

public static final int CV_SET_MAGIC_VAL =             0x42980000;
// #define CV_IS_SET(set)
//     ((set) != NULL && (((CvSeq*)(set))->flags & CV_MAGIC_MASK) == CV_SET_MAGIC_VAL)

public static final int CV_SEQ_ELTYPE_BITS =           12;
public static final int CV_SEQ_ELTYPE_MASK =           ((1 << CV_SEQ_ELTYPE_BITS) - 1);

public static final int CV_SEQ_ELTYPE_POINT =          CV_32SC2;  /* (x,y) */
public static final int CV_SEQ_ELTYPE_CODE =           CV_8UC1;   /* freeman code: 0..7 */
public static final int CV_SEQ_ELTYPE_GENERIC =        0;
public static final int CV_SEQ_ELTYPE_PTR =            CV_USRTYPE1;
public static final int CV_SEQ_ELTYPE_PPOINT =         CV_SEQ_ELTYPE_PTR;  /* &(x,y) */
public static final int CV_SEQ_ELTYPE_INDEX =          CV_32SC1;  /* #(x,y) */
public static final int CV_SEQ_ELTYPE_GRAPH_EDGE =     0;  /* &next_o, &next_d, &vtx_o, &vtx_d */
public static final int CV_SEQ_ELTYPE_GRAPH_VERTEX =   0;  /* first_edge, &(x,y) */
public static final int CV_SEQ_ELTYPE_TRIAN_ATR =      0;  /* vertex of the binary tree   */
public static final int CV_SEQ_ELTYPE_CONNECTED_COMP = 0;  /* connected component  */
public static final int CV_SEQ_ELTYPE_POINT3D =        CV_32FC3;  /* (x,y,z)  */

public static final int CV_SEQ_KIND_BITS =        2;
public static final int CV_SEQ_KIND_MASK =        (((1 << CV_SEQ_KIND_BITS) - 1)<<CV_SEQ_ELTYPE_BITS);

/* types of sequences */
public static final int CV_SEQ_KIND_GENERIC =     (0 << CV_SEQ_ELTYPE_BITS);
public static final int CV_SEQ_KIND_CURVE =       (1 << CV_SEQ_ELTYPE_BITS);
public static final int CV_SEQ_KIND_BIN_TREE =    (2 << CV_SEQ_ELTYPE_BITS);

/* types of sparse sequences (sets) */
public static final int CV_SEQ_KIND_GRAPH =       (1 << CV_SEQ_ELTYPE_BITS);
public static final int CV_SEQ_KIND_SUBDIV2D =    (2 << CV_SEQ_ELTYPE_BITS);

public static final int CV_SEQ_FLAG_SHIFT =       (CV_SEQ_KIND_BITS + CV_SEQ_ELTYPE_BITS);

/* flags for curves */
public static final int CV_SEQ_FLAG_CLOSED =     (1 << CV_SEQ_FLAG_SHIFT);
public static final int CV_SEQ_FLAG_SIMPLE =     (0 << CV_SEQ_FLAG_SHIFT);
public static final int CV_SEQ_FLAG_CONVEX =     (0 << CV_SEQ_FLAG_SHIFT);
public static final int CV_SEQ_FLAG_HOLE =       (2 << CV_SEQ_FLAG_SHIFT);

/* flags for graphs */
public static final int CV_GRAPH_FLAG_ORIENTED = (1 << CV_SEQ_FLAG_SHIFT);

public static final int CV_GRAPH =               CV_SEQ_KIND_GRAPH;
public static final int CV_ORIENTED_GRAPH =      (CV_SEQ_KIND_GRAPH|CV_GRAPH_FLAG_ORIENTED);

/* point sets */
public static final int CV_SEQ_POINT_SET =       (CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT);
public static final int CV_SEQ_POINT3D_SET =     (CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT3D);
public static final int CV_SEQ_POLYLINE =        (CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_POINT);
public static final int CV_SEQ_POLYGON =         (CV_SEQ_FLAG_CLOSED | CV_SEQ_POLYLINE );
public static final int CV_SEQ_CONTOUR =         CV_SEQ_POLYGON;
public static final int CV_SEQ_SIMPLE_POLYGON =  (CV_SEQ_FLAG_SIMPLE | CV_SEQ_POLYGON  );

/* chain-coded curves */
public static final int CV_SEQ_CHAIN =           (CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_CODE);
public static final int CV_SEQ_CHAIN_CONTOUR =   (CV_SEQ_FLAG_CLOSED | CV_SEQ_CHAIN);

/* binary tree for the contour */
public static final int CV_SEQ_POLYGON_TREE =    (CV_SEQ_KIND_BIN_TREE  | CV_SEQ_ELTYPE_TRIAN_ATR);

/* sequence of the connected components */
public static final int CV_SEQ_CONNECTED_COMP =  (CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_CONNECTED_COMP);

/* sequence of the integer numbers */
public static final int CV_SEQ_INDEX =           (CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_INDEX);

// #define CV_SEQ_ELTYPE( seq )   ((seq)->flags & CV_SEQ_ELTYPE_MASK)
// #define CV_SEQ_KIND( seq )     ((seq)->flags & CV_SEQ_KIND_MASK )

/* flag checking */
// #define CV_IS_SEQ_INDEX( seq )      ((CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_INDEX) &&
//                                      (CV_SEQ_KIND(seq) == CV_SEQ_KIND_GENERIC))

// #define CV_IS_SEQ_CURVE( seq )      (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE)
// #define CV_IS_SEQ_CLOSED( seq )     (((seq)->flags & CV_SEQ_FLAG_CLOSED) != 0)
// #define CV_IS_SEQ_CONVEX( seq )     0
// #define CV_IS_SEQ_HOLE( seq )       (((seq)->flags & CV_SEQ_FLAG_HOLE) != 0)
// #define CV_IS_SEQ_SIMPLE( seq )     1

/* type checking macros */
// #define CV_IS_SEQ_POINT_SET( seq )
//     ((CV_SEQ_ELTYPE(seq) == CV_32SC2 || CV_SEQ_ELTYPE(seq) == CV_32FC2))

// #define CV_IS_SEQ_POINT_SUBSET( seq )
//     (CV_IS_SEQ_INDEX( seq ) || CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_PPOINT)

// #define CV_IS_SEQ_POLYLINE( seq )
//     (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE && CV_IS_SEQ_POINT_SET(seq))

// #define CV_IS_SEQ_POLYGON( seq )
//     (CV_IS_SEQ_POLYLINE(seq) && CV_IS_SEQ_CLOSED(seq))

// #define CV_IS_SEQ_CHAIN( seq )
//     (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE && (seq)->elem_size == 1)

// #define CV_IS_SEQ_CONTOUR( seq )
//     (CV_IS_SEQ_CLOSED(seq) && (CV_IS_SEQ_POLYLINE(seq) || CV_IS_SEQ_CHAIN(seq)))

// #define CV_IS_SEQ_CHAIN_CONTOUR( seq )
//     (CV_IS_SEQ_CHAIN( seq ) && CV_IS_SEQ_CLOSED( seq ))

// #define CV_IS_SEQ_POLYGON_TREE( seq )
//     (CV_SEQ_ELTYPE (seq) ==  CV_SEQ_ELTYPE_TRIAN_ATR &&
//     CV_SEQ_KIND( seq ) ==  CV_SEQ_KIND_BIN_TREE )

// #define CV_IS_GRAPH( seq )
//     (CV_IS_SET(seq) && CV_SEQ_KIND((CvSet*)(seq)) == CV_SEQ_KIND_GRAPH)

// #define CV_IS_GRAPH_ORIENTED( seq )
//     (((seq)->flags & CV_GRAPH_FLAG_ORIENTED) != 0)

// #define CV_IS_SUBDIV2D( seq )
//     (CV_IS_SET(seq) && CV_SEQ_KIND((CvSet*)(seq)) == CV_SEQ_KIND_SUBDIV2D)

/****************************************************************************************/
/*                            Sequence writer & reader                                  */
/****************************************************************************************/

// #define CV_SEQ_WRITER_FIELDS()
//     int          header_size;
//     CvSeq*       seq;        /* the sequence written */
//     CvSeqBlock*  block;      /* current block */
//     schar*       ptr;        /* pointer to free space */
//     schar*       block_min;  /* pointer to the beginning of block*/
//     schar*       block_max;  /* pointer to the end of block */

public static class CvSeqWriter extends Pointer {
    static { Loader.load(); }
    public CvSeqWriter() { allocate(); }
    public CvSeqWriter(int size) { allocateArray(size); }
    public CvSeqWriter(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSeqWriter position(int position) {
        return (CvSeqWriter)super.position(position);
    }

    public native int header_size(); public native CvSeqWriter header_size(int header_size);                                      
    public native CvSeq seq(); public native CvSeqWriter seq(CvSeq seq);        /* the sequence written */            
    public native CvSeqBlock block(); public native CvSeqWriter block(CvSeqBlock block);      /* current block */                   
    public native @Cast("schar*") BytePointer ptr(); public native CvSeqWriter ptr(BytePointer ptr);        /* pointer to free space */           
    public native @Cast("schar*") BytePointer block_min(); public native CvSeqWriter block_min(BytePointer block_min);  /* pointer to the beginning of block*/
    public native @Cast("schar*") BytePointer block_max(); public native CvSeqWriter block_max(BytePointer block_max);  /* pointer to the end of block */
}


// #define CV_SEQ_READER_FIELDS()
//     int          header_size;
//     CvSeq*       seq;        /* sequence, beign read */
//     CvSeqBlock*  block;      /* current block */
//     schar*       ptr;        /* pointer to element be read next */
//     schar*       block_min;  /* pointer to the beginning of block */
//     schar*       block_max;  /* pointer to the end of block */
//     int          delta_index;/* = seq->first->start_index   */
//     schar*       prev_elem;  /* pointer to previous element */


public static class CvSeqReader extends Pointer {
    static { Loader.load(); }
    public CvSeqReader() { allocate(); }
    public CvSeqReader(int size) { allocateArray(size); }
    public CvSeqReader(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSeqReader position(int position) {
        return (CvSeqReader)super.position(position);
    }

    public native int header_size(); public native CvSeqReader header_size(int header_size);                                       
    public native CvSeq seq(); public native CvSeqReader seq(CvSeq seq);        /* sequence, beign read */             
    public native CvSeqBlock block(); public native CvSeqReader block(CvSeqBlock block);      /* current block */                    
    public native @Cast("schar*") BytePointer ptr(); public native CvSeqReader ptr(BytePointer ptr);        /* pointer to element be read next */  
    public native @Cast("schar*") BytePointer block_min(); public native CvSeqReader block_min(BytePointer block_min);  /* pointer to the beginning of block */
    public native @Cast("schar*") BytePointer block_max(); public native CvSeqReader block_max(BytePointer block_max);  /* pointer to the end of block */      
    public native int delta_index(); public native CvSeqReader delta_index(int delta_index);/* = seq->first->start_index   */      
    public native @Cast("schar*") BytePointer prev_elem(); public native CvSeqReader prev_elem(BytePointer prev_elem);  /* pointer to previous element */
}

/****************************************************************************************/
/*                                Operations on sequences                               */
/****************************************************************************************/

// #define  CV_SEQ_ELEM( seq, elem_type, index )
// /* assert gives some guarantee that <seq> parameter is valid */
// (   assert(sizeof((seq)->first[0]) == sizeof(CvSeqBlock) &&
//     (seq)->elem_size == sizeof(elem_type)),
//     (elem_type*)((seq)->first && (unsigned)index <
//     (unsigned)((seq)->first->count) ?
//     (seq)->first->data + (index) * sizeof(elem_type) :
//     cvGetSeqElem( (CvSeq*)(seq), (index) )))
// #define CV_GET_SEQ_ELEM( elem_type, seq, index ) CV_SEQ_ELEM( (seq), elem_type, (index) )

/* Add element to sequence: */
// #define CV_WRITE_SEQ_ELEM_VAR( elem_ptr, writer )
// {
//     if( (writer).ptr >= (writer).bock_max )
//     {
//         cvCreateSeqBlock( &writer);
//     }
//     memcpy((writer).ptr, elem_ptr, (writer).seq->elem_size);
//     (writer).ptr += (writer).seq->elem_size;
// }

// #define CV_WRITE_SEQ_ELEM( elem, writer )
// {
//     assert( (writer).seq->elem_size == sizeof(elem));
//     if( (writer).ptr >= (writer).bock_max )
//     {
//         cvCreateSeqBlock( &writer);
//     }
//     assert( (writer).ptr <= (writer).bock_max - sizeof(elem));
//     memcpy((writer).ptr, &(elem), sizeof(elem));
//     (writer).ptr += sizeof(elem);
// }


/* Move reader position forward: */
// #define CV_NEXT_SEQ_ELEM( elem_size, reader )
// {
//     if( ((reader).ptr += (elem_size)) >= (reader).bock_max )
//     {
//         cvChangeSeqBlock( &(reader), 1 );
//     }
// }


/* Move reader position backward: */
// #define CV_PREV_SEQ_ELEM( elem_size, reader )
// {
//     if( ((reader).ptr -= (elem_size)) < (reader).bock_min )
//     {
//         cvChangeSeqBlock( &(reader), -1 );
//     }
// }

/* Read element and move read position forward: */
// #define CV_READ_SEQ_ELEM( elem, reader )
// {
//     assert( (reader).seq->elem_size == sizeof(elem));
//     memcpy( &(elem), (reader).ptr, sizeof((elem)));
//     CV_NEXT_SEQ_ELEM( sizeof(elem), reader )
// }

/* Read element and move read position backward: */
// #define CV_REV_READ_SEQ_ELEM( elem, reader )
// {
//     assert( (reader).seq->elem_size == sizeof(elem));
//     memcpy(&(elem), (reader).ptr, sizeof((elem)));
//     CV_PREV_SEQ_ELEM( sizeof(elem), reader )
// }


// #define CV_READ_CHAIN_POINT( _pt, reader )
// {
//     (_pt) = (reader).pt;
//     if( (reader).ptr )
//     {
//         CV_READ_SEQ_ELEM( (reader).code, (reader));
//         assert( ((reader).code & ~7) == 0 );
//         (reader).pt.x += (reader).detas[(int)(reader).code][0];
//         (reader).pt.y += (reader).detas[(int)(reader).code][1];
//     }
// }

// #define CV_CURRENT_POINT( reader )  (*((CvPoint*)((reader).ptr)))
// #define CV_PREV_POINT( reader )     (*((CvPoint*)((reader).prev_elem)))

// #define CV_READ_EDGE( pt1, pt2, reader )
// {
//     assert( sizeof(pt1) == sizeof(CvPoint) &&
//             sizeof(pt2) == sizeof(CvPoint) &&
//             reader.seq->elem_size == sizeof(CvPoint));
//     (pt1) = CV_PREV_POINT( reader );
//     (pt2) = CV_CURRENT_POINT( reader );
//     (reader).prev_elem = (reader).ptr;
//     CV_NEXT_SEQ_ELEM( sizeof(CvPoint), (reader));
// }

/************ Graph macros ************/

/* Return next graph edge for given vertex: */
// #define  CV_NEXT_GRAPH_EDGE( edge, vertex )
//      (assert((edge)->vtx[0] == (vertex) || (edge)->vtx[1] == (vertex)),
//       (edge)->next[(edge)->vtx[1] == (vertex)])



/****************************************************************************************\
*             Data structures for persistence (a.k.a serialization) functionality        *
\****************************************************************************************/

/* "black box" file storage */
@Opaque public static class CvFileStorage extends Pointer {
    public CvFileStorage() { }
    public CvFileStorage(Pointer p) { super(p); }
}

/* Storage flags: */
public static final int CV_STORAGE_READ =          0;
public static final int CV_STORAGE_WRITE =         1;
public static final int CV_STORAGE_WRITE_TEXT =    CV_STORAGE_WRITE;
public static final int CV_STORAGE_WRITE_BINARY =  CV_STORAGE_WRITE;
public static final int CV_STORAGE_APPEND =        2;
public static final int CV_STORAGE_MEMORY =        4;
public static final int CV_STORAGE_FORMAT_MASK =   (7<<3);
public static final int CV_STORAGE_FORMAT_AUTO =   0;
public static final int CV_STORAGE_FORMAT_XML =    8;
public static final int CV_STORAGE_FORMAT_YAML =  16;

/* List of attributes: */
public static class CvAttrList extends Pointer {
    static { Loader.load(); }
    public CvAttrList() { allocate(); }
    public CvAttrList(int size) { allocateArray(size); }
    public CvAttrList(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvAttrList position(int position) {
        return (CvAttrList)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer attr(int i);
    @MemberGetter public native @Cast("const char**") PointerPointer attr();         /* NULL-terminated array of (attribute_name,attribute_value) pairs. */
    public native CvAttrList next(); public native CvAttrList next(CvAttrList next);   /* Pointer to next chunk of the attributes list.                    */
}

public static native @ByVal CvAttrList cvAttrList( @Cast("const char**") PointerPointer attr/*CV_DEFAULT(NULL)*/,
                                 CvAttrList next/*CV_DEFAULT(NULL)*/ );
public static native @ByVal CvAttrList cvAttrList( @Cast("const char**") @ByPtrPtr BytePointer attr/*CV_DEFAULT(NULL)*/,
                                 CvAttrList next/*CV_DEFAULT(NULL)*/ );
public static native @ByVal CvAttrList cvAttrList( @Cast("const char**") @ByPtrPtr ByteBuffer attr/*CV_DEFAULT(NULL)*/,
                                 CvAttrList next/*CV_DEFAULT(NULL)*/ );
public static native @ByVal CvAttrList cvAttrList( @Cast("const char**") @ByPtrPtr byte[] attr/*CV_DEFAULT(NULL)*/,
                                 CvAttrList next/*CV_DEFAULT(NULL)*/ );

public static final int CV_NODE_NONE =        0;
public static final int CV_NODE_INT =         1;
public static final int CV_NODE_INTEGER =     CV_NODE_INT;
public static final int CV_NODE_REAL =        2;
public static final int CV_NODE_FLOAT =       CV_NODE_REAL;
public static final int CV_NODE_STR =         3;
public static final int CV_NODE_STRING =      CV_NODE_STR;
public static final int CV_NODE_REF =         4; /* not used */
public static final int CV_NODE_SEQ =         5;
public static final int CV_NODE_MAP =         6;
public static final int CV_NODE_TYPE_MASK =   7;

// #define CV_NODE_TYPE(flags)  ((flags) & CV_NODE_TYPE_MASK)

/* file node flags */
public static final int CV_NODE_FLOW =        8; /* Used only for writing structures in YAML format. */
public static final int CV_NODE_USER =        16;
public static final int CV_NODE_EMPTY =       32;
public static final int CV_NODE_NAMED =       64;

// #define CV_NODE_IS_INT(flags)        (CV_NODE_TYPE(flags) == CV_NODE_INT)
// #define CV_NODE_IS_REAL(flags)       (CV_NODE_TYPE(flags) == CV_NODE_REAL)
// #define CV_NODE_IS_STRING(flags)     (CV_NODE_TYPE(flags) == CV_NODE_STRING)
// #define CV_NODE_IS_SEQ(flags)        (CV_NODE_TYPE(flags) == CV_NODE_SEQ)
// #define CV_NODE_IS_MAP(flags)        (CV_NODE_TYPE(flags) == CV_NODE_MAP)
// #define CV_NODE_IS_COLLECTION(flags) (CV_NODE_TYPE(flags) >= CV_NODE_SEQ)
// #define CV_NODE_IS_FLOW(flags)       (((flags) & CV_NODE_FLOW) != 0)
// #define CV_NODE_IS_EMPTY(flags)      (((flags) & CV_NODE_EMPTY) != 0)
// #define CV_NODE_IS_USER(flags)       (((flags) & CV_NODE_USER) != 0)
// #define CV_NODE_HAS_NAME(flags)      (((flags) & CV_NODE_NAMED) != 0)

public static final int CV_NODE_SEQ_SIMPLE = 256;
// #define CV_NODE_SEQ_IS_SIMPLE(seq) (((seq)->flags & CV_NODE_SEQ_SIMPLE) != 0)

public static class CvString extends Pointer {
    static { Loader.load(); }
    public CvString() { allocate(); }
    public CvString(int size) { allocateArray(size); }
    public CvString(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvString position(int position) {
        return (CvString)super.position(position);
    }

    public native int len(); public native CvString len(int len);
    public native @Cast("char*") BytePointer ptr(); public native CvString ptr(BytePointer ptr);
}

/* All the keys (names) of elements in the readed file storage
   are stored in the hash to speed up the lookup operations: */
public static class CvStringHashNode extends Pointer {
    static { Loader.load(); }
    public CvStringHashNode() { allocate(); }
    public CvStringHashNode(int size) { allocateArray(size); }
    public CvStringHashNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStringHashNode position(int position) {
        return (CvStringHashNode)super.position(position);
    }

    public native @Cast("unsigned") int hashval(); public native CvStringHashNode hashval(int hashval);
    public native @ByVal CvString str(); public native CvStringHashNode str(CvString str);
    public native CvStringHashNode next(); public native CvStringHashNode next(CvStringHashNode next);
}

@Opaque public static class CvFileNodeHash extends Pointer {
    public CvFileNodeHash() { }
    public CvFileNodeHash(Pointer p) { super(p); }
}

/* Basic element of the file storage - scalar or collection: */
public static class CvFileNode extends Pointer {
    static { Loader.load(); }
    public CvFileNode() { allocate(); }
    public CvFileNode(int size) { allocateArray(size); }
    public CvFileNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvFileNode position(int position) {
        return (CvFileNode)super.position(position);
    }

    public native int tag(); public native CvFileNode tag(int tag);
    public native CvTypeInfo info(); public native CvFileNode info(CvTypeInfo info); /* type information
            (only for user-defined object, for others it is 0) */
        @Name({"data", ".f"}) public native double data_f(); public native CvFileNode data_f(double data_f); /* scalar floating-point number */
        @Name({"data", ".i"}) public native int data_i(); public native CvFileNode data_i(int data_i);    /* scalar integer number */
        @Name({"data", ".str"}) public native @ByVal CvString data_str(); public native CvFileNode data_str(CvString data_str); /* text string */
        @Name({"data", ".seq"}) public native CvSeq data_seq(); public native CvFileNode data_seq(CvSeq data_seq); /* sequence (ordered collection of file nodes) */
        @Name({"data", ".map"}) public native CvFileNodeHash data_map(); public native CvFileNode data_map(CvFileNodeHash data_map); /* map (collection of named file nodes) */
}

// #ifdef __cplusplus
// #endif
public static class CvIsInstanceFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvIsInstanceFunc(Pointer p) { super(p); }
    protected CvIsInstanceFunc() { allocate(); }
    private native void allocate();
    public native int call( @Const Pointer struct_ptr );
}
public static class CvReleaseFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvReleaseFunc(Pointer p) { super(p); }
    protected CvReleaseFunc() { allocate(); }
    private native void allocate();
    public native void call( @Cast("void**") @ByPtrPtr Pointer struct_dblptr );
}
public static class CvReadFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvReadFunc(Pointer p) { super(p); }
    protected CvReadFunc() { allocate(); }
    private native void allocate();
    public native Pointer call( CvFileStorage storage, CvFileNode node );
}
public static class CvWriteFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvWriteFunc(Pointer p) { super(p); }
    protected CvWriteFunc() { allocate(); }
    private native void allocate();
    public native void call( CvFileStorage storage, @Cast("const char*") BytePointer name,
                                      @Const Pointer struct_ptr, @ByVal CvAttrList attributes );
}
public static class CvCloneFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvCloneFunc(Pointer p) { super(p); }
    protected CvCloneFunc() { allocate(); }
    private native void allocate();
    public native Pointer call( @Const Pointer struct_ptr );
}
// #ifdef __cplusplus
// #endif

public static class CvTypeInfo extends Pointer {
    static { Loader.load(); }
    public CvTypeInfo() { allocate(); }
    public CvTypeInfo(int size) { allocateArray(size); }
    public CvTypeInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvTypeInfo position(int position) {
        return (CvTypeInfo)super.position(position);
    }

    public native int flags(); public native CvTypeInfo flags(int flags);
    public native int header_size(); public native CvTypeInfo header_size(int header_size);
    public native CvTypeInfo prev(); public native CvTypeInfo prev(CvTypeInfo prev);
    public native CvTypeInfo next(); public native CvTypeInfo next(CvTypeInfo next);
    @MemberGetter public native @Cast("const char*") BytePointer type_name();
    public native CvIsInstanceFunc is_instance(); public native CvTypeInfo is_instance(CvIsInstanceFunc is_instance);
    public native CvReleaseFunc release(); public native CvTypeInfo release(CvReleaseFunc release);
    public native CvReadFunc read(); public native CvTypeInfo read(CvReadFunc read);
    public native CvWriteFunc write(); public native CvTypeInfo write(CvWriteFunc write);
    public native CvCloneFunc clone(); public native CvTypeInfo clone(CvCloneFunc clone);
}


/**** System data types ******/

public static class CvPluginFuncInfo extends Pointer {
    static { Loader.load(); }
    public CvPluginFuncInfo() { allocate(); }
    public CvPluginFuncInfo(int size) { allocateArray(size); }
    public CvPluginFuncInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPluginFuncInfo position(int position) {
        return (CvPluginFuncInfo)super.position(position);
    }

    public native Pointer func_addr(int i); public native CvPluginFuncInfo func_addr(int i, Pointer func_addr);
    @MemberGetter public native @Cast("void**") PointerPointer func_addr();
    public native Pointer default_func_addr(); public native CvPluginFuncInfo default_func_addr(Pointer default_func_addr);
    @MemberGetter public native @Cast("const char*") BytePointer func_names();
    public native int search_modules(); public native CvPluginFuncInfo search_modules(int search_modules);
    public native int loaded_from(); public native CvPluginFuncInfo loaded_from(int loaded_from);
}

public static class CvModuleInfo extends Pointer {
    static { Loader.load(); }
    public CvModuleInfo() { allocate(); }
    public CvModuleInfo(int size) { allocateArray(size); }
    public CvModuleInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvModuleInfo position(int position) {
        return (CvModuleInfo)super.position(position);
    }

    public native CvModuleInfo next(); public native CvModuleInfo next(CvModuleInfo next);
    @MemberGetter public native @Cast("const char*") BytePointer name();
    @MemberGetter public native @Cast("const char*") BytePointer version();
    public native CvPluginFuncInfo func_tab(); public native CvModuleInfo func_tab(CvPluginFuncInfo func_tab);
}

// #endif /*__OPENCV_CORE_TYPES_H__*/

/* End of file. */


/* Wrapper for header file /usr/local/include/opencv2/core/core_c.h */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/


// #ifndef __OPENCV_CORE_C_H__
// #define __OPENCV_CORE_C_H__

// #include "opencv2/core/types_c.h"

// #ifdef __cplusplus
/**malloc> wrapper.
   If there is no enough memory, the function
   (as well as other OpenCV functions that call cvAlloc)
   raises an error. */
// #endif

/****************************************************************************************\
*          Array allocation, deallocation, initialization and access to elements         *
\****************************************************************************************/
/**free> wrapper.
   Here and further all the memory releasing functions
   (that all call cvFree) take double pointer in order to
   to clear pointer to the data after releasing it.
   Passing pointer to NULL pointer is Ok: nothing happens in this case
*/
public static native Pointer cvAlloc( @Cast("size_t") long size );
public static native void cvFree_( Pointer ptr );
// #define cvFree(ptr) (cvFree_(*(ptr)), *(ptr)=0)

/* Allocates and initializes IplImage header */
public static native IplImage cvCreateImageHeader( @ByVal CvSize size, int depth, int channels );

/* Inializes IplImage header */
public static native IplImage cvInitImageHeader( IplImage image, @ByVal CvSize size, int depth,
                                   int channels, int origin/*CV_DEFAULT(0)*/,
                                   int align/*CV_DEFAULT(4)*/);

/* Creates IPL image (header and data) */
public static native IplImage cvCreateImage( @ByVal CvSize size, int depth, int channels );

/* Releases (i.e. deallocates) IPL image header */
public static native void cvReleaseImageHeader( @Cast("IplImage**") PointerPointer image );
public static native void cvReleaseImageHeader( @ByPtrPtr IplImage image );

/* Releases IPL image header and data */
public static native void cvReleaseImage( @Cast("IplImage**") PointerPointer image );
public static native void cvReleaseImage( @ByPtrPtr IplImage image );

/* Creates a copy of IPL image (widthStep may differ) */
public static native IplImage cvCloneImage( @Const IplImage image );

/* Sets a Channel Of Interest (only a few functions support COI) -
   use cvCopy to extract the selected channel and/or put it back */
public static native void cvSetImageCOI( IplImage image, int coi );

/* Retrieves image Channel Of Interest */
public static native int cvGetImageCOI( @Const IplImage image );

/* Sets image ROI (region of interest) (COI is not changed) */
public static native void cvSetImageROI( IplImage image, @ByVal CvRect rect );

/* Resets image ROI and COI */
public static native void cvResetImageROI( IplImage image );

/* Retrieves image ROI */
public static native @ByVal CvRect cvGetImageROI( @Const IplImage image );

/* Allocates and initalizes CvMat header */
public static native CvMat cvCreateMatHeader( int rows, int cols, int type );

public static final int CV_AUTOSTEP =  0x7fffffff;

/* Initializes CvMat header */
public static native CvMat cvInitMatHeader( CvMat mat, int rows, int cols,
                              int type, Pointer data/*CV_DEFAULT(NULL)*/,
                              int step/*CV_DEFAULT(CV_AUTOSTEP)*/ );

/* Allocates and initializes CvMat header and allocates data */
public static native CvMat cvCreateMat( int rows, int cols, int type );

/* Releases CvMat header and deallocates matrix data
   (reference counting is used for data) */
public static native void cvReleaseMat( @Cast("CvMat**") PointerPointer mat );
public static native void cvReleaseMat( @ByPtrPtr CvMat mat );

/* Decrements CvMat data reference counter and deallocates the data if
   it reaches 0 */
public static native void cvDecRefData( CvArr arr );

/* Increments CvMat data reference counter */
public static native int cvIncRefData( CvArr arr );


/* Creates an exact copy of the input matrix (except, may be, step value) */
public static native CvMat cvCloneMat( @Const CvMat mat );


/* Makes a new matrix from <rect> subrectangle of input array.
   No data is copied */
public static native CvMat cvGetSubRect( @Const CvArr arr, CvMat submat, @ByVal CvRect rect );
public static native CvMat cvGetSubArr(CvArr arg1, CvMat arg2, @ByVal CvRect arg3);

/* Selects row span of the input array: arr(start_row:delta_row:end_row,:)
    (end_row is not included into the span). */
public static native CvMat cvGetRows( @Const CvArr arr, CvMat submat,
                        int start_row, int end_row,
                        int delta_row/*CV_DEFAULT(1)*/);

public static native CvMat cvGetRow( @Const CvArr arr, CvMat submat, int row );


/* Selects column span of the input array: arr(:,start_col:end_col)
   (end_col is not included into the span) */
public static native CvMat cvGetCols( @Const CvArr arr, CvMat submat,
                        int start_col, int end_col );

public static native CvMat cvGetCol( @Const CvArr arr, CvMat submat, int col );

/* Select a diagonal of the input array.
   (diag = 0 means the main diagonal, >0 means a diagonal above the main one,
   <0 - below the main one).
   The diagonal will be represented as a column (nx1 matrix). */
public static native CvMat cvGetDiag( @Const CvArr arr, CvMat submat,
                            int diag/*CV_DEFAULT(0)*/);

/* low-level scalar <-> raw data conversion functions */
public static native void cvScalarToRawData( @Const CvScalar scalar, Pointer data, int type,
                              int extend_to_12/*CV_DEFAULT(0)*/ );

public static native void cvRawDataToScalar( @Const Pointer data, int type, CvScalar scalar );

/* Allocates and initializes CvMatND header */
public static native CvMatND cvCreateMatNDHeader( int dims, @Const IntPointer sizes, int type );
public static native CvMatND cvCreateMatNDHeader( int dims, @Const IntBuffer sizes, int type );
public static native CvMatND cvCreateMatNDHeader( int dims, @Const int[] sizes, int type );

/* Allocates and initializes CvMatND header and allocates data */
public static native CvMatND cvCreateMatND( int dims, @Const IntPointer sizes, int type );
public static native CvMatND cvCreateMatND( int dims, @Const IntBuffer sizes, int type );
public static native CvMatND cvCreateMatND( int dims, @Const int[] sizes, int type );

/* Initializes preallocated CvMatND header */
public static native CvMatND cvInitMatNDHeader( CvMatND mat, int dims, @Const IntPointer sizes,
                                    int type, Pointer data/*CV_DEFAULT(NULL)*/ );
public static native CvMatND cvInitMatNDHeader( CvMatND mat, int dims, @Const IntBuffer sizes,
                                    int type, Pointer data/*CV_DEFAULT(NULL)*/ );
public static native CvMatND cvInitMatNDHeader( CvMatND mat, int dims, @Const int[] sizes,
                                    int type, Pointer data/*CV_DEFAULT(NULL)*/ );

/* Releases CvMatND */
public static native void cvReleaseMatND( @Cast("CvMatND**") PointerPointer mat );
public static native void cvReleaseMatND( @ByPtrPtr CvMatND mat );

/* Creates a copy of CvMatND (except, may be, steps) */
public static native CvMatND cvCloneMatND( @Const CvMatND mat );

/* Allocates and initializes CvSparseMat header and allocates data */
public static native CvSparseMat cvCreateSparseMat( int dims, @Const IntPointer sizes, int type );
public static native CvSparseMat cvCreateSparseMat( int dims, @Const IntBuffer sizes, int type );
public static native CvSparseMat cvCreateSparseMat( int dims, @Const int[] sizes, int type );

/* Releases CvSparseMat */
public static native void cvReleaseSparseMat( @Cast("CvSparseMat**") PointerPointer mat );
public static native void cvReleaseSparseMat( @ByPtrPtr CvSparseMat mat );

/* Creates a copy of CvSparseMat (except, may be, zero items) */
public static native CvSparseMat cvCloneSparseMat( @Const CvSparseMat mat );

/* Initializes sparse array iterator
   (returns the first node or NULL if the array is empty) */
public static native CvSparseNode cvInitSparseMatIterator( @Const CvSparseMat mat,
                                              CvSparseMatIterator mat_iterator );

// returns next sparse array node (or NULL if there is no more nodes)
public static native CvSparseNode cvGetNextSparseNode( CvSparseMatIterator mat_iterator );

/**************** matrix iterator: used for n-ary operations on dense arrays *********/

public static final int CV_MAX_ARR = 10;

public static class CvNArrayIterator extends Pointer {
    static { Loader.load(); }
    public CvNArrayIterator() { allocate(); }
    public CvNArrayIterator(int size) { allocateArray(size); }
    public CvNArrayIterator(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvNArrayIterator position(int position) {
        return (CvNArrayIterator)super.position(position);
    }

    public native int count(); public native CvNArrayIterator count(int count); /* number of arrays */
    public native int dims(); public native CvNArrayIterator dims(int dims); /* number of dimensions to iterate */
    public native @ByVal CvSize size(); public native CvNArrayIterator size(CvSize size); /* maximal common linear size: { width = size, height = 1 } */
    public native @Cast("uchar*") BytePointer ptr(int i); public native CvNArrayIterator ptr(int i, BytePointer ptr);
    @MemberGetter public native @Cast("uchar**") PointerPointer ptr(); /* pointers to the array slices */
    public native int stack(int i); public native CvNArrayIterator stack(int i, int stack);
    @MemberGetter public native IntPointer stack(); /* for internal use */
    public native CvMatND hdr(int i); public native CvNArrayIterator hdr(int i, CvMatND hdr);
    @MemberGetter public native @Cast("CvMatND**") PointerPointer hdr(); /* pointers to the headers of the
                                 matrices that are processed */
}

public static final int CV_NO_DEPTH_CHECK =     1;
public static final int CV_NO_CN_CHECK =        2;
public static final int CV_NO_SIZE_CHECK =      4;

/* initializes iterator that traverses through several arrays simulteneously
   (the function together with cvNextArraySlice is used for
    N-ari element-wise operations) */
public static native int cvInitNArrayIterator( int count, @Cast("CvArr**") PointerPointer arrs,
                                 @Const CvArr mask, CvMatND stubs,
                                 CvNArrayIterator array_iterator,
                                 int flags/*CV_DEFAULT(0)*/ );
public static native int cvInitNArrayIterator( int count, @ByPtrPtr CvArr arrs,
                                 @Const CvArr mask, CvMatND stubs,
                                 CvNArrayIterator array_iterator,
                                 int flags/*CV_DEFAULT(0)*/ );

/* returns zero value if iteration is finished, non-zero (slice length) otherwise */
public static native int cvNextNArraySlice( CvNArrayIterator array_iterator );


/* Returns type of array elements:
   CV_8UC1 ... CV_64FC4 ... */
public static native int cvGetElemType( @Const CvArr arr );

/* Retrieves number of an array dimensions and
   optionally sizes of the dimensions */
public static native int cvGetDims( @Const CvArr arr, IntPointer sizes/*CV_DEFAULT(NULL)*/ );
public static native int cvGetDims( @Const CvArr arr, IntBuffer sizes/*CV_DEFAULT(NULL)*/ );
public static native int cvGetDims( @Const CvArr arr, int[] sizes/*CV_DEFAULT(NULL)*/ );


/* Retrieves size of a particular array dimension.
   For 2d arrays cvGetDimSize(arr,0) returns number of rows (image height)
   and cvGetDimSize(arr,1) returns number of columns (image width) */
public static native int cvGetDimSize( @Const CvArr arr, int index );


/* ptr = &arr(idx0,idx1,...). All indexes are zero-based,
   the major dimensions go first (e.g. (y,x) for 2D, (z,y,x) for 3D */
public static native @Cast("uchar*") BytePointer cvPtr1D( @Const CvArr arr, int idx0, IntPointer type/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") ByteBuffer cvPtr1D( @Const CvArr arr, int idx0, IntBuffer type/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") byte[] cvPtr1D( @Const CvArr arr, int idx0, int[] type/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") BytePointer cvPtr2D( @Const CvArr arr, int idx0, int idx1, IntPointer type/*CV_DEFAULT(NULL)*/ );
public static native @Cast("uchar*") ByteBuffer cvPtr2D( @Const CvArr arr, int idx0, int idx1, IntBuffer type/*CV_DEFAULT(NULL)*/ );
public static native @Cast("uchar*") byte[] cvPtr2D( @Const CvArr arr, int idx0, int idx1, int[] type/*CV_DEFAULT(NULL)*/ );
public static native @Cast("uchar*") BytePointer cvPtr3D( @Const CvArr arr, int idx0, int idx1, int idx2,
                      IntPointer type/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") ByteBuffer cvPtr3D( @Const CvArr arr, int idx0, int idx1, int idx2,
                      IntBuffer type/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") byte[] cvPtr3D( @Const CvArr arr, int idx0, int idx1, int idx2,
                      int[] type/*CV_DEFAULT(NULL)*/);

/* For CvMat or IplImage number of indices should be 2
   (row index (y) goes first, column index (x) goes next).
   For CvMatND or CvSparseMat number of infices should match number of <dims> and
   indices order should match the array dimension order. */
public static native @Cast("uchar*") BytePointer cvPtrND( @Const CvArr arr, @Const IntPointer idx, IntPointer type/*CV_DEFAULT(NULL)*/,
                      int create_node/*CV_DEFAULT(1)*/,
                      @Cast("unsigned*") IntPointer precalc_hashval/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") ByteBuffer cvPtrND( @Const CvArr arr, @Const IntBuffer idx, IntBuffer type/*CV_DEFAULT(NULL)*/,
                      int create_node/*CV_DEFAULT(1)*/,
                      @Cast("unsigned*") IntBuffer precalc_hashval/*CV_DEFAULT(NULL)*/);
public static native @Cast("uchar*") byte[] cvPtrND( @Const CvArr arr, @Const int[] idx, int[] type/*CV_DEFAULT(NULL)*/,
                      int create_node/*CV_DEFAULT(1)*/,
                      @Cast("unsigned*") int[] precalc_hashval/*CV_DEFAULT(NULL)*/);

/* value = arr(idx0,idx1,...) */
public static native @ByVal CvScalar cvGet1D( @Const CvArr arr, int idx0 );
public static native @ByVal CvScalar cvGet2D( @Const CvArr arr, int idx0, int idx1 );
public static native @ByVal CvScalar cvGet3D( @Const CvArr arr, int idx0, int idx1, int idx2 );
public static native @ByVal CvScalar cvGetND( @Const CvArr arr, @Const IntPointer idx );
public static native @ByVal CvScalar cvGetND( @Const CvArr arr, @Const IntBuffer idx );
public static native @ByVal CvScalar cvGetND( @Const CvArr arr, @Const int[] idx );

/* for 1-channel arrays */
public static native double cvGetReal1D( @Const CvArr arr, int idx0 );
public static native double cvGetReal2D( @Const CvArr arr, int idx0, int idx1 );
public static native double cvGetReal3D( @Const CvArr arr, int idx0, int idx1, int idx2 );
public static native double cvGetRealND( @Const CvArr arr, @Const IntPointer idx );
public static native double cvGetRealND( @Const CvArr arr, @Const IntBuffer idx );
public static native double cvGetRealND( @Const CvArr arr, @Const int[] idx );

/* arr(idx0,idx1,...) = value */
public static native void cvSet1D( CvArr arr, int idx0, @ByVal CvScalar value );
public static native void cvSet2D( CvArr arr, int idx0, int idx1, @ByVal CvScalar value );
public static native void cvSet3D( CvArr arr, int idx0, int idx1, int idx2, @ByVal CvScalar value );
public static native void cvSetND( CvArr arr, @Const IntPointer idx, @ByVal CvScalar value );
public static native void cvSetND( CvArr arr, @Const IntBuffer idx, @ByVal CvScalar value );
public static native void cvSetND( CvArr arr, @Const int[] idx, @ByVal CvScalar value );

/* for 1-channel arrays */
public static native void cvSetReal1D( CvArr arr, int idx0, double value );
public static native void cvSetReal2D( CvArr arr, int idx0, int idx1, double value );
public static native void cvSetReal3D( CvArr arr, int idx0,
                        int idx1, int idx2, double value );
public static native void cvSetRealND( CvArr arr, @Const IntPointer idx, double value );
public static native void cvSetRealND( CvArr arr, @Const IntBuffer idx, double value );
public static native void cvSetRealND( CvArr arr, @Const int[] idx, double value );

/* clears element of ND dense array,
   in case of sparse arrays it deletes the specified node */
public static native void cvClearND( CvArr arr, @Const IntPointer idx );
public static native void cvClearND( CvArr arr, @Const IntBuffer idx );
public static native void cvClearND( CvArr arr, @Const int[] idx );

/* Converts CvArr (IplImage or CvMat,...) to CvMat.
   If the last parameter is non-zero, function can
   convert multi(>2)-dimensional array to CvMat as long as
   the last array's dimension is continous. The resultant
   matrix will be have appropriate (a huge) number of rows */
public static native CvMat cvGetMat( @Const CvArr arr, CvMat header,
                       IntPointer coi/*CV_DEFAULT(NULL)*/,
                       int allowND/*CV_DEFAULT(0)*/);
public static native CvMat cvGetMat( @Const CvArr arr, CvMat header,
                       IntBuffer coi/*CV_DEFAULT(NULL)*/,
                       int allowND/*CV_DEFAULT(0)*/);
public static native CvMat cvGetMat( @Const CvArr arr, CvMat header,
                       int[] coi/*CV_DEFAULT(NULL)*/,
                       int allowND/*CV_DEFAULT(0)*/);

/* Converts CvArr (IplImage or CvMat) to IplImage */
public static native IplImage cvGetImage( @Const CvArr arr, IplImage image_header );


/* Changes a shape of multi-dimensional array.
   new_cn == 0 means that number of channels remains unchanged.
   new_dims == 0 means that number and sizes of dimensions remain the same
   (unless they need to be changed to set the new number of channels)
   if new_dims == 1, there is no need to specify new dimension sizes
   The resultant configuration should be achievable w/o data copying.
   If the resultant array is sparse, CvSparseMat header should be passed
   to the function else if the result is 1 or 2 dimensional,
   CvMat header should be passed to the function
   else CvMatND header should be passed */
public static native CvArr cvReshapeMatND( @Const CvArr arr,
                             int sizeof_header, CvArr header,
                             int new_cn, int new_dims, IntPointer new_sizes );
public static native CvArr cvReshapeMatND( @Const CvArr arr,
                             int sizeof_header, CvArr header,
                             int new_cn, int new_dims, IntBuffer new_sizes );
public static native CvArr cvReshapeMatND( @Const CvArr arr,
                             int sizeof_header, CvArr header,
                             int new_cn, int new_dims, int[] new_sizes );

// #define cvReshapeND( arr, header, new_cn, new_dims, new_sizes )
//       cvReshapeMatND( (arr), sizeof(*(header)), (header),
//                       (new_cn), (new_dims), (new_sizes))

public static native CvMat cvReshape( @Const CvArr arr, CvMat header,
                        int new_cn, int new_rows/*CV_DEFAULT(0)*/ );

/* Repeats source 2d array several times in both horizontal and
   vertical direction to fill destination array */
public static native void cvRepeat( @Const CvArr src, CvArr dst );

/* Allocates array data */
public static native void cvCreateData( CvArr arr );

/* Releases array data */
public static native void cvReleaseData( CvArr arr );

/* Attaches user data to the array header. The step is reffered to
   the pre-last dimension. That is, all the planes of the array
   must be joint (w/o gaps) */
public static native void cvSetData( CvArr arr, Pointer data, int step );

/* Retrieves raw data of CvMat, IplImage or CvMatND.
   In the latter case the function raises an error if
   the array can not be represented as a matrix */
public static native void cvGetRawData( @Const CvArr arr, @Cast("uchar**") PointerPointer data,
                         IntPointer step/*CV_DEFAULT(NULL)*/,
                         CvSize roi_size/*CV_DEFAULT(NULL)*/);
public static native void cvGetRawData( @Const CvArr arr, @Cast("uchar**") @ByPtrPtr BytePointer data,
                         IntPointer step/*CV_DEFAULT(NULL)*/,
                         CvSize roi_size/*CV_DEFAULT(NULL)*/);
public static native void cvGetRawData( @Const CvArr arr, @Cast("uchar**") @ByPtrPtr ByteBuffer data,
                         IntBuffer step/*CV_DEFAULT(NULL)*/,
                         CvSize roi_size/*CV_DEFAULT(NULL)*/);
public static native void cvGetRawData( @Const CvArr arr, @Cast("uchar**") @ByPtrPtr byte[] data,
                         int[] step/*CV_DEFAULT(NULL)*/,
                         CvSize roi_size/*CV_DEFAULT(NULL)*/);

/* Returns width and height of array in elements */
public static native @ByVal CvSize cvGetSize( @Const CvArr arr );

/* Copies source array to destination array */
public static native void cvCopy( @Const CvArr src, CvArr dst,
                     @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Sets all or "masked" elements of input array
   to the same value*/
public static native void cvSet( CvArr arr, @ByVal CvScalar value,
                    @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Clears all the array elements (sets them to 0) */
public static native void cvSetZero( CvArr arr );
public static native void cvZero(CvArr arg1);


/* Splits a multi-channel array into the set of single-channel arrays or
   extracts particular [color] plane */
public static native void cvSplit( @Const CvArr src, CvArr dst0, CvArr dst1,
                      CvArr dst2, CvArr dst3 );

/* Merges a set of single-channel arrays into the single multi-channel array
   or inserts one particular [color] plane to the array */
public static native void cvMerge( @Const CvArr src0, @Const CvArr src1,
                      @Const CvArr src2, @Const CvArr src3,
                      CvArr dst );

/* Copies several channels from input arrays to
   certain channels of output arrays */
public static native void cvMixChannels( @Cast("const CvArr**") PointerPointer src, int src_count,
                            @Cast("CvArr**") PointerPointer dst, int dst_count,
                            @Const IntPointer from_to, int pair_count );
public static native void cvMixChannels( @Const @ByPtrPtr CvArr src, int src_count,
                            @ByPtrPtr CvArr dst, int dst_count,
                            @Const IntPointer from_to, int pair_count );
public static native void cvMixChannels( @Const @ByPtrPtr CvArr src, int src_count,
                            @ByPtrPtr CvArr dst, int dst_count,
                            @Const IntBuffer from_to, int pair_count );
public static native void cvMixChannels( @Const @ByPtrPtr CvArr src, int src_count,
                            @ByPtrPtr CvArr dst, int dst_count,
                            @Const int[] from_to, int pair_count );

/* Performs linear transformation on every source array element:
   dst(x,y,c) = scale*src(x,y,c)+shift.
   Arbitrary combination of input and output array depths are allowed
   (number of channels must be the same), thus the function can be used
   for type conversion */
public static native void cvConvertScale( @Const CvArr src, CvArr dst,
                             double scale/*CV_DEFAULT(1)*/,
                             double shift/*CV_DEFAULT(0)*/ );
public static native void cvCvtScale(CvArr arg1, CvArr arg2, double arg3, double arg4);
public static native void cvScale(CvArr arg1, CvArr arg2, double arg3, double arg4);
public static native void cvConvert(CvArr src, CvArr dst);


/* Performs linear transformation on every source array element,
   stores absolute value of the result:
   dst(x,y,c) = abs(scale*src(x,y,c)+shift).
   destination array must have 8u type.
   In other cases one may use cvConvertScale + cvAbsDiffS */
public static native void cvConvertScaleAbs( @Const CvArr src, CvArr dst,
                                double scale/*CV_DEFAULT(1)*/,
                                double shift/*CV_DEFAULT(0)*/ );
public static native void cvCvtScaleAbs(CvArr arg1, CvArr arg2, double arg3, double arg4);


/* checks termination criteria validity and
   sets eps to default_eps (if it is not set),
   max_iter to default_max_iters (if it is not set)
*/
public static native @ByVal CvTermCriteria cvCheckTermCriteria( @ByVal CvTermCriteria criteria,
                                           double default_eps,
                                           int default_max_iters );

/****************************************************************************************\
*                   Arithmetic, logic and comparison operations                          *
\****************************************************************************************/

/* dst(mask) = src1(mask) + src2(mask) */
public static native void cvAdd( @Const CvArr src1, @Const CvArr src2, CvArr dst,
                    @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(mask) = src(mask) + value */
public static native void cvAddS( @Const CvArr src, @ByVal CvScalar value, CvArr dst,
                     @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(mask) = src1(mask) - src2(mask) */
public static native void cvSub( @Const CvArr src1, @Const CvArr src2, CvArr dst,
                    @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(mask) = src(mask) - value = src(mask) + (-value) */
public static native void cvSubS( @Const CvArr src, @ByVal CvScalar value, CvArr dst,
                         @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(mask) = value - src(mask) */
public static native void cvSubRS( @Const CvArr src, @ByVal CvScalar value, CvArr dst,
                      @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src1(idx) * src2(idx) * scale
   (scaled element-wise multiplication of 2 arrays) */
public static native void cvMul( @Const CvArr src1, @Const CvArr src2,
                    CvArr dst, double scale/*CV_DEFAULT(1)*/ );

/* element-wise division/inversion with scaling:
    dst(idx) = src1(idx) * scale / src2(idx)
    or dst(idx) = scale / src2(idx) if src1 == 0 */
public static native void cvDiv( @Const CvArr src1, @Const CvArr src2,
                    CvArr dst, double scale/*CV_DEFAULT(1)*/);

/* dst = src1 * scale + src2 */
public static native void cvScaleAdd( @Const CvArr src1, @ByVal CvScalar scale,
                         @Const CvArr src2, CvArr dst );
// #define cvAXPY( A, real_scalar, B, C ) cvScaleAdd(A, cvRealScalar(real_scalar), B, C)

/* dst = src1 * alpha + src2 * beta + gamma */
public static native void cvAddWeighted( @Const CvArr src1, double alpha,
                            @Const CvArr src2, double beta,
                            double gamma, CvArr dst );

/* result = sum_i(src1(i) * src2(i)) (results for all channels are accumulated together) */
public static native double cvDotProduct( @Const CvArr src1, @Const CvArr src2 );

/* dst(idx) = src1(idx) & src2(idx) */
public static native void cvAnd( @Const CvArr src1, @Const CvArr src2,
                  CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src(idx) & value */
public static native void cvAndS( @Const CvArr src, @ByVal CvScalar value,
                   CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src1(idx) | src2(idx) */
public static native void cvOr( @Const CvArr src1, @Const CvArr src2,
                 CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src(idx) | value */
public static native void cvOrS( @Const CvArr src, @ByVal CvScalar value,
                  CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src1(idx) ^ src2(idx) */
public static native void cvXor( @Const CvArr src1, @Const CvArr src2,
                  CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = src(idx) ^ value */
public static native void cvXorS( @Const CvArr src, @ByVal CvScalar value,
                   CvArr dst, @Const CvArr mask/*CV_DEFAULT(NULL)*/);

/* dst(idx) = ~src(idx) */
public static native void cvNot( @Const CvArr src, CvArr dst );

/* dst(idx) = lower(idx) <= src(idx) < upper(idx) */
public static native void cvInRange( @Const CvArr src, @Const CvArr lower,
                      @Const CvArr upper, CvArr dst );

/* dst(idx) = lower <= src(idx) < upper */
public static native void cvInRangeS( @Const CvArr src, @ByVal CvScalar lower,
                       @ByVal CvScalar upper, CvArr dst );

public static final int CV_CMP_EQ =   0;
public static final int CV_CMP_GT =   1;
public static final int CV_CMP_GE =   2;
public static final int CV_CMP_LT =   3;
public static final int CV_CMP_LE =   4;
public static final int CV_CMP_NE =   5;

/* The comparison operation support single-channel arrays only.
   Destination image should be 8uC1 or 8sC1 */

/* dst(idx) = src1(idx) _cmp_op_ src2(idx) */
public static native void cvCmp( @Const CvArr src1, @Const CvArr src2, CvArr dst, int cmp_op );

/* dst(idx) = src1(idx) _cmp_op_ value */
public static native void cvCmpS( @Const CvArr src, double value, CvArr dst, int cmp_op );

/* dst(idx) = min(src1(idx),src2(idx)) */
public static native void cvMin( @Const CvArr src1, @Const CvArr src2, CvArr dst );

/* dst(idx) = max(src1(idx),src2(idx)) */
public static native void cvMax( @Const CvArr src1, @Const CvArr src2, CvArr dst );

/* dst(idx) = min(src(idx),value) */
public static native void cvMinS( @Const CvArr src, double value, CvArr dst );

/* dst(idx) = max(src(idx),value) */
public static native void cvMaxS( @Const CvArr src, double value, CvArr dst );

/* dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c)) */
public static native void cvAbsDiff( @Const CvArr src1, @Const CvArr src2, CvArr dst );

/* dst(x,y,c) = abs(src(x,y,c) - value(c)) */
public static native void cvAbsDiffS( @Const CvArr src, CvArr dst, @ByVal CvScalar value );
// #define cvAbs( src, dst ) cvAbsDiffS( (src), (dst), cvScalarAll(0))

/****************************************************************************************\
*                                Math operations                                         *
\****************************************************************************************/

/* Does cartesian->polar coordinates conversion.
   Either of output components (magnitude or angle) is optional */
public static native void cvCartToPolar( @Const CvArr x, @Const CvArr y,
                            CvArr magnitude, CvArr angle/*CV_DEFAULT(NULL)*/,
                            int angle_in_degrees/*CV_DEFAULT(0)*/);

/* Does polar->cartesian coordinates conversion.
   Either of output components (magnitude or angle) is optional.
   If magnitude is missing it is assumed to be all 1's */
public static native void cvPolarToCart( @Const CvArr magnitude, @Const CvArr angle,
                            CvArr x, CvArr y,
                            int angle_in_degrees/*CV_DEFAULT(0)*/);

/* Does powering: dst(idx) = src(idx)^power */
public static native void cvPow( @Const CvArr src, CvArr dst, double power );

/* Does exponention: dst(idx) = exp(src(idx)).
   Overflow is not handled yet. Underflow is handled.
   Maximal relative error is ~7e-6 for single-precision input */
public static native void cvExp( @Const CvArr src, CvArr dst );

/* Calculates natural logarithms: dst(idx) = log(abs(src(idx))).
   Logarithm of 0 gives large negative number(~-700)
   Maximal relative error is ~3e-7 for single-precision output
*/
public static native void cvLog( @Const CvArr src, CvArr dst );

/* Fast arctangent calculation */
public static native float cvFastArctan( float y, float x );

/* Fast cubic root calculation */
public static native float cvCbrt( float value );

/* Checks array values for NaNs, Infs or simply for too large numbers
   (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
   no runtime errors is raised (function returns zero value in case of "bad" values).
   Otherwise cvError is called */
public static final int CV_CHECK_RANGE =    1;
public static final int CV_CHECK_QUIET =    2;
public static native int cvCheckArr( @Const CvArr arr, int flags/*CV_DEFAULT(0)*/,
                        double min_val/*CV_DEFAULT(0)*/, double max_val/*CV_DEFAULT(0)*/);
public static native int cvCheckArray(CvArr arg1, int arg2, double arg3, double arg4);

public static final int CV_RAND_UNI =      0;
public static final int CV_RAND_NORMAL =   1;
public static native void cvRandArr( @Cast("CvRNG*") IntPointer rng, CvArr arr, int dist_type,
                      @ByVal CvScalar param1, @ByVal CvScalar param2 );
public static native void cvRandArr( @Cast("CvRNG*") IntBuffer rng, CvArr arr, int dist_type,
                      @ByVal CvScalar param1, @ByVal CvScalar param2 );
public static native void cvRandArr( @Cast("CvRNG*") int[] rng, CvArr arr, int dist_type,
                      @ByVal CvScalar param1, @ByVal CvScalar param2 );

public static native void cvRandShuffle( CvArr mat, @Cast("CvRNG*") IntPointer rng,
                           double iter_factor/*CV_DEFAULT(1.)*/);
public static native void cvRandShuffle( CvArr mat, @Cast("CvRNG*") IntBuffer rng,
                           double iter_factor/*CV_DEFAULT(1.)*/);
public static native void cvRandShuffle( CvArr mat, @Cast("CvRNG*") int[] rng,
                           double iter_factor/*CV_DEFAULT(1.)*/);

public static final int CV_SORT_EVERY_ROW = 0;
public static final int CV_SORT_EVERY_COLUMN = 1;
public static final int CV_SORT_ASCENDING = 0;
public static final int CV_SORT_DESCENDING = 16;

public static native void cvSort( @Const CvArr src, CvArr dst/*CV_DEFAULT(NULL)*/,
                    CvArr idxmat/*CV_DEFAULT(NULL)*/,
                    int flags/*CV_DEFAULT(0)*/);

/* Finds real roots of a cubic equation */
public static native int cvSolveCubic( @Const CvMat coeffs, CvMat roots );

/* Finds all real and complex roots of a polynomial equation */
public static native void cvSolvePoly(@Const CvMat coeffs, CvMat roots2,
      int maxiter/*CV_DEFAULT(20)*/, int fig/*CV_DEFAULT(100)*/);

/****************************************************************************************\
*                                Matrix operations                                       *
\****************************************************************************************/

/* Calculates cross product of two 3d vectors */
public static native void cvCrossProduct( @Const CvArr src1, @Const CvArr src2, CvArr dst );

/* Matrix transform: dst = A*B + C, C is optional */
// #define cvMatMulAdd( src1, src2, src3, dst ) cvGEMM( (src1), (src2), 1., (src3), 1., (dst), 0 )
// #define cvMatMul( src1, src2, dst )  cvMatMulAdd( (src1), (src2), NULL, (dst))

public static final int CV_GEMM_A_T = 1;
public static final int CV_GEMM_B_T = 2;
public static final int CV_GEMM_C_T = 4;
/* Extended matrix transform:
   dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T */
public static native void cvGEMM( @Const CvArr src1, @Const CvArr src2, double alpha,
                     @Const CvArr src3, double beta, CvArr dst,
                     int tABC/*CV_DEFAULT(0)*/);
public static native void cvMatMulAddEx(CvArr arg1, CvArr arg2, double arg3, CvArr arg4, double arg5, CvArr arg6, int arg7);

/* Transforms each element of source array and stores
   resultant vectors in destination array */
public static native void cvTransform( @Const CvArr src, CvArr dst,
                          @Const CvMat transmat,
                          @Const CvMat shiftvec/*CV_DEFAULT(NULL)*/);
public static native void cvMatMulAddS(CvArr arg1, CvArr arg2, CvMat arg3, CvMat arg4);

/* Does perspective transform on every element of input array */
public static native void cvPerspectiveTransform( @Const CvArr src, CvArr dst,
                                     @Const CvMat mat );

/* Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1) */
public static native void cvMulTransposed( @Const CvArr src, CvArr dst, int order,
                             @Const CvArr delta/*CV_DEFAULT(NULL)*/,
                             double scale/*CV_DEFAULT(1.)*/ );

/* Tranposes matrix. Square matrices can be transposed in-place */
public static native void cvTranspose( @Const CvArr src, CvArr dst );
public static native void cvT(CvArr arg1, CvArr arg2);

/* Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part */
public static native void cvCompleteSymm( CvMat matrix, int LtoR/*CV_DEFAULT(0)*/ );

/* Mirror array data around horizontal (flip=0),
   vertical (flip=1) or both(flip=-1) axises:
   cvFlip(src) flips images vertically and sequences horizontally (inplace) */
public static native void cvFlip( @Const CvArr src, CvArr dst/*CV_DEFAULT(NULL)*/,
                     int flip_mode/*CV_DEFAULT(0)*/);
public static native void cvMirror(CvArr arg1, CvArr arg2, int arg3);


public static final int CV_SVD_MODIFY_A =   1;
public static final int CV_SVD_U_T =        2;
public static final int CV_SVD_V_T =        4;

/* Performs Singular Value Decomposition of a matrix */
public static native void cvSVD( CvArr A, CvArr W, CvArr U/*CV_DEFAULT(NULL)*/,
                     CvArr V/*CV_DEFAULT(NULL)*/, int flags/*CV_DEFAULT(0)*/);

/* Performs Singular Value Back Substitution (solves A*X = B):
   flags must be the same as in cvSVD */
public static native void cvSVBkSb( @Const CvArr W, @Const CvArr U,
                        @Const CvArr V, @Const CvArr B,
                        CvArr X, int flags );

public static final int CV_LU =  0;
public static final int CV_SVD = 1;
public static final int CV_SVD_SYM = 2;
public static final int CV_CHOLESKY = 3;
public static final int CV_QR =  4;
public static final int CV_NORMAL = 16;

/* Inverts matrix */
public static native double cvInvert( @Const CvArr src, CvArr dst,
                         int method/*CV_DEFAULT(CV_LU)*/);
public static native void cvInv(CvArr arg1, CvArr arg2, int arg3);

/* Solves linear system (src1)*(dst) = (src2)
   (returns 0 if src1 is a singular and CV_LU method is used) */
public static native int cvSolve( @Const CvArr src1, @Const CvArr src2, CvArr dst,
                     int method/*CV_DEFAULT(CV_LU)*/);

/* Calculates determinant of input matrix */
public static native double cvDet( @Const CvArr mat );

/* Calculates trace of the matrix (sum of elements on the main diagonal) */
public static native @ByVal CvScalar cvTrace( @Const CvArr mat );

/* Finds eigen values and vectors of a symmetric matrix */
public static native void cvEigenVV( CvArr mat, CvArr evects, CvArr evals,
                        double eps/*CV_DEFAULT(0)*/,
                        int lowindex/*CV_DEFAULT(-1)*/,
                        int highindex/*CV_DEFAULT(-1)*/);

///* Finds selected eigen values and vectors of a symmetric matrix */
//CVAPI(void)  cvSelectedEigenVV( CvArr* mat, CvArr* evects, CvArr* evals,
//                                int lowindex, int highindex );

/* Makes an identity matrix (mat_ij = i == j) */
public static native void cvSetIdentity( CvArr mat, @ByVal CvScalar value/*CV_DEFAULT(cvRealScalar(1))*/ );

/* Fills matrix with given range of numbers */
public static native CvArr cvRange( CvArr mat, double start, double end );

/* Calculates covariation matrix for a set of vectors */
/* transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] */
public static final int CV_COVAR_SCRAMBLED = 0;

/* [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...]) */
public static final int CV_COVAR_NORMAL =    1;

/* do not calc average (i.e. mean vector) - use the input vector instead
   (useful for calculating covariance matrix by parts) */
public static final int CV_COVAR_USE_AVG =   2;

/* scale the covariance matrix coefficients by number of the vectors */
public static final int CV_COVAR_SCALE =     4;

/* all the input vectors are stored in a single matrix, as its rows */
public static final int CV_COVAR_ROWS =      8;

/* all the input vectors are stored in a single matrix, as its columns */
public static final int CV_COVAR_COLS =     16;

public static native void cvCalcCovarMatrix( @Cast("const CvArr**") PointerPointer vects, int count,
                                CvArr cov_mat, CvArr avg, int flags );
public static native void cvCalcCovarMatrix( @Const @ByPtrPtr CvArr vects, int count,
                                CvArr cov_mat, CvArr avg, int flags );

public static final int CV_PCA_DATA_AS_ROW = 0;
public static final int CV_PCA_DATA_AS_COL = 1;
public static final int CV_PCA_USE_AVG = 2;
public static native void cvCalcPCA( @Const CvArr data, CvArr mean,
                        CvArr eigenvals, CvArr eigenvects, int flags );

public static native void cvProjectPCA( @Const CvArr data, @Const CvArr mean,
                           @Const CvArr eigenvects, CvArr result );

public static native void cvBackProjectPCA( @Const CvArr proj, @Const CvArr mean,
                               @Const CvArr eigenvects, CvArr result );

/* Calculates Mahalanobis(weighted) distance */
public static native double cvMahalanobis( @Const CvArr vec1, @Const CvArr vec2, @Const CvArr mat );
public static native double cvMahalonobis(CvArr arg1, CvArr arg2, CvArr arg3);

/****************************************************************************************\
*                                    Array Statistics                                    *
\****************************************************************************************/

/* Finds sum of array elements */
public static native @ByVal CvScalar cvSum( @Const CvArr arr );

/* Calculates number of non-zero pixels */
public static native int cvCountNonZero( @Const CvArr arr );

/* Calculates mean value of array elements */
public static native @ByVal CvScalar cvAvg( @Const CvArr arr, @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Calculates mean and standard deviation of pixel values */
public static native void cvAvgSdv( @Const CvArr arr, CvScalar mean, CvScalar std_dev,
                       @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Finds global minimum, maximum and their positions */
public static native void cvMinMaxLoc( @Const CvArr arr, DoublePointer min_val, DoublePointer max_val,
                          CvPoint min_loc/*CV_DEFAULT(NULL)*/,
                          CvPoint max_loc/*CV_DEFAULT(NULL)*/,
                          @Const CvArr mask/*CV_DEFAULT(NULL)*/ );
public static native void cvMinMaxLoc( @Const CvArr arr, DoubleBuffer min_val, DoubleBuffer max_val,
                          CvPoint min_loc/*CV_DEFAULT(NULL)*/,
                          CvPoint max_loc/*CV_DEFAULT(NULL)*/,
                          @Const CvArr mask/*CV_DEFAULT(NULL)*/ );
public static native void cvMinMaxLoc( @Const CvArr arr, double[] min_val, double[] max_val,
                          CvPoint min_loc/*CV_DEFAULT(NULL)*/,
                          CvPoint max_loc/*CV_DEFAULT(NULL)*/,
                          @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* types of array norm */
public static final int CV_C =            1;
public static final int CV_L1 =           2;
public static final int CV_L2 =           4;
public static final int CV_NORM_MASK =    7;
public static final int CV_RELATIVE =     8;
public static final int CV_DIFF =         16;
public static final int CV_MINMAX =       32;

public static final int CV_DIFF_C =       (CV_DIFF | CV_C);
public static final int CV_DIFF_L1 =      (CV_DIFF | CV_L1);
public static final int CV_DIFF_L2 =      (CV_DIFF | CV_L2);
public static final int CV_RELATIVE_C =   (CV_RELATIVE | CV_C);
public static final int CV_RELATIVE_L1 =  (CV_RELATIVE | CV_L1);
public static final int CV_RELATIVE_L2 =  (CV_RELATIVE | CV_L2);

/* Finds norm, difference norm or relative difference norm for an array (or two arrays) */
public static native double cvNorm( @Const CvArr arr1, @Const CvArr arr2/*CV_DEFAULT(NULL)*/,
                       int norm_type/*CV_DEFAULT(CV_L2)*/,
                       @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

public static native void cvNormalize( @Const CvArr src, CvArr dst,
                          double a/*CV_DEFAULT(1.)*/, double b/*CV_DEFAULT(0.)*/,
                          int norm_type/*CV_DEFAULT(CV_L2)*/,
                          @Const CvArr mask/*CV_DEFAULT(NULL)*/ );


public static final int CV_REDUCE_SUM = 0;
public static final int CV_REDUCE_AVG = 1;
public static final int CV_REDUCE_MAX = 2;
public static final int CV_REDUCE_MIN = 3;

public static native void cvReduce( @Const CvArr src, CvArr dst, int dim/*CV_DEFAULT(-1)*/,
                       int op/*CV_DEFAULT(CV_REDUCE_SUM)*/ );

/****************************************************************************************\
*                      Discrete Linear Transforms and Related Functions                  *
\****************************************************************************************/

public static final int CV_DXT_FORWARD =  0;
public static final int CV_DXT_INVERSE =  1;
public static final int CV_DXT_SCALE =    2; /* divide result by size of array */
public static final int CV_DXT_INV_SCALE = (CV_DXT_INVERSE + CV_DXT_SCALE);
public static final int CV_DXT_INVERSE_SCALE = CV_DXT_INV_SCALE;
public static final int CV_DXT_ROWS =     4; /* transform each row individually */
public static final int CV_DXT_MUL_CONJ = 8; /* conjugate the second argument of cvMulSpectrums */

/* Discrete Fourier Transform:
    complex->complex,
    real->ccs (forward),
    ccs->real (inverse) */
public static native void cvDFT( @Const CvArr src, CvArr dst, int flags,
                    int nonzero_rows/*CV_DEFAULT(0)*/ );
public static native void cvFFT(CvArr arg1, CvArr arg2, int arg3, int arg4);

/* Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) */
public static native void cvMulSpectrums( @Const CvArr src1, @Const CvArr src2,
                             CvArr dst, int flags );

/* Finds optimal DFT vector size >= size0 */
public static native int cvGetOptimalDFTSize( int size0 );

/* Discrete Cosine Transform */
public static native void cvDCT( @Const CvArr src, CvArr dst, int flags );

/****************************************************************************************\
*                              Dynamic data structures                                   *
\****************************************************************************************/

/* Calculates length of sequence slice (with support of negative indices). */
public static native int cvSliceLength( @ByVal CvSlice slice, @Const CvSeq seq );


/* Creates new memory storage.
   block_size == 0 means that default,
   somewhat optimal size, is used (currently, it is 64K) */
public static native CvMemStorage cvCreateMemStorage( int block_size/*CV_DEFAULT(0)*/);


/* Creates a memory storage that will borrow memory blocks from parent storage */
public static native CvMemStorage cvCreateChildMemStorage( CvMemStorage parent );


/* Releases memory storage. All the children of a parent must be released before
   the parent. A child storage returns all the blocks to parent when it is released */
public static native void cvReleaseMemStorage( @Cast("CvMemStorage**") PointerPointer storage );
public static native void cvReleaseMemStorage( @ByPtrPtr CvMemStorage storage );


/* Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)
   to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...
   do not free any memory.
   A child storage returns all the blocks to the parent when it is cleared */
public static native void cvClearMemStorage( CvMemStorage storage );

/* Remember a storage "free memory" position */
public static native void cvSaveMemStoragePos( @Const CvMemStorage storage, CvMemStoragePos pos );

/* Restore a storage "free memory" position */
public static native void cvRestoreMemStoragePos( CvMemStorage storage, CvMemStoragePos pos );

/* Allocates continuous buffer of the specified size in the storage */
public static native Pointer cvMemStorageAlloc( CvMemStorage storage, @Cast("size_t") long size );

/* Allocates string in memory storage */
public static native @ByVal CvString cvMemStorageAllocString( CvMemStorage storage, @Cast("const char*") BytePointer ptr,
                                         int len/*CV_DEFAULT(-1)*/ );
public static native @ByVal CvString cvMemStorageAllocString( CvMemStorage storage, String ptr,
                                         int len/*CV_DEFAULT(-1)*/ );

/* Creates new empty sequence that will reside in the specified storage */
public static native CvSeq cvCreateSeq( int seq_flags, @Cast("size_t") long header_size,
                            @Cast("size_t") long elem_size, CvMemStorage storage );

/* Changes default size (granularity) of sequence blocks.
   The default size is ~1Kbyte */
public static native void cvSetSeqBlockSize( CvSeq seq, int delta_elems );


/* Adds new element to the end of sequence. Returns pointer to the element */
public static native @Cast("schar*") BytePointer cvSeqPush( CvSeq seq, @Const Pointer element/*CV_DEFAULT(NULL)*/);


/* Adds new element to the beginning of sequence. Returns pointer to it */
public static native @Cast("schar*") BytePointer cvSeqPushFront( CvSeq seq, @Const Pointer element/*CV_DEFAULT(NULL)*/);


/* Removes the last element from sequence and optionally saves it */
public static native void cvSeqPop( CvSeq seq, Pointer element/*CV_DEFAULT(NULL)*/);


/* Removes the first element from sequence and optioanally saves it */
public static native void cvSeqPopFront( CvSeq seq, Pointer element/*CV_DEFAULT(NULL)*/);


public static final int CV_FRONT = 1;
public static final int CV_BACK = 0;
/* Adds several new elements to the end of sequence */
public static native void cvSeqPushMulti( CvSeq seq, @Const Pointer elements,
                             int count, int in_front/*CV_DEFAULT(0)*/ );

/* Removes several elements from the end of sequence and optionally saves them */
public static native void cvSeqPopMulti( CvSeq seq, Pointer elements,
                            int count, int in_front/*CV_DEFAULT(0)*/ );

/* Inserts a new element in the middle of sequence.
   cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem) */
public static native @Cast("schar*") BytePointer cvSeqInsert( CvSeq seq, int before_index,
                            @Const Pointer element/*CV_DEFAULT(NULL)*/);

/* Removes specified sequence element */
public static native void cvSeqRemove( CvSeq seq, int index );


/* Removes all the elements from the sequence. The freed memory
   can be reused later only by the same sequence unless cvClearMemStorage
   or cvRestoreMemStoragePos is called */
public static native void cvClearSeq( CvSeq seq );


/* Retrieves pointer to specified sequence element.
   Negative indices are supported and mean counting from the end
   (e.g -1 means the last sequence element) */
public static native @Cast("schar*") BytePointer cvGetSeqElem( @Const CvSeq seq, int index );

/* Calculates index of the specified sequence element.
   Returns -1 if element does not belong to the sequence */
public static native int cvSeqElemIdx( @Const CvSeq seq, @Const Pointer element,
                         @Cast("CvSeqBlock**") PointerPointer block/*CV_DEFAULT(NULL)*/ );
public static native int cvSeqElemIdx( @Const CvSeq seq, @Const Pointer element,
                         @ByPtrPtr CvSeqBlock block/*CV_DEFAULT(NULL)*/ );

/* Initializes sequence writer. The new elements will be added to the end of sequence */
public static native void cvStartAppendToSeq( CvSeq seq, CvSeqWriter writer );


/* Combination of cvCreateSeq and cvStartAppendToSeq */
public static native void cvStartWriteSeq( int seq_flags, int header_size,
                              int elem_size, CvMemStorage storage,
                              CvSeqWriter writer );

/* Closes sequence writer, updates sequence header and returns pointer
   to the resultant sequence
   (which may be useful if the sequence was created using cvStartWriteSeq))
*/
public static native CvSeq cvEndWriteSeq( CvSeqWriter writer );


/* Updates sequence header. May be useful to get access to some of previously
   written elements via cvGetSeqElem or sequence reader */
public static native void cvFlushSeqWriter( CvSeqWriter writer );


/* Initializes sequence reader.
   The sequence can be read in forward or backward direction */
public static native void cvStartReadSeq( @Const CvSeq seq, CvSeqReader reader,
                           int reverse/*CV_DEFAULT(0)*/ );


/* Returns current sequence reader position (currently observed sequence element) */
public static native int cvGetSeqReaderPos( CvSeqReader reader );


/* Changes sequence reader position. It may seek to an absolute or
   to relative to the current position */
public static native void cvSetSeqReaderPos( CvSeqReader reader, int index,
                                 int is_relative/*CV_DEFAULT(0)*/);

/* Copies sequence content to a continuous piece of memory */
public static native Pointer cvCvtSeqToArray( @Const CvSeq seq, Pointer elements,
                               @ByVal CvSlice slice/*CV_DEFAULT(CV_WHOLE_SEQ)*/ );

/* Creates sequence header for array.
   After that all the operations on sequences that do not alter the content
   can be applied to the resultant sequence */
public static native CvSeq cvMakeSeqHeaderForArray( int seq_type, int header_size,
                                       int elem_size, Pointer elements, int total,
                                       CvSeq seq, CvSeqBlock block );

/* Extracts sequence slice (with or without copying sequence elements) */
public static native CvSeq cvSeqSlice( @Const CvSeq seq, @ByVal CvSlice slice,
                         CvMemStorage storage/*CV_DEFAULT(NULL)*/,
                         int copy_data/*CV_DEFAULT(0)*/);

public static native CvSeq cvCloneSeq( @Const CvSeq seq, CvMemStorage storage/*CV_DEFAULT(NULL)*/);

/* Removes sequence slice */
public static native void cvSeqRemoveSlice( CvSeq seq, @ByVal CvSlice slice );

/* Inserts a sequence or array into another sequence */
public static native void cvSeqInsertSlice( CvSeq seq, int before_index, @Const CvArr from_arr );

/* a < b ? -1 : a > b ? 1 : 0 */
public static class CvCmpFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvCmpFunc(Pointer p) { super(p); }
    protected CvCmpFunc() { allocate(); }
    private native void allocate();
    public native int call(@Const Pointer a, @Const Pointer b, Pointer userdata );
}

/* Sorts sequence in-place given element comparison function */
public static native void cvSeqSort( CvSeq seq, CvCmpFunc func, Pointer userdata/*CV_DEFAULT(NULL)*/ );

/* Finds element in a [sorted] sequence */
public static native @Cast("schar*") BytePointer cvSeqSearch( CvSeq seq, @Const Pointer elem, CvCmpFunc func,
                           int is_sorted, IntPointer elem_idx,
                           Pointer userdata/*CV_DEFAULT(NULL)*/ );
public static native @Cast("schar*") ByteBuffer cvSeqSearch( CvSeq seq, @Const Pointer elem, CvCmpFunc func,
                           int is_sorted, IntBuffer elem_idx,
                           Pointer userdata/*CV_DEFAULT(NULL)*/ );
public static native @Cast("schar*") byte[] cvSeqSearch( CvSeq seq, @Const Pointer elem, CvCmpFunc func,
                           int is_sorted, int[] elem_idx,
                           Pointer userdata/*CV_DEFAULT(NULL)*/ );

/* Reverses order of sequence elements in-place */
public static native void cvSeqInvert( CvSeq seq );

/* Splits sequence into one or more equivalence classes using the specified criteria */
public static native int cvSeqPartition( @Const CvSeq seq, CvMemStorage storage,
                            @Cast("CvSeq**") PointerPointer labels, CvCmpFunc is_equal, Pointer userdata );
public static native int cvSeqPartition( @Const CvSeq seq, CvMemStorage storage,
                            @ByPtrPtr CvSeq labels, CvCmpFunc is_equal, Pointer userdata );

/************ Internal sequence functions ************/
public static native void cvChangeSeqBlock( Pointer reader, int direction );
public static native void cvCreateSeqBlock( CvSeqWriter writer );


/* Creates a new set */
public static native CvSet cvCreateSet( int set_flags, int header_size,
                            int elem_size, CvMemStorage storage );

/* Adds new element to the set and returns pointer to it */
public static native int cvSetAdd( CvSet set_header, CvSetElem elem/*CV_DEFAULT(NULL)*/,
                      @Cast("CvSetElem**") PointerPointer inserted_elem/*CV_DEFAULT(NULL)*/ );
public static native int cvSetAdd( CvSet set_header, CvSetElem elem/*CV_DEFAULT(NULL)*/,
                      @ByPtrPtr CvSetElem inserted_elem/*CV_DEFAULT(NULL)*/ );

/* Fast variant of cvSetAdd */
public static native CvSetElem cvSetNew( CvSet set_header );

/* Removes set element given its pointer */
public static native void cvSetRemoveByPtr( CvSet set_header, Pointer elem );

/* Removes element from the set by its index  */
public static native void cvSetRemove( CvSet set_header, int index );

/* Returns a set element by index. If the element doesn't belong to the set,
   NULL is returned */
public static native CvSetElem cvGetSetElem( @Const CvSet set_header, int idx );

/* Removes all the elements from the set */
public static native void cvClearSet( CvSet set_header );

/* Creates new graph */
public static native CvGraph cvCreateGraph( int graph_flags, int header_size,
                                int vtx_size, int edge_size,
                                CvMemStorage storage );

/* Adds new vertex to the graph */
public static native int cvGraphAddVtx( CvGraph graph, @Const CvGraphVtx vtx/*CV_DEFAULT(NULL)*/,
                           @Cast("CvGraphVtx**") PointerPointer inserted_vtx/*CV_DEFAULT(NULL)*/ );
public static native int cvGraphAddVtx( CvGraph graph, @Const CvGraphVtx vtx/*CV_DEFAULT(NULL)*/,
                           @ByPtrPtr CvGraphVtx inserted_vtx/*CV_DEFAULT(NULL)*/ );


/* Removes vertex from the graph together with all incident edges */
public static native int cvGraphRemoveVtx( CvGraph graph, int index );
public static native int cvGraphRemoveVtxByPtr( CvGraph graph, CvGraphVtx vtx );


/* Link two vertices specifed by indices or pointers if they
   are not connected or return pointer to already existing edge
   connecting the vertices.
   Functions return 1 if a new edge was created, 0 otherwise */
public static native int cvGraphAddEdge( CvGraph graph,
                            int start_idx, int end_idx,
                            @Const CvGraphEdge edge/*CV_DEFAULT(NULL)*/,
                            @Cast("CvGraphEdge**") PointerPointer inserted_edge/*CV_DEFAULT(NULL)*/ );
public static native int cvGraphAddEdge( CvGraph graph,
                            int start_idx, int end_idx,
                            @Const CvGraphEdge edge/*CV_DEFAULT(NULL)*/,
                            @ByPtrPtr CvGraphEdge inserted_edge/*CV_DEFAULT(NULL)*/ );

public static native int cvGraphAddEdgeByPtr( CvGraph graph,
                               CvGraphVtx start_vtx, CvGraphVtx end_vtx,
                               @Const CvGraphEdge edge/*CV_DEFAULT(NULL)*/,
                               @Cast("CvGraphEdge**") PointerPointer inserted_edge/*CV_DEFAULT(NULL)*/ );
public static native int cvGraphAddEdgeByPtr( CvGraph graph,
                               CvGraphVtx start_vtx, CvGraphVtx end_vtx,
                               @Const CvGraphEdge edge/*CV_DEFAULT(NULL)*/,
                               @ByPtrPtr CvGraphEdge inserted_edge/*CV_DEFAULT(NULL)*/ );

/* Remove edge connecting two vertices */
public static native void cvGraphRemoveEdge( CvGraph graph, int start_idx, int end_idx );
public static native void cvGraphRemoveEdgeByPtr( CvGraph graph, CvGraphVtx start_vtx,
                                     CvGraphVtx end_vtx );

/* Find edge connecting two vertices */
public static native CvGraphEdge cvFindGraphEdge( @Const CvGraph graph, int start_idx, int end_idx );
public static native CvGraphEdge cvFindGraphEdgeByPtr( @Const CvGraph graph,
                                           @Const CvGraphVtx start_vtx,
                                           @Const CvGraphVtx end_vtx );
public static native CvGraphEdge cvGraphFindEdge(CvGraph arg1, int arg2, int arg3);
public static native CvGraphEdge cvGraphFindEdgeByPtr(CvGraph arg1, CvGraphVtx arg2, CvGraphVtx arg3);

/* Remove all vertices and edges from the graph */
public static native void cvClearGraph( CvGraph graph );


/* Count number of edges incident to the vertex */
public static native int cvGraphVtxDegree( @Const CvGraph graph, int vtx_idx );
public static native int cvGraphVtxDegreeByPtr( @Const CvGraph graph, @Const CvGraphVtx vtx );


/* Retrieves graph vertex by given index */
// #define cvGetGraphVtx( graph, idx ) (CvGraphVtx*)cvGetSetElem((CvSet*)(graph), (idx))

/* Retrieves index of a graph vertex given its pointer */
// #define cvGraphVtxIdx( graph, vtx ) ((vtx)->flags & CV_SET_ELEM_IDX_MASK)

/* Retrieves index of a graph edge given its pointer */
// #define cvGraphEdgeIdx( graph, edge ) ((edge)->flags & CV_SET_ELEM_IDX_MASK)

// #define cvGraphGetVtxCount( graph ) ((graph)->active_count)
// #define cvGraphGetEdgeCount( graph ) ((graph)->edges->active_count)

public static final int CV_GRAPH_VERTEX =        1;
public static final int CV_GRAPH_TREE_EDGE =     2;
public static final int CV_GRAPH_BACK_EDGE =     4;
public static final int CV_GRAPH_FORWARD_EDGE =  8;
public static final int CV_GRAPH_CROSS_EDGE =    16;
public static final int CV_GRAPH_ANY_EDGE =      30;
public static final int CV_GRAPH_NEW_TREE =      32;
public static final int CV_GRAPH_BACKTRACKING =  64;
public static final int CV_GRAPH_OVER =          -1;

public static final int CV_GRAPH_ALL_ITEMS =    -1;

/* flags for graph vertices and edges */
public static final int CV_GRAPH_ITEM_VISITED_FLAG =  (1 << 30);
// #define  CV_IS_GRAPH_VERTEX_VISITED(vtx)
//     (((CvGraphVtx*)(vtx))->flags & CV_GRAPH_ITEM_VISITED_FLAG)
// #define  CV_IS_GRAPH_EDGE_VISITED(edge)
//     (((CvGraphEdge*)(edge))->flags & CV_GRAPH_ITEM_VISITED_FLAG)
public static final int CV_GRAPH_SEARCH_TREE_NODE_FLAG =   (1 << 29);
public static final int CV_GRAPH_FORWARD_EDGE_FLAG =       (1 << 28);

public static class CvGraphScanner extends Pointer {
    static { Loader.load(); }
    public CvGraphScanner() { allocate(); }
    public CvGraphScanner(int size) { allocateArray(size); }
    public CvGraphScanner(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphScanner position(int position) {
        return (CvGraphScanner)super.position(position);
    }

    public native CvGraphVtx vtx(); public native CvGraphScanner vtx(CvGraphVtx vtx);       /* current graph vertex (or current edge origin) */
    public native CvGraphVtx dst(); public native CvGraphScanner dst(CvGraphVtx dst);       /* current graph edge destination vertex */
    public native CvGraphEdge edge(); public native CvGraphScanner edge(CvGraphEdge edge);     /* current edge */

    public native CvGraph graph(); public native CvGraphScanner graph(CvGraph graph);        /* the graph */
    public native CvSeq stack(); public native CvGraphScanner stack(CvSeq stack);        /* the graph vertex stack */
    public native int index(); public native CvGraphScanner index(int index);        /* the lower bound of certainly visited vertices */
    public native int mask(); public native CvGraphScanner mask(int mask);         /* event mask */
}

/* Creates new graph scanner. */
public static native CvGraphScanner cvCreateGraphScanner( CvGraph graph,
                                             CvGraphVtx vtx/*CV_DEFAULT(NULL)*/,
                                             int mask/*CV_DEFAULT(CV_GRAPH_ALL_ITEMS)*/);

/* Releases graph scanner. */
public static native void cvReleaseGraphScanner( @Cast("CvGraphScanner**") PointerPointer scanner );
public static native void cvReleaseGraphScanner( @ByPtrPtr CvGraphScanner scanner );

/* Get next graph element */
public static native int cvNextGraphItem( CvGraphScanner scanner );

/* Creates a copy of graph */
public static native CvGraph cvCloneGraph( @Const CvGraph graph, CvMemStorage storage );

/****************************************************************************************\
*                                     Drawing                                            *
\****************************************************************************************/

/****************************************************************************************\
*       Drawing functions work with images/matrices of arbitrary type.                   *
*       For color images the channel order is BGR[A]                                     *
*       Antialiasing is supported only for 8-bit image now.                              *
*       All the functions include parameter color that means rgb value (that may be      *
*       constructed with CV_RGB macro) for color images and brightness                   *
*       for grayscale images.                                                            *
*       If a drawn figure is partially or completely outside of the image, it is clipped.*
\****************************************************************************************/

// #define CV_RGB( r, g, b )  cvScalar( (b), (g), (r), 0 )
public static final int CV_FILLED = -1;

public static final int CV_AA = 16;

/* Draws 4-connected, 8-connected or antialiased line segment connecting two points */
public static native void cvLine( CvArr img, @ByVal CvPoint pt1, @ByVal CvPoint pt2,
                     @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                     int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );

/* Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2),
   if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn */
public static native void cvRectangle( CvArr img, @ByVal CvPoint pt1, @ByVal CvPoint pt2,
                          @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                          int line_type/*CV_DEFAULT(8)*/,
                          int shift/*CV_DEFAULT(0)*/);

/* Draws a rectangle specified by a CvRect structure */
public static native void cvRectangleR( CvArr img, @ByVal CvRect r,
                           @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                           int line_type/*CV_DEFAULT(8)*/,
                           int shift/*CV_DEFAULT(0)*/);


/* Draws a circle with specified center and radius.
   Thickness works in the same way as with cvRectangle */
public static native void cvCircle( CvArr img, @ByVal CvPoint center, int radius,
                       @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                       int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/);

/* Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector,
   depending on <thickness>, <start_angle> and <end_angle> parameters. The resultant figure
   is rotated by <angle>. All the angles are in degrees */
public static native void cvEllipse( CvArr img, @ByVal CvPoint center, @ByVal CvSize axes,
                        double angle, double start_angle, double end_angle,
                        @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                        int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/);

public static native void cvEllipseBox( CvArr img, @ByVal CvBox2D box, @ByVal CvScalar color,
                               int thickness/*CV_DEFAULT(1)*/,
                               int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );

/* Fills convex or monotonous polygon. */
public static native void cvFillConvexPoly( CvArr img, @Const CvPoint pts, int npts, @ByVal CvScalar color,
                               int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/);

/* Fills an area bounded by one or more arbitrary polygons */
public static native void cvFillPoly( CvArr img, @Cast("CvPoint**") PointerPointer pts, @Const IntPointer npts,
                         int contours, @ByVal CvScalar color,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvFillPoly( CvArr img, @ByPtrPtr CvPoint pts, @Const IntPointer npts,
                         int contours, @ByVal CvScalar color,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvFillPoly( CvArr img, @ByPtrPtr CvPoint pts, @Const IntBuffer npts,
                         int contours, @ByVal CvScalar color,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvFillPoly( CvArr img, @ByPtrPtr CvPoint pts, @Const int[] npts,
                         int contours, @ByVal CvScalar color,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );

/* Draws one or more polygonal curves */
public static native void cvPolyLine( CvArr img, @Cast("CvPoint**") PointerPointer pts, @Const IntPointer npts, int contours,
                         int is_closed, @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvPolyLine( CvArr img, @ByPtrPtr CvPoint pts, @Const IntPointer npts, int contours,
                         int is_closed, @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvPolyLine( CvArr img, @ByPtrPtr CvPoint pts, @Const IntBuffer npts, int contours,
                         int is_closed, @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );
public static native void cvPolyLine( CvArr img, @ByPtrPtr CvPoint pts, @Const int[] npts, int contours,
                         int is_closed, @ByVal CvScalar color, int thickness/*CV_DEFAULT(1)*/,
                         int line_type/*CV_DEFAULT(8)*/, int shift/*CV_DEFAULT(0)*/ );

public static native void cvDrawRect(CvArr arg1, @ByVal CvPoint arg2, @ByVal CvPoint arg3, @ByVal CvScalar arg4, int arg5, int arg6, int arg7);
public static native void cvDrawLine(CvArr arg1, @ByVal CvPoint arg2, @ByVal CvPoint arg3, @ByVal CvScalar arg4, int arg5, int arg6, int arg7);
public static native void cvDrawCircle(CvArr arg1, @ByVal CvPoint arg2, int arg3, @ByVal CvScalar arg4, int arg5, int arg6, int arg7);
public static native void cvDrawEllipse(CvArr arg1, @ByVal CvPoint arg2, @ByVal CvSize arg3, double arg4, double arg5, double arg6, @ByVal CvScalar arg7, int arg8, int arg9, int arg10);
public static native void cvDrawPolyLine(CvArr arg1, @Cast("CvPoint**") PointerPointer arg2, IntPointer arg3, int arg4, int arg5, @ByVal CvScalar arg6, int arg7, int arg8, int arg9);
public static native void cvDrawPolyLine(CvArr arg1, @ByPtrPtr CvPoint arg2, IntPointer arg3, int arg4, int arg5, @ByVal CvScalar arg6, int arg7, int arg8, int arg9);
public static native void cvDrawPolyLine(CvArr arg1, @ByPtrPtr CvPoint arg2, IntBuffer arg3, int arg4, int arg5, @ByVal CvScalar arg6, int arg7, int arg8, int arg9);
public static native void cvDrawPolyLine(CvArr arg1, @ByPtrPtr CvPoint arg2, int[] arg3, int arg4, int arg5, @ByVal CvScalar arg6, int arg7, int arg8, int arg9);

/* Clips the line segment connecting *pt1 and *pt2
   by the rectangular window
   (0<=x<img_size.width, 0<=y<img_size.height). */
public static native int cvClipLine( @ByVal CvSize img_size, CvPoint pt1, CvPoint pt2 );

/* Initializes line iterator. Initially, line_iterator->ptr will point
   to pt1 (or pt2, see left_to_right description) location in the image.
   Returns the number of pixels on the line between the ending points. */
public static native int cvInitLineIterator( @Const CvArr image, @ByVal CvPoint pt1, @ByVal CvPoint pt2,
                                CvLineIterator line_iterator,
                                int connectivity/*CV_DEFAULT(8)*/,
                                int left_to_right/*CV_DEFAULT(0)*/);

/* Moves iterator to the next line point */
// #define CV_NEXT_LINE_POINT( line_iterator )
// {
//     int _line_iterator_mask = (line_iterator).err < 0 ? -1 : 0;
//     (line_iterator).err += (line_iterator).minus_delta +
//         ((line_iterator).plus_delta & _line_iterator_mask);
//     (line_iterator).ptr += (line_iterator).minus_step +
//         ((line_iterator).plus_step & _line_iterator_mask);
// }


/* basic font types */
public static final int CV_FONT_HERSHEY_SIMPLEX =         0;
public static final int CV_FONT_HERSHEY_PLAIN =           1;
public static final int CV_FONT_HERSHEY_DUPLEX =          2;
public static final int CV_FONT_HERSHEY_COMPLEX =         3;
public static final int CV_FONT_HERSHEY_TRIPLEX =         4;
public static final int CV_FONT_HERSHEY_COMPLEX_SMALL =   5;
public static final int CV_FONT_HERSHEY_SCRIPT_SIMPLEX =  6;
public static final int CV_FONT_HERSHEY_SCRIPT_COMPLEX =  7;

/* font flags */
public static final int CV_FONT_ITALIC =                 16;

public static final int CV_FONT_VECTOR0 =    CV_FONT_HERSHEY_SIMPLEX;


/* Font structure */
public static class CvFont extends Pointer {
    static { Loader.load(); }
    public CvFont() { allocate(); }
    public CvFont(int size) { allocateArray(size); }
    public CvFont(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvFont position(int position) {
        return (CvFont)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer nameFont();   //Qt:nameFont
  public native @ByVal CvScalar color(); public native CvFont color(CvScalar color);       //Qt:ColorFont -> cvScalar(blue_component, green_component, red\_component[, alpha_component])
    public native int font_face(); public native CvFont font_face(int font_face);    //Qt: bool italic         /* =CV_FONT_* */
    @MemberGetter public native @Const IntPointer ascii();      /* font data and metrics */
    @MemberGetter public native @Const IntPointer greek();
    @MemberGetter public native @Const IntPointer cyrillic();
    public native float hscale(); public native CvFont hscale(float hscale);
    public native float vscale(); public native CvFont vscale(float vscale);
    public native float shear(); public native CvFont shear(float shear);      /* slope coefficient: 0 - normal, >0 - italic */
    public native int thickness(); public native CvFont thickness(int thickness);    //Qt: weight               /* letters thickness */
    public native float dx(); public native CvFont dx(float dx);       /* horizontal interval between letters */
    public native int line_type(); public native CvFont line_type(int line_type);    //Qt: PointSize
}

/* Initializes font structure used further in cvPutText */
public static native void cvInitFont( CvFont font, int font_face,
                         double hscale, double vscale,
                         double shear/*CV_DEFAULT(0)*/,
                         int thickness/*CV_DEFAULT(1)*/,
                         int line_type/*CV_DEFAULT(8)*/);

public static native @ByVal CvFont cvFont( double scale, int thickness/*CV_DEFAULT(1)*/ );

/* Renders text stroke with specified font and color at specified location.
   CvFont should be initialized with cvInitFont */
public static native void cvPutText( CvArr img, @Cast("const char*") BytePointer text, @ByVal CvPoint org,
                        @Const CvFont font, @ByVal CvScalar color );
public static native void cvPutText( CvArr img, String text, @ByVal CvPoint org,
                        @Const CvFont font, @ByVal CvScalar color );

/* Calculates bounding box of text stroke (useful for alignment) */
public static native void cvGetTextSize( @Cast("const char*") BytePointer text_string, @Const CvFont font,
                            CvSize text_size, IntPointer baseline );
public static native void cvGetTextSize( String text_string, @Const CvFont font,
                            CvSize text_size, IntBuffer baseline );
public static native void cvGetTextSize( @Cast("const char*") BytePointer text_string, @Const CvFont font,
                            CvSize text_size, int[] baseline );
public static native void cvGetTextSize( String text_string, @Const CvFont font,
                            CvSize text_size, IntPointer baseline );
public static native void cvGetTextSize( @Cast("const char*") BytePointer text_string, @Const CvFont font,
                            CvSize text_size, IntBuffer baseline );
public static native void cvGetTextSize( String text_string, @Const CvFont font,
                            CvSize text_size, int[] baseline );



/* Unpacks color value, if arrtype is CV_8UC?, <color> is treated as
   packed color value, otherwise the first channels (depending on arrtype)
   of destination scalar are set to the same value = <color> */
public static native @ByVal CvScalar cvColorToScalar( double packed_color, int arrtype );

/* Returns the polygon points which make up the given ellipse.  The ellipse is define by
   the box of size 'axes' rotated 'angle' around the 'center'.  A partial sweep
   of the ellipse arc can be done by spcifying arc_start and arc_end to be something
   other than 0 and 360, respectively.  The input array 'pts' must be large enough to
   hold the result.  The total number of points stored into 'pts' is returned by this
   function. */
public static native int cvEllipse2Poly( @ByVal CvPoint center, @ByVal CvSize axes,
                 int angle, int arc_start, int arc_end, CvPoint pts, int delta );

/* Draws contour outlines or filled interiors on the image */
public static native void cvDrawContours( CvArr img, CvSeq contour,
                             @ByVal CvScalar external_color, @ByVal CvScalar hole_color,
                             int max_level, int thickness/*CV_DEFAULT(1)*/,
                             int line_type/*CV_DEFAULT(8)*/,
                             @ByVal CvPoint offset/*CV_DEFAULT(cvPoint(0,0))*/);

/* Does look-up transformation. Elements of the source array
   (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table */
public static native void cvLUT( @Const CvArr src, CvArr dst, @Const CvArr lut );


/******************* Iteration through the sequence tree *****************/
public static class CvTreeNodeIterator extends Pointer {
    static { Loader.load(); }
    public CvTreeNodeIterator() { allocate(); }
    public CvTreeNodeIterator(int size) { allocateArray(size); }
    public CvTreeNodeIterator(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvTreeNodeIterator position(int position) {
        return (CvTreeNodeIterator)super.position(position);
    }

    @MemberGetter public native @Const Pointer node();
    public native int level(); public native CvTreeNodeIterator level(int level);
    public native int max_level(); public native CvTreeNodeIterator max_level(int max_level);
}

public static native void cvInitTreeNodeIterator( CvTreeNodeIterator tree_iterator,
                                   @Const Pointer first, int max_level );
public static native Pointer cvNextTreeNode( CvTreeNodeIterator tree_iterator );
public static native Pointer cvPrevTreeNode( CvTreeNodeIterator tree_iterator );

/* Inserts sequence into tree with specified "parent" sequence.
   If parent is equal to frame (e.g. the most external contour),
   then added contour will have null pointer to parent. */
public static native void cvInsertNodeIntoTree( Pointer node, Pointer parent, Pointer frame );

/* Removes contour from tree (together with the contour children). */
public static native void cvRemoveNodeFromTree( Pointer node, Pointer frame );

/* Gathers pointers to all the sequences,
   accessible from the <first>, to the single sequence */
public static native CvSeq cvTreeToNodeSeq( @Const Pointer first, int header_size,
                              CvMemStorage storage );

/* The function implements the K-means algorithm for clustering an array of sample
   vectors in a specified number of classes */
public static final int CV_KMEANS_USE_INITIAL_LABELS =    1;
public static native int cvKMeans2( @Const CvArr samples, int cluster_count, CvArr labels,
                      @ByVal CvTermCriteria termcrit, int attempts/*CV_DEFAULT(1)*/,
                      @Cast("CvRNG*") IntPointer rng/*CV_DEFAULT(0)*/, int flags/*CV_DEFAULT(0)*/,
                      CvArr _centers/*CV_DEFAULT(0)*/, DoublePointer compactness/*CV_DEFAULT(0)*/ );
public static native int cvKMeans2( @Const CvArr samples, int cluster_count, CvArr labels,
                      @ByVal CvTermCriteria termcrit, int attempts/*CV_DEFAULT(1)*/,
                      @Cast("CvRNG*") IntBuffer rng/*CV_DEFAULT(0)*/, int flags/*CV_DEFAULT(0)*/,
                      CvArr _centers/*CV_DEFAULT(0)*/, DoubleBuffer compactness/*CV_DEFAULT(0)*/ );
public static native int cvKMeans2( @Const CvArr samples, int cluster_count, CvArr labels,
                      @ByVal CvTermCriteria termcrit, int attempts/*CV_DEFAULT(1)*/,
                      @Cast("CvRNG*") int[] rng/*CV_DEFAULT(0)*/, int flags/*CV_DEFAULT(0)*/,
                      CvArr _centers/*CV_DEFAULT(0)*/, double[] compactness/*CV_DEFAULT(0)*/ );

/****************************************************************************************\
*                                    System functions                                    *
\****************************************************************************************/

/* Add the function pointers table with associated information to the IPP primitives list */
public static native int cvRegisterModule( @Const CvModuleInfo module_info );

/* Loads optimized functions from IPP, MKL etc. or switches back to pure C code */
public static native int cvUseOptimized( int on_off );

/* Retrieves information about the registered modules and loaded optimized plugins */
public static native void cvGetModuleInfo( @Cast("const char*") BytePointer module_name,
                              @Cast("const char**") PointerPointer version,
                              @Cast("const char**") PointerPointer loaded_addon_plugins );
public static native void cvGetModuleInfo( @Cast("const char*") BytePointer module_name,
                              @Cast("const char**") @ByPtrPtr BytePointer version,
                              @Cast("const char**") @ByPtrPtr BytePointer loaded_addon_plugins );
public static native void cvGetModuleInfo( String module_name,
                              @Cast("const char**") @ByPtrPtr ByteBuffer version,
                              @Cast("const char**") @ByPtrPtr ByteBuffer loaded_addon_plugins );
public static native void cvGetModuleInfo( @Cast("const char*") BytePointer module_name,
                              @Cast("const char**") @ByPtrPtr byte[] version,
                              @Cast("const char**") @ByPtrPtr byte[] loaded_addon_plugins );
public static native void cvGetModuleInfo( String module_name,
                              @Cast("const char**") @ByPtrPtr BytePointer version,
                              @Cast("const char**") @ByPtrPtr BytePointer loaded_addon_plugins );
public static native void cvGetModuleInfo( @Cast("const char*") BytePointer module_name,
                              @Cast("const char**") @ByPtrPtr ByteBuffer version,
                              @Cast("const char**") @ByPtrPtr ByteBuffer loaded_addon_plugins );
public static native void cvGetModuleInfo( String module_name,
                              @Cast("const char**") @ByPtrPtr byte[] version,
                              @Cast("const char**") @ByPtrPtr byte[] loaded_addon_plugins );

public static class CvAllocFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvAllocFunc(Pointer p) { super(p); }
    protected CvAllocFunc() { allocate(); }
    private native void allocate();
    public native Pointer call(@Cast("size_t") long size, Pointer userdata);
}
public static class CvFreeFunc extends FunctionPointer {
    static { Loader.load(); }
    public    CvFreeFunc(Pointer p) { super(p); }
    protected CvFreeFunc() { allocate(); }
    private native void allocate();
    public native int call(Pointer pptr, Pointer userdata);
}

/* Set user-defined memory managment functions (substitutors for malloc and free) that
   will be called by cvAlloc, cvFree and higher-level functions (e.g. cvCreateImage) */
public static native void cvSetMemoryManager( CvAllocFunc alloc_func/*CV_DEFAULT(NULL)*/,
                               CvFreeFunc free_func/*CV_DEFAULT(NULL)*/,
                               Pointer userdata/*CV_DEFAULT(NULL)*/);


public static class Cv_iplCreateImageHeader extends FunctionPointer {
    static { Loader.load(); }
    public    Cv_iplCreateImageHeader(Pointer p) { super(p); }
    protected Cv_iplCreateImageHeader() { allocate(); }
    private native void allocate();
    public native IplImage call(int arg0,int arg1,int arg2,@Cast("char*") BytePointer arg3,@Cast("char*") BytePointer arg4,int arg5,int arg6,int arg7,int arg8,int arg9,
                            IplROI arg10,IplImage arg11,Pointer arg12,IplTileInfo arg13);
}
public static class Cv_iplAllocateImageData extends FunctionPointer {
    static { Loader.load(); }
    public    Cv_iplAllocateImageData(Pointer p) { super(p); }
    protected Cv_iplAllocateImageData() { allocate(); }
    private native void allocate();
    public native void call(IplImage arg0,int arg1,int arg2);
}
public static class Cv_iplDeallocate extends FunctionPointer {
    static { Loader.load(); }
    public    Cv_iplDeallocate(Pointer p) { super(p); }
    protected Cv_iplDeallocate() { allocate(); }
    private native void allocate();
    public native void call(IplImage arg0,int arg1);
}
public static class Cv_iplCreateROI extends FunctionPointer {
    static { Loader.load(); }
    public    Cv_iplCreateROI(Pointer p) { super(p); }
    protected Cv_iplCreateROI() { allocate(); }
    private native void allocate();
    public native IplROI call(int arg0,int arg1,int arg2,int arg3,int arg4);
}
public static class Cv_iplCloneImage extends FunctionPointer {
    static { Loader.load(); }
    public    Cv_iplCloneImage(Pointer p) { super(p); }
    protected Cv_iplCloneImage() { allocate(); }
    private native void allocate();
    public native IplImage call(@Const IplImage arg0);
}

/* Makes OpenCV use IPL functions for IplImage allocation/deallocation */
public static native void cvSetIPLAllocators( Cv_iplCreateImageHeader create_header,
                               Cv_iplAllocateImageData allocate_data,
                               Cv_iplDeallocate deallocate,
                               Cv_iplCreateROI create_roi,
                               Cv_iplCloneImage clone_image );

// #define CV_TURN_ON_IPL_COMPATIBILITY()
//     cvSetIPLAllocators( iplCreateImageHeader, iplAllocateImage,
//                         iplDeallocate, iplCreateROI, iplCloneImage )

/****************************************************************************************\
*                                    Data Persistence                                    *
\****************************************************************************************/

/********************************** High-level functions ********************************/

/* opens existing or creates new file storage */
public static native CvFileStorage cvOpenFileStorage( @Cast("const char*") BytePointer filename, CvMemStorage memstorage,
                                          int flags, @Cast("const char*") BytePointer encoding/*CV_DEFAULT(NULL)*/ );
public static native CvFileStorage cvOpenFileStorage( String filename, CvMemStorage memstorage,
                                          int flags, String encoding/*CV_DEFAULT(NULL)*/ );

/* closes file storage and deallocates buffers */
public static native void cvReleaseFileStorage( @Cast("CvFileStorage**") PointerPointer fs );
public static native void cvReleaseFileStorage( @ByPtrPtr CvFileStorage fs );

/* returns attribute value or 0 (NULL) if there is no such attribute */
public static native @Cast("const char*") BytePointer cvAttrValue( @Const CvAttrList attr, @Cast("const char*") BytePointer attr_name );
public static native String cvAttrValue( @Const CvAttrList attr, String attr_name );

/* starts writing compound structure (map or sequence) */
public static native void cvStartWriteStruct( CvFileStorage fs, @Cast("const char*") BytePointer name,
                                int struct_flags, @Cast("const char*") BytePointer type_name/*CV_DEFAULT(NULL)*/,
                                @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);
public static native void cvStartWriteStruct( CvFileStorage fs, String name,
                                int struct_flags, String type_name/*CV_DEFAULT(NULL)*/,
                                @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);

/* finishes writing compound structure */
public static native void cvEndWriteStruct( CvFileStorage fs );

/* writes an integer */
public static native void cvWriteInt( CvFileStorage fs, @Cast("const char*") BytePointer name, int value );
public static native void cvWriteInt( CvFileStorage fs, String name, int value );

/* writes a floating-point number */
public static native void cvWriteReal( CvFileStorage fs, @Cast("const char*") BytePointer name, double value );
public static native void cvWriteReal( CvFileStorage fs, String name, double value );

/* writes a string */
public static native void cvWriteString( CvFileStorage fs, @Cast("const char*") BytePointer name,
                           @Cast("const char*") BytePointer str, int quote/*CV_DEFAULT(0)*/ );
public static native void cvWriteString( CvFileStorage fs, String name,
                           String str, int quote/*CV_DEFAULT(0)*/ );

/* writes a comment */
public static native void cvWriteComment( CvFileStorage fs, @Cast("const char*") BytePointer comment,
                            int eol_comment );
public static native void cvWriteComment( CvFileStorage fs, String comment,
                            int eol_comment );

/* writes instance of a standard type (matrix, image, sequence, graph etc.)
   or user-defined type */
public static native void cvWrite( CvFileStorage fs, @Cast("const char*") BytePointer name, @Const Pointer ptr,
                         @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);
public static native void cvWrite( CvFileStorage fs, String name, @Const Pointer ptr,
                         @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);

/* starts the next stream */
public static native void cvStartNextStream( CvFileStorage fs );

/* helper function: writes multiple integer or floating-point numbers */
public static native void cvWriteRawData( CvFileStorage fs, @Const Pointer src,
                                int len, @Cast("const char*") BytePointer dt );
public static native void cvWriteRawData( CvFileStorage fs, @Const Pointer src,
                                int len, String dt );

/* returns the hash entry corresponding to the specified literal key string or 0
   if there is no such a key in the storage */
public static native CvStringHashNode cvGetHashedKey( CvFileStorage fs, @Cast("const char*") BytePointer name,
                                        int len/*CV_DEFAULT(-1)*/,
                                        int create_missing/*CV_DEFAULT(0)*/);
public static native CvStringHashNode cvGetHashedKey( CvFileStorage fs, String name,
                                        int len/*CV_DEFAULT(-1)*/,
                                        int create_missing/*CV_DEFAULT(0)*/);

/* returns file node with the specified key within the specified map
   (collection of named nodes) */
public static native CvFileNode cvGetRootFileNode( @Const CvFileStorage fs,
                                     int stream_index/*CV_DEFAULT(0)*/ );

/* returns file node with the specified key within the specified map
   (collection of named nodes) */
public static native CvFileNode cvGetFileNode( CvFileStorage fs, CvFileNode map,
                                 @Const CvStringHashNode key,
                                 int create_missing/*CV_DEFAULT(0)*/ );

/* this is a slower version of cvGetFileNode that takes the key as a literal string */
public static native CvFileNode cvGetFileNodeByName( @Const CvFileStorage fs,
                                       @Const CvFileNode map,
                                       @Cast("const char*") BytePointer name );
public static native CvFileNode cvGetFileNodeByName( @Const CvFileStorage fs,
                                       @Const CvFileNode map,
                                       String name );

public static native int cvReadInt( @Const CvFileNode node, int default_value/*CV_DEFAULT(0)*/ );


public static native int cvReadIntByName( @Const CvFileStorage fs, @Const CvFileNode map,
                         @Cast("const char*") BytePointer name, int default_value/*CV_DEFAULT(0)*/ );
public static native int cvReadIntByName( @Const CvFileStorage fs, @Const CvFileNode map,
                         String name, int default_value/*CV_DEFAULT(0)*/ );


public static native double cvReadReal( @Const CvFileNode node, double default_value/*CV_DEFAULT(0.)*/ );


public static native double cvReadRealByName( @Const CvFileStorage fs, @Const CvFileNode map,
                        @Cast("const char*") BytePointer name, double default_value/*CV_DEFAULT(0.)*/ );
public static native double cvReadRealByName( @Const CvFileStorage fs, @Const CvFileNode map,
                        String name, double default_value/*CV_DEFAULT(0.)*/ );


public static native @Cast("const char*") BytePointer cvReadString( @Const CvFileNode node,
                        @Cast("const char*") BytePointer default_value/*CV_DEFAULT(NULL)*/ );
public static native String cvReadString( @Const CvFileNode node,
                        String default_value/*CV_DEFAULT(NULL)*/ );


public static native @Cast("const char*") BytePointer cvReadStringByName( @Const CvFileStorage fs, @Const CvFileNode map,
                        @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer default_value/*CV_DEFAULT(NULL)*/ );
public static native String cvReadStringByName( @Const CvFileStorage fs, @Const CvFileNode map,
                        String name, String default_value/*CV_DEFAULT(NULL)*/ );


/* decodes standard or user-defined object and returns it */
public static native Pointer cvRead( CvFileStorage fs, CvFileNode node,
                        CvAttrList attributes/*CV_DEFAULT(NULL)*/);

/* decodes standard or user-defined object and returns it */
public static native Pointer cvReadByName( CvFileStorage fs, @Const CvFileNode map,
                              @Cast("const char*") BytePointer name, CvAttrList attributes/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvReadByName( CvFileStorage fs, @Const CvFileNode map,
                              String name, CvAttrList attributes/*CV_DEFAULT(NULL)*/ );


/* starts reading data from sequence or scalar numeric node */
public static native void cvStartReadRawData( @Const CvFileStorage fs, @Const CvFileNode src,
                               CvSeqReader reader );

/* reads multiple numbers and stores them to array */
public static native void cvReadRawDataSlice( @Const CvFileStorage fs, CvSeqReader reader,
                               int count, Pointer dst, @Cast("const char*") BytePointer dt );
public static native void cvReadRawDataSlice( @Const CvFileStorage fs, CvSeqReader reader,
                               int count, Pointer dst, String dt );

/* combination of two previous functions for easier reading of whole sequences */
public static native void cvReadRawData( @Const CvFileStorage fs, @Const CvFileNode src,
                          Pointer dst, @Cast("const char*") BytePointer dt );
public static native void cvReadRawData( @Const CvFileStorage fs, @Const CvFileNode src,
                          Pointer dst, String dt );

/* writes a copy of file node to file storage */
public static native void cvWriteFileNode( CvFileStorage fs, @Cast("const char*") BytePointer new_node_name,
                            @Const CvFileNode node, int embed );
public static native void cvWriteFileNode( CvFileStorage fs, String new_node_name,
                            @Const CvFileNode node, int embed );

/* returns name of file node */
public static native @Cast("const char*") BytePointer cvGetFileNodeName( @Const CvFileNode node );

/*********************************** Adding own types ***********************************/

public static native void cvRegisterType( @Const CvTypeInfo info );
public static native void cvUnregisterType( @Cast("const char*") BytePointer type_name );
public static native void cvUnregisterType( String type_name );
public static native CvTypeInfo cvFirstType();
public static native CvTypeInfo cvFindType( @Cast("const char*") BytePointer type_name );
public static native CvTypeInfo cvFindType( String type_name );
public static native CvTypeInfo cvTypeOf( @Const Pointer struct_ptr );

/* universal functions */
public static native void cvRelease( @Cast("void**") PointerPointer struct_ptr );
public static native void cvRelease( @Cast("void**") @ByPtrPtr Pointer struct_ptr );
public static native Pointer cvClone( @Const Pointer struct_ptr );

/* simple API for reading/writing data */
public static native void cvSave( @Cast("const char*") BytePointer filename, @Const Pointer struct_ptr,
                    @Cast("const char*") BytePointer name/*CV_DEFAULT(NULL)*/,
                    @Cast("const char*") BytePointer comment/*CV_DEFAULT(NULL)*/,
                    @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);
public static native void cvSave( String filename, @Const Pointer struct_ptr,
                    String name/*CV_DEFAULT(NULL)*/,
                    String comment/*CV_DEFAULT(NULL)*/,
                    @ByVal CvAttrList attributes/*CV_DEFAULT(cvAttrList())*/);
public static native Pointer cvLoad( @Cast("const char*") BytePointer filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     @Cast("const char*") BytePointer name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") PointerPointer real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( @Cast("const char*") BytePointer filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     @Cast("const char*") BytePointer name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr BytePointer real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( String filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     String name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr ByteBuffer real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( @Cast("const char*") BytePointer filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     @Cast("const char*") BytePointer name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr byte[] real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( String filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     String name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr BytePointer real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( @Cast("const char*") BytePointer filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     @Cast("const char*") BytePointer name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr ByteBuffer real_name/*CV_DEFAULT(NULL)*/ );
public static native Pointer cvLoad( String filename,
                     CvMemStorage memstorage/*CV_DEFAULT(NULL)*/,
                     String name/*CV_DEFAULT(NULL)*/,
                     @Cast("const char**") @ByPtrPtr byte[] real_name/*CV_DEFAULT(NULL)*/ );

/*********************************** Measuring Execution Time ***************************/

/* helper functions for RNG initialization and accurate time measurement:
   uses internal clock counter on x86 */
public static native @Cast("int64") long cvGetTickCount( );
public static native double cvGetTickFrequency( );

/*********************************** CPU capabilities ***********************************/

public static final int CV_CPU_NONE =    0;
public static final int CV_CPU_MMX =     1;
public static final int CV_CPU_SSE =     2;
public static final int CV_CPU_SSE2 =    3;
public static final int CV_CPU_SSE3 =    4;
public static final int CV_CPU_SSSE3 =   5;
public static final int CV_CPU_SSE4_1 =  6;
public static final int CV_CPU_SSE4_2 =  7;
public static final int CV_CPU_POPCNT =  8;
public static final int CV_CPU_AVX =    10;
public static final int CV_HARDWARE_MAX_FEATURE = 255;

public static native int cvCheckHardwareSupport(int feature);

/*********************************** Multi-Threading ************************************/

/* retrieve/set the number of threads used in OpenMP implementations */
public static native int cvGetNumThreads( );
public static native void cvSetNumThreads( int threads/*CV_DEFAULT(0)*/ );
/* get index of the thread being executed */
public static native int cvGetThreadNum( );


/********************************** Error Handling **************************************/

/* Get current OpenCV error status */
public static native int cvGetErrStatus( );

/* Sets error status silently */
public static native void cvSetErrStatus( int status );

public static final int CV_ErrModeLeaf =     0;   /* Print error and exit program */
public static final int CV_ErrModeParent =   1;   /* Print error and continue */
public static final int CV_ErrModeSilent =   2;   /* Don't print and continue */

/* Retrives current error processing mode */
public static native int cvGetErrMode( );

/* Sets error processing mode, returns previously used mode */
public static native int cvSetErrMode( int mode );

/* Sets error status and performs some additonal actions (displaying message box,
 writing message to stderr, terminating application etc.)
 depending on the current error mode */
public static native void cvError( int status, @Cast("const char*") BytePointer func_name,
                    @Cast("const char*") BytePointer err_msg, @Cast("const char*") BytePointer file_name, int line );
public static native void cvError( int status, String func_name,
                    String err_msg, String file_name, int line );

/* Retrieves textual description of the error given its code */
public static native @Cast("const char*") BytePointer cvErrorStr( int status );

/* Retrieves detailed information about the last error occured */
public static native int cvGetErrInfo( @Cast("const char**") PointerPointer errcode_desc, @Cast("const char**") PointerPointer description,
                        @Cast("const char**") PointerPointer filename, IntPointer line );
public static native int cvGetErrInfo( @Cast("const char**") @ByPtrPtr BytePointer errcode_desc, @Cast("const char**") @ByPtrPtr BytePointer description,
                        @Cast("const char**") @ByPtrPtr BytePointer filename, IntPointer line );
public static native int cvGetErrInfo( @Cast("const char**") @ByPtrPtr ByteBuffer errcode_desc, @Cast("const char**") @ByPtrPtr ByteBuffer description,
                        @Cast("const char**") @ByPtrPtr ByteBuffer filename, IntBuffer line );
public static native int cvGetErrInfo( @Cast("const char**") @ByPtrPtr byte[] errcode_desc, @Cast("const char**") @ByPtrPtr byte[] description,
                        @Cast("const char**") @ByPtrPtr byte[] filename, int[] line );

/* Maps IPP error codes to the counterparts from OpenCV */
public static native int cvErrorFromIppStatus( int ipp_status );

public static class CvErrorCallback extends FunctionPointer {
    static { Loader.load(); }
    public    CvErrorCallback(Pointer p) { super(p); }
    protected CvErrorCallback() { allocate(); }
    private native void allocate();
    public native int call( int status, @Cast("const char*") BytePointer func_name,
                                        @Cast("const char*") BytePointer err_msg, @Cast("const char*") BytePointer file_name, int line, Pointer userdata );
}

/* Assigns a new error-handling function */
public static native CvErrorCallback cvRedirectError( CvErrorCallback error_handler,
                                       Pointer userdata/*CV_DEFAULT(NULL)*/,
                                       @Cast("void**") PointerPointer prev_userdata/*CV_DEFAULT(NULL)*/ );
public static native CvErrorCallback cvRedirectError( CvErrorCallback error_handler,
                                       Pointer userdata/*CV_DEFAULT(NULL)*/,
                                       @Cast("void**") @ByPtrPtr Pointer prev_userdata/*CV_DEFAULT(NULL)*/ );

/*
 Output to:
 cvNulDevReport - nothing
 cvStdErrReport - console(fprintf(stderr,...))
 cvGuiBoxReport - MessageBox(WIN32)
 */
public static native int cvNulDevReport( int status, @Cast("const char*") BytePointer func_name, @Cast("const char*") BytePointer err_msg,
                          @Cast("const char*") BytePointer file_name, int line, Pointer userdata );
public static native int cvNulDevReport( int status, String func_name, String err_msg,
                          String file_name, int line, Pointer userdata );

public static native int cvStdErrReport( int status, @Cast("const char*") BytePointer func_name, @Cast("const char*") BytePointer err_msg,
                          @Cast("const char*") BytePointer file_name, int line, Pointer userdata );
public static native int cvStdErrReport( int status, String func_name, String err_msg,
                          String file_name, int line, Pointer userdata );

public static native int cvGuiBoxReport( int status, @Cast("const char*") BytePointer func_name, @Cast("const char*") BytePointer err_msg,
                          @Cast("const char*") BytePointer file_name, int line, Pointer userdata );
public static native int cvGuiBoxReport( int status, String func_name, String err_msg,
                          String file_name, int line, Pointer userdata );

// #define OPENCV_ERROR(status,func,context)
// cvError((status),(func),(context),__FILE__,__LINE__)

// #define OPENCV_ERRCHK(func,context)
// {if (cvGetErrStatus() >= 0)
// {OPENCV_ERROR(CV_StsBackTrace,(func),(context));}}

// #define OPENCV_ASSERT(expr,func,context)
// {if (! (expr))
// {OPENCV_ERROR(CV_StsInternal,(func),(context));}}

// #define OPENCV_RSTERR() (cvSetErrStatus(CV_StsOk))

// #define OPENCV_CALL( Func )
// {
// Func;
// }


/* CV_FUNCNAME macro defines icvFuncName constant which is used by CV_ERROR macro */
// #ifdef CV_NO_FUNC_NAMES
// #define CV_FUNCNAME( Name )
public static final String cvFuncName = "";
// #else
// #define CV_FUNCNAME( Name )
// static char cvFuncName[] = Name
// #endif


/*
 CV_ERROR macro unconditionally raises error with passed code and message.
 After raising error, control will be transferred to the exit label.
 */
// #define CV_ERROR( Code, Msg )
// {
//     cvError( (Code), cvFuncName, Msg, __FILE__, __LINE__ );
//     __CV_EXIT__;
// }

/* Simplified form of CV_ERROR */
// #define CV_ERROR_FROM_CODE( code )
//     CV_ERROR( code, "" )

/*
 CV_CHECK macro checks error status after CV (or IPL)
 function call. If error detected, control will be transferred to the exit
 label.
 */
// #define CV_CHECK()
// {
//     if( cvGetErrStatus() < 0 )
//         CV_ERROR( CV_StsBackTrace, "Inner function failed." );
// }


/*
 CV_CALL macro calls CV (or IPL) function, checks error status and
 signals a error if the function failed. Useful in "parent node"
 error procesing mode
 */
// #define CV_CALL( Func )
// {
//     Func;
//     CV_CHECK();
// }


/* Runtime assertion macro */
// #define CV_ASSERT( Condition )
// {
//     if( !(Condition) )
//         CV_ERROR( CV_StsInternal, "Assertion: " #Condition " failed" );
// }

// #define __CV_BEGIN__       {
// #define __CV_END__         goto exit; exit: ; }
// #define __CV_EXIT__        goto exit

// #ifdef __cplusplus

// #endif

// #endif


}
