/* DO NOT EDIT THIS FILE - IT IS MACHINE GENERATED */

package com.googlecode.javacpp;

import com.googlecode.javacpp.*;
import com.googlecode.javacpp.annotation.*;
import java.nio.*;

import static com.googlecode.javacpp.opencv_core.*;
import static com.googlecode.javacpp.opencv_imgproc.*;
import static com.googlecode.javacpp.opencv_highgui.*;

public class opencv_objdetect extends com.googlecode.javacpp.presets.opencv_objdetect {
    static { Loader.load(); }

/* Wrapper for header file /usr/local/include/opencv2/objdetect/objdetect.hpp */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef __OPENCV_OBJDETECT_HPP__
// #define __OPENCV_OBJDETECT_HPP__

// #include "opencv2/core/core.hpp"

// #ifdef __cplusplus
// #endif

/****************************************************************************************\
*                         Haar-like Object Detection functions                           *
\****************************************************************************************/

public static final int CV_HAAR_MAGIC_VAL =    0x42500000;
public static final String CV_TYPE_NAME_HAAR =    "opencv-haar-classifier";

// #define CV_IS_HAAR_CLASSIFIER( haar )
//     ((haar) != NULL &&
//     (((const CvHaarClassifierCascade*)(haar))->flags & CV_MAGIC_MASK)==CV_HAAR_MAGIC_VAL)

public static final int CV_HAAR_FEATURE_MAX =  3;

public static class CvHaarFeature extends Pointer {
    static { Loader.load(); }
    public CvHaarFeature() { allocate(); }
    public CvHaarFeature(int size) { allocateArray(size); }
    public CvHaarFeature(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHaarFeature position(int position) {
        return (CvHaarFeature)super.position(position);
    }

    public native int tilted(); public native CvHaarFeature tilted(int tilted);
        @Name({"rect", ".r"}) public native @ByVal CvRect rect_r(int i); public native CvHaarFeature rect_r(int i, CvRect rect_r);
        @Name({"rect", ".weight"}) public native float rect_weight(int i); public native CvHaarFeature rect_weight(int i, float rect_weight);
}

public static class CvHaarClassifier extends Pointer {
    static { Loader.load(); }
    public CvHaarClassifier() { allocate(); }
    public CvHaarClassifier(int size) { allocateArray(size); }
    public CvHaarClassifier(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHaarClassifier position(int position) {
        return (CvHaarClassifier)super.position(position);
    }

    public native int count(); public native CvHaarClassifier count(int count);
    public native CvHaarFeature haar_feature(); public native CvHaarClassifier haar_feature(CvHaarFeature haar_feature);
    public native FloatPointer threshold(); public native CvHaarClassifier threshold(FloatPointer threshold);
    public native IntPointer left(); public native CvHaarClassifier left(IntPointer left);
    public native IntPointer right(); public native CvHaarClassifier right(IntPointer right);
    public native FloatPointer alpha(); public native CvHaarClassifier alpha(FloatPointer alpha);
}

public static class CvHaarStageClassifier extends Pointer {
    static { Loader.load(); }
    public CvHaarStageClassifier() { allocate(); }
    public CvHaarStageClassifier(int size) { allocateArray(size); }
    public CvHaarStageClassifier(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHaarStageClassifier position(int position) {
        return (CvHaarStageClassifier)super.position(position);
    }

    public native int count(); public native CvHaarStageClassifier count(int count);
    public native float threshold(); public native CvHaarStageClassifier threshold(float threshold);
    public native CvHaarClassifier classifier(); public native CvHaarStageClassifier classifier(CvHaarClassifier classifier);

    public native int next(); public native CvHaarStageClassifier next(int next);
    public native int child(); public native CvHaarStageClassifier child(int child);
    public native int parent(); public native CvHaarStageClassifier parent(int parent);
}

@Opaque public static class CvHidHaarClassifierCascade extends Pointer {
    public CvHidHaarClassifierCascade() { }
    public CvHidHaarClassifierCascade(Pointer p) { super(p); }
}

public static class CvHaarClassifierCascade extends Pointer {
    static { Loader.load(); }
    public CvHaarClassifierCascade() { allocate(); }
    public CvHaarClassifierCascade(int size) { allocateArray(size); }
    public CvHaarClassifierCascade(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHaarClassifierCascade position(int position) {
        return (CvHaarClassifierCascade)super.position(position);
    }

    public native int flags(); public native CvHaarClassifierCascade flags(int flags);
    public native int count(); public native CvHaarClassifierCascade count(int count);
    public native @ByVal CvSize orig_window_size(); public native CvHaarClassifierCascade orig_window_size(CvSize orig_window_size);
    public native @ByVal CvSize real_window_size(); public native CvHaarClassifierCascade real_window_size(CvSize real_window_size);
    public native double scale(); public native CvHaarClassifierCascade scale(double scale);
    public native CvHaarStageClassifier stage_classifier(); public native CvHaarClassifierCascade stage_classifier(CvHaarStageClassifier stage_classifier);
    public native CvHidHaarClassifierCascade hid_cascade(); public native CvHaarClassifierCascade hid_cascade(CvHidHaarClassifierCascade hid_cascade);
}

public static class CvAvgComp extends Pointer {
    static { Loader.load(); }
    public CvAvgComp() { allocate(); }
    public CvAvgComp(int size) { allocateArray(size); }
    public CvAvgComp(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvAvgComp position(int position) {
        return (CvAvgComp)super.position(position);
    }

    public native @ByVal CvRect rect(); public native CvAvgComp rect(CvRect rect);
    public native int neighbors(); public native CvAvgComp neighbors(int neighbors);
}

/* Loads haar classifier cascade from a directory.
   It is obsolete: convert your cascade to xml and use cvLoad instead */
public static native CvHaarClassifierCascade cvLoadHaarClassifierCascade(
                    @Cast("const char*") BytePointer directory, @ByVal CvSize orig_window_size);
public static native CvHaarClassifierCascade cvLoadHaarClassifierCascade(
                    String directory, @ByVal CvSize orig_window_size);

public static native void cvReleaseHaarClassifierCascade( @Cast("CvHaarClassifierCascade**") PointerPointer cascade );
public static native void cvReleaseHaarClassifierCascade( @ByPtrPtr CvHaarClassifierCascade cascade );

public static final int CV_HAAR_DO_CANNY_PRUNING =    1;
public static final int CV_HAAR_SCALE_IMAGE =         2;
public static final int CV_HAAR_FIND_BIGGEST_OBJECT = 4;
public static final int CV_HAAR_DO_ROUGH_SEARCH =     8;

//CVAPI(CvSeq*) cvHaarDetectObjectsForROC( const CvArr* image,
//                     CvHaarClassifierCascade* cascade, CvMemStorage* storage,
//                     CvSeq** rejectLevels, CvSeq** levelWeightds,
//                     double scale_factor CV_DEFAULT(1.1),
//                     int min_neighbors CV_DEFAULT(3), int flags CV_DEFAULT(0),
//                     CvSize min_size CV_DEFAULT(cvSize(0,0)), CvSize max_size CV_DEFAULT(cvSize(0,0)),
//                     bool outputRejectLevels = false );


public static native CvSeq cvHaarDetectObjects( @Const CvArr image,
                     CvHaarClassifierCascade cascade, CvMemStorage storage,
                     double scale_factor/*CV_DEFAULT(1.1)*/,
                     int min_neighbors/*CV_DEFAULT(3)*/, int flags/*CV_DEFAULT(0)*/,
                     @ByVal CvSize min_size/*CV_DEFAULT(cvSize(0,0))*/, @ByVal CvSize max_size/*CV_DEFAULT(cvSize(0,0))*/);

/* sets images for haar classifier cascade */
public static native void cvSetImagesForHaarClassifierCascade( CvHaarClassifierCascade cascade,
                                                @Const CvArr sum, @Const CvArr sqsum,
                                                @Const CvArr tilted_sum, double scale );

/* runs the cascade on the specified window */
public static native int cvRunHaarClassifierCascade( @Const CvHaarClassifierCascade cascade,
                                       @ByVal CvPoint pt, int start_stage/*CV_DEFAULT(0)*/);


/****************************************************************************************\
*                         Latent SVM Object Detection functions                          *
\****************************************************************************************/

// DataType: STRUCT position
// Structure describes the position of the filter in the feature pyramid
// l - level in the feature pyramid
// (x, y) - coordinate in level l
public static class CvLSVMFilterPosition extends Pointer {
    static { Loader.load(); }
    public CvLSVMFilterPosition() { allocate(); }
    public CvLSVMFilterPosition(int size) { allocateArray(size); }
    public CvLSVMFilterPosition(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLSVMFilterPosition position(int position) {
        return (CvLSVMFilterPosition)super.position(position);
    }

    public native int x(); public native CvLSVMFilterPosition x(int x);
    public native int y(); public native CvLSVMFilterPosition y(int y);
    public native int l(); public native CvLSVMFilterPosition l(int l);
}

// DataType: STRUCT filterObject
// Description of the filter, which corresponds to the part of the object
// V               - ideal (penalty = 0) position of the partial filter
//                   from the root filter position (V_i in the paper)
// penaltyFunction - vector describes penalty function (d_i in the paper)
//                   pf[0] * x + pf[1] * y + pf[2] * x^2 + pf[3] * y^2
// FILTER DESCRIPTION
//   Rectangular map (sizeX x sizeY),
//   every cell stores feature vector (dimension = p)
// H               - matrix of feature vectors
//                   to set and get feature vectors (i,j)
//                   used formula H[(j * sizeX + i) * p + k], where
//                   k - component of feature vector in cell (i, j)
// END OF FILTER DESCRIPTION
public static class CvLSVMFilterObject extends Pointer {
    static { Loader.load(); }
    public CvLSVMFilterObject() { allocate(); }
    public CvLSVMFilterObject(int size) { allocateArray(size); }
    public CvLSVMFilterObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLSVMFilterObject position(int position) {
        return (CvLSVMFilterObject)super.position(position);
    }

    public native @ByVal CvLSVMFilterPosition V(); public native CvLSVMFilterObject V(CvLSVMFilterPosition V);
    public native float fineFunction(int i); public native CvLSVMFilterObject fineFunction(int i, float fineFunction);
    @MemberGetter public native FloatPointer fineFunction();
    public native int sizeX(); public native CvLSVMFilterObject sizeX(int sizeX);
    public native int sizeY(); public native CvLSVMFilterObject sizeY(int sizeY);
    public native int numFeatures(); public native CvLSVMFilterObject numFeatures(int numFeatures);
    public native FloatPointer H(); public native CvLSVMFilterObject H(FloatPointer H);
}

// data type: STRUCT CvLatentSvmDetector
// structure contains internal representation of trained Latent SVM detector
// num_filters          - total number of filters (root plus part) in model
// num_components       - number of components in model
// num_part_filters     - array containing number of part filters for each component
// filters              - root and part filters for all model components
// b                    - biases for all model components
// score_threshold      - confidence level threshold
public static class CvLatentSvmDetector extends Pointer {
    static { Loader.load(); }
    public CvLatentSvmDetector() { allocate(); }
    public CvLatentSvmDetector(int size) { allocateArray(size); }
    public CvLatentSvmDetector(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLatentSvmDetector position(int position) {
        return (CvLatentSvmDetector)super.position(position);
    }

    public native int num_filters(); public native CvLatentSvmDetector num_filters(int num_filters);
    public native int num_components(); public native CvLatentSvmDetector num_components(int num_components);
    public native IntPointer num_part_filters(); public native CvLatentSvmDetector num_part_filters(IntPointer num_part_filters);
    public native CvLSVMFilterObject filters(int i); public native CvLatentSvmDetector filters(int i, CvLSVMFilterObject filters);
    @MemberGetter public native @Cast("CvLSVMFilterObject**") PointerPointer filters();
    public native FloatPointer b(); public native CvLatentSvmDetector b(FloatPointer b);
    public native float score_threshold(); public native CvLatentSvmDetector score_threshold(float score_threshold);
}

// data type: STRUCT CvObjectDetection
// structure contains the bounding box and confidence level for detected object
// rect                 - bounding box for a detected object
// score                - confidence level
public static class CvObjectDetection extends Pointer {
    static { Loader.load(); }
    public CvObjectDetection() { allocate(); }
    public CvObjectDetection(int size) { allocateArray(size); }
    public CvObjectDetection(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvObjectDetection position(int position) {
        return (CvObjectDetection)super.position(position);
    }

    public native @ByVal CvRect rect(); public native CvObjectDetection rect(CvRect rect);
    public native float score(); public native CvObjectDetection score(float score);
}

//////////////// Object Detection using Latent SVM //////////////


/*
// load trained detector from a file
//
// API
// CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename);
// INPUT
// filename             - path to the file containing the parameters of
                        - trained Latent SVM detector
// OUTPUT
// trained Latent SVM detector in internal representation
*/
public static native CvLatentSvmDetector cvLoadLatentSvmDetector(@Cast("const char*") BytePointer filename);
public static native CvLatentSvmDetector cvLoadLatentSvmDetector(String filename);

/*
// release memory allocated for CvLatentSvmDetector structure
//
// API
// void cvReleaseLatentSvmDetector(CvLatentSvmDetector** detector);
// INPUT
// detector             - CvLatentSvmDetector structure to be released
// OUTPUT
*/
public static native void cvReleaseLatentSvmDetector(@Cast("CvLatentSvmDetector**") PointerPointer detector);
public static native void cvReleaseLatentSvmDetector(@ByPtrPtr CvLatentSvmDetector detector);

/*
// find rectangular regions in the given image that are likely
// to contain objects and corresponding confidence levels
//
// API
// CvSeq* cvLatentSvmDetectObjects(const IplImage* image,
//                                  CvLatentSvmDetector* detector,
//                                  CvMemStorage* storage,
//                                  float overlap_threshold = 0.5f,
//                                  int numThreads = -1);
// INPUT
// image                - image to detect objects in
// detector             - Latent SVM detector in internal representation
// storage              - memory storage to store the resultant sequence
//                          of the object candidate rectangles
// overlap_threshold    - threshold for the non-maximum suppression algorithm
                           = 0.5f [here will be the reference to original paper]
// OUTPUT
// sequence of detected objects (bounding boxes and confidence levels stored in CvObjectDetection structures)
*/
public static native CvSeq cvLatentSvmDetectObjects(IplImage image,
                                CvLatentSvmDetector detector,
                                CvMemStorage storage,
                                float overlap_threshold/*CV_DEFAULT(0.5f)*/,
                                int numThreads/*CV_DEFAULT(-1)*/);

// #ifdef __cplusplus

// #endif

// #endif


}
