/* DO NOT EDIT THIS FILE - IT IS MACHINE GENERATED */

package com.googlecode.javacpp;

import com.googlecode.javacpp.*;
import com.googlecode.javacpp.annotation.*;
import java.nio.*;

import static com.googlecode.javacpp.opencv_core.*;

public class opencv_imgproc extends com.googlecode.javacpp.presets.opencv_imgproc {
    static { Loader.load(); }

/* Wrapper for header file /usr/local/include/opencv2/imgproc/types_c.h */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef __OPENCV_IMGPROC_TYPES_C_H__
// #define __OPENCV_IMGPROC_TYPES_C_H__

// #include "opencv2/core/core_c.h"

// #ifdef __cplusplus
// #endif

/* Connected component structure */
public static class CvConnectedComp extends Pointer {
    static { Loader.load(); }
    public CvConnectedComp() { allocate(); }
    public CvConnectedComp(int size) { allocateArray(size); }
    public CvConnectedComp(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvConnectedComp position(int position) {
        return (CvConnectedComp)super.position(position);
    }

    public native double area(); public native CvConnectedComp area(double area);    /* area of the connected component  */
    public native @ByVal CvScalar value(); public native CvConnectedComp value(CvScalar value); /* average color of the connected component */
    public native @ByVal CvRect rect(); public native CvConnectedComp rect(CvRect rect);    /* ROI of the component  */
    public native CvSeq contour(); public native CvConnectedComp contour(CvSeq contour); /* optional component boundary
                      (the contour might have child contours corresponding to the holes)*/
}

/* Image smooth methods */
/** enum  */
public static final int
    CV_BLUR_NO_SCALE = 0,
    CV_BLUR  = 1,
    CV_GAUSSIAN  = 2,
    CV_MEDIAN = 3,
    CV_BILATERAL = 4;

/* Filters used in pyramid decomposition */
/** enum  */
public static final int
    CV_GAUSSIAN_5x5 = 7;

/* Special filters */
/** enum  */
public static final int
    CV_SCHARR = -1,
    CV_MAX_SOBEL_KSIZE = 7;

/* Constants for color conversion */
/** enum  */
public static final int
    CV_BGR2BGRA    = 0,
    CV_RGB2RGBA    = CV_BGR2BGRA,

    CV_BGRA2BGR    = 1,
    CV_RGBA2RGB    = CV_BGRA2BGR,

    CV_BGR2RGBA    = 2,
    CV_RGB2BGRA    = CV_BGR2RGBA,

    CV_RGBA2BGR    = 3,
    CV_BGRA2RGB    = CV_RGBA2BGR,

    CV_BGR2RGB     = 4,
    CV_RGB2BGR     = CV_BGR2RGB,

    CV_BGRA2RGBA   = 5,
    CV_RGBA2BGRA   = CV_BGRA2RGBA,

    CV_BGR2GRAY    = 6,
    CV_RGB2GRAY    = 7,
    CV_GRAY2BGR    = 8,
    CV_GRAY2RGB    = CV_GRAY2BGR,
    CV_GRAY2BGRA   = 9,
    CV_GRAY2RGBA   = CV_GRAY2BGRA,
    CV_BGRA2GRAY   = 10,
    CV_RGBA2GRAY   = 11,

    CV_BGR2BGR565  = 12,
    CV_RGB2BGR565  = 13,
    CV_BGR5652BGR  = 14,
    CV_BGR5652RGB  = 15,
    CV_BGRA2BGR565 = 16,
    CV_RGBA2BGR565 = 17,
    CV_BGR5652BGRA = 18,
    CV_BGR5652RGBA = 19,

    CV_GRAY2BGR565 = 20,
    CV_BGR5652GRAY = 21,

    CV_BGR2BGR555  = 22,
    CV_RGB2BGR555  = 23,
    CV_BGR5552BGR  = 24,
    CV_BGR5552RGB  = 25,
    CV_BGRA2BGR555 = 26,
    CV_RGBA2BGR555 = 27,
    CV_BGR5552BGRA = 28,
    CV_BGR5552RGBA = 29,

    CV_GRAY2BGR555 = 30,
    CV_BGR5552GRAY = 31,

    CV_BGR2XYZ     = 32,
    CV_RGB2XYZ     = 33,
    CV_XYZ2BGR     = 34,
    CV_XYZ2RGB     = 35,

    CV_BGR2YCrCb   = 36,
    CV_RGB2YCrCb   = 37,
    CV_YCrCb2BGR   = 38,
    CV_YCrCb2RGB   = 39,

    CV_BGR2HSV     = 40,
    CV_RGB2HSV     = 41,

    CV_BGR2Lab     = 44,
    CV_RGB2Lab     = 45,

    CV_BayerBG2BGR = 46,
    CV_BayerGB2BGR = 47,
    CV_BayerRG2BGR = 48,
    CV_BayerGR2BGR = 49,

    CV_BayerBG2RGB = CV_BayerRG2BGR,
    CV_BayerGB2RGB = CV_BayerGR2BGR,
    CV_BayerRG2RGB = CV_BayerBG2BGR,
    CV_BayerGR2RGB = CV_BayerGB2BGR,

    CV_BGR2Luv     = 50,
    CV_RGB2Luv     = 51,
    CV_BGR2HLS     = 52,
    CV_RGB2HLS     = 53,

    CV_HSV2BGR     = 54,
    CV_HSV2RGB     = 55,

    CV_Lab2BGR     = 56,
    CV_Lab2RGB     = 57,
    CV_Luv2BGR     = 58,
    CV_Luv2RGB     = 59,
    CV_HLS2BGR     = 60,
    CV_HLS2RGB     = 61,

    CV_BayerBG2BGR_VNG = 62,
    CV_BayerGB2BGR_VNG = 63,
    CV_BayerRG2BGR_VNG = 64,
    CV_BayerGR2BGR_VNG = 65,

    CV_BayerBG2RGB_VNG = CV_BayerRG2BGR_VNG,
    CV_BayerGB2RGB_VNG = CV_BayerGR2BGR_VNG,
    CV_BayerRG2RGB_VNG = CV_BayerBG2BGR_VNG,
    CV_BayerGR2RGB_VNG = CV_BayerGB2BGR_VNG,

    CV_BGR2HSV_FULL = 66,
    CV_RGB2HSV_FULL = 67,
    CV_BGR2HLS_FULL = 68,
    CV_RGB2HLS_FULL = 69,

    CV_HSV2BGR_FULL = 70,
    CV_HSV2RGB_FULL = 71,
    CV_HLS2BGR_FULL = 72,
    CV_HLS2RGB_FULL = 73,

    CV_LBGR2Lab     = 74,
    CV_LRGB2Lab     = 75,
    CV_LBGR2Luv     = 76,
    CV_LRGB2Luv     = 77,

    CV_Lab2LBGR     = 78,
    CV_Lab2LRGB     = 79,
    CV_Luv2LBGR     = 80,
    CV_Luv2LRGB     = 81,

    CV_BGR2YUV      = 82,
    CV_RGB2YUV      = 83,
    CV_YUV2BGR      = 84,
    CV_YUV2RGB      = 85,

    CV_BayerBG2GRAY = 86,
    CV_BayerGB2GRAY = 87,
    CV_BayerRG2GRAY = 88,
    CV_BayerGR2GRAY = 89,

    //YUV 4:2:0 formats family
    CV_YUV2RGB_NV12 = 90,
    CV_YUV2BGR_NV12 = 91,
    CV_YUV2RGB_NV21 = 92,
    CV_YUV2BGR_NV21 = 93,
    CV_YUV420sp2RGB =  CV_YUV2RGB_NV21,
    CV_YUV420sp2BGR =  CV_YUV2BGR_NV21,

    CV_YUV2RGBA_NV12 = 94,
    CV_YUV2BGRA_NV12 = 95,
    CV_YUV2RGBA_NV21 = 96,
    CV_YUV2BGRA_NV21 = 97,
    CV_YUV420sp2RGBA =  CV_YUV2RGBA_NV21,
    CV_YUV420sp2BGRA =  CV_YUV2BGRA_NV21,

    CV_YUV2RGB_YV12 = 98,
    CV_YUV2BGR_YV12 = 99,
    CV_YUV2RGB_IYUV = 100,
    CV_YUV2BGR_IYUV = 101,
    CV_YUV2RGB_I420 =  CV_YUV2RGB_IYUV,
    CV_YUV2BGR_I420 =  CV_YUV2BGR_IYUV,
    CV_YUV420p2RGB =  CV_YUV2RGB_YV12,
    CV_YUV420p2BGR =  CV_YUV2BGR_YV12,

    CV_YUV2RGBA_YV12 = 102,
    CV_YUV2BGRA_YV12 = 103,
    CV_YUV2RGBA_IYUV = 104,
    CV_YUV2BGRA_IYUV = 105,
    CV_YUV2RGBA_I420 =  CV_YUV2RGBA_IYUV,
    CV_YUV2BGRA_I420 =  CV_YUV2BGRA_IYUV,
    CV_YUV420p2RGBA =  CV_YUV2RGBA_YV12,
    CV_YUV420p2BGRA =  CV_YUV2BGRA_YV12,

    CV_YUV2GRAY_420 = 106,
    CV_YUV2GRAY_NV21 =  CV_YUV2GRAY_420,
    CV_YUV2GRAY_NV12 =  CV_YUV2GRAY_420,
    CV_YUV2GRAY_YV12 =  CV_YUV2GRAY_420,
    CV_YUV2GRAY_IYUV =  CV_YUV2GRAY_420,
    CV_YUV2GRAY_I420 =  CV_YUV2GRAY_420,
    CV_YUV420sp2GRAY =  CV_YUV2GRAY_420,
    CV_YUV420p2GRAY =  CV_YUV2GRAY_420,

    //YUV 4:2:2 formats family
    CV_YUV2RGB_UYVY = 107,
    CV_YUV2BGR_UYVY = 108,
    //CV_YUV2RGB_VYUY = 109,
    //CV_YUV2BGR_VYUY = 110,
    CV_YUV2RGB_Y422 =  CV_YUV2RGB_UYVY,
    CV_YUV2BGR_Y422 =  CV_YUV2BGR_UYVY,
    CV_YUV2RGB_UYNV =  CV_YUV2RGB_UYVY,
    CV_YUV2BGR_UYNV =  CV_YUV2BGR_UYVY,

    CV_YUV2RGBA_UYVY = 111,
    CV_YUV2BGRA_UYVY = 112,
    //CV_YUV2RGBA_VYUY = 113,
    //CV_YUV2BGRA_VYUY = 114,
    CV_YUV2RGBA_Y422 =  CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_Y422 =  CV_YUV2BGRA_UYVY,
    CV_YUV2RGBA_UYNV =  CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_UYNV =  CV_YUV2BGRA_UYVY,

    CV_YUV2RGB_YUY2 = 115,
    CV_YUV2BGR_YUY2 = 116,
    CV_YUV2RGB_YVYU = 117,
    CV_YUV2BGR_YVYU = 118,
    CV_YUV2RGB_YUYV =  CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUYV =  CV_YUV2BGR_YUY2,
    CV_YUV2RGB_YUNV =  CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUNV =  CV_YUV2BGR_YUY2,

    CV_YUV2RGBA_YUY2 = 119,
    CV_YUV2BGRA_YUY2 = 120,
    CV_YUV2RGBA_YVYU = 121,
    CV_YUV2BGRA_YVYU = 122,
    CV_YUV2RGBA_YUYV =  CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUYV =  CV_YUV2BGRA_YUY2,
    CV_YUV2RGBA_YUNV =  CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUNV =  CV_YUV2BGRA_YUY2,

    CV_YUV2GRAY_UYVY = 123,
    CV_YUV2GRAY_YUY2 = 124,
    //CV_YUV2GRAY_VYUY = CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_Y422 =  CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_UYNV =  CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_YVYU =  CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUYV =  CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUNV =  CV_YUV2GRAY_YUY2,

    // alpha premultiplication
    CV_RGBA2mRGBA = 125,
    CV_mRGBA2RGBA = 126,

    CV_RGB2YUV_I420 = 127,
    CV_BGR2YUV_I420 = 128,
    CV_RGB2YUV_IYUV =  CV_RGB2YUV_I420,
    CV_BGR2YUV_IYUV =  CV_BGR2YUV_I420,

    CV_RGBA2YUV_I420 = 129,
    CV_BGRA2YUV_I420 = 130,
    CV_RGBA2YUV_IYUV =  CV_RGBA2YUV_I420,
    CV_BGRA2YUV_IYUV =  CV_BGRA2YUV_I420,
    CV_RGB2YUV_YV12  = 131,
    CV_BGR2YUV_YV12  = 132,
    CV_RGBA2YUV_YV12 = 133,
    CV_BGRA2YUV_YV12 = 134,

    CV_COLORCVT_MAX  = 135;


/* Sub-pixel interpolation methods */
/** enum  */
public static final int
    CV_INTER_NN        = 0,
    CV_INTER_LINEAR    = 1,
    CV_INTER_CUBIC     = 2,
    CV_INTER_AREA      = 3,
    CV_INTER_LANCZOS4  = 4;

/* ... and other image warping flags */
/** enum  */
public static final int
    CV_WARP_FILL_OUTLIERS = 8,
    CV_WARP_INVERSE_MAP  = 16;

/* Shapes of a structuring element for morphological operations */
/** enum  */
public static final int
    CV_SHAPE_RECT      = 0,
    CV_SHAPE_CROSS     = 1,
    CV_SHAPE_ELLIPSE   = 2,
    CV_SHAPE_CUSTOM    = 100;

/* Morphological operations */
/** enum  */
public static final int
    CV_MOP_ERODE        = 0,
    CV_MOP_DILATE       = 1,
    CV_MOP_OPEN         = 2,
    CV_MOP_CLOSE        = 3,
    CV_MOP_GRADIENT     = 4,
    CV_MOP_TOPHAT       = 5,
    CV_MOP_BLACKHAT     = 6;

/* Spatial and central moments */
public static class CvMoments extends Pointer {
    static { Loader.load(); }
    public CvMoments() { allocate(); }
    public CvMoments(int size) { allocateArray(size); }
    public CvMoments(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMoments position(int position) {
        return (CvMoments)super.position(position);
    }

    public native double m00(); public native CvMoments m00(double m00);
    public native double m10(); public native CvMoments m10(double m10);
    public native double m01(); public native CvMoments m01(double m01);
    public native double m20(); public native CvMoments m20(double m20);
    public native double m11(); public native CvMoments m11(double m11);
    public native double m02(); public native CvMoments m02(double m02);
    public native double m30(); public native CvMoments m30(double m30);
    public native double m21(); public native CvMoments m21(double m21);
    public native double m12(); public native CvMoments m12(double m12);
    public native double m03(); public native CvMoments m03(double m03); /* spatial moments */
    public native double mu20(); public native CvMoments mu20(double mu20);
    public native double mu11(); public native CvMoments mu11(double mu11);
    public native double mu02(); public native CvMoments mu02(double mu02);
    public native double mu30(); public native CvMoments mu30(double mu30);
    public native double mu21(); public native CvMoments mu21(double mu21);
    public native double mu12(); public native CvMoments mu12(double mu12);
    public native double mu03(); public native CvMoments mu03(double mu03); /* central moments */
    public native double inv_sqrt_m00(); public native CvMoments inv_sqrt_m00(double inv_sqrt_m00); /* m00 != 0 ? 1/sqrt(m00) : 0 */
}

/* Hu invariants */
public static class CvHuMoments extends Pointer {
    static { Loader.load(); }
    public CvHuMoments() { allocate(); }
    public CvHuMoments(int size) { allocateArray(size); }
    public CvHuMoments(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvHuMoments position(int position) {
        return (CvHuMoments)super.position(position);
    }

    public native double hu1(); public native CvHuMoments hu1(double hu1);
    public native double hu2(); public native CvHuMoments hu2(double hu2);
    public native double hu3(); public native CvHuMoments hu3(double hu3);
    public native double hu4(); public native CvHuMoments hu4(double hu4);
    public native double hu5(); public native CvHuMoments hu5(double hu5);
    public native double hu6(); public native CvHuMoments hu6(double hu6);
    public native double hu7(); public native CvHuMoments hu7(double hu7); /* Hu invariants */
}

/* Template matching methods */
/** enum  */
public static final int
    CV_TM_SQDIFF        = 0,
    CV_TM_SQDIFF_NORMED = 1,
    CV_TM_CCORR         = 2,
    CV_TM_CCORR_NORMED  = 3,
    CV_TM_CCOEFF        = 4,
    CV_TM_CCOEFF_NORMED = 5;

public static class CvDistanceFunction extends FunctionPointer {
    static { Loader.load(); }
    public    CvDistanceFunction(Pointer p) { super(p); }
    protected CvDistanceFunction() { allocate(); }
    private native void allocate();
    public native float call( @Const FloatPointer a, @Const FloatPointer b, Pointer user_param );
}

/* Contour retrieval modes */
/** enum  */
public static final int
    CV_RETR_EXTERNAL= 0,
    CV_RETR_LIST= 1,
    CV_RETR_CCOMP= 2,
    CV_RETR_TREE= 3,
    CV_RETR_FLOODFILL= 4;

/* Contour approximation methods */
/** enum  */
public static final int
    CV_CHAIN_CODE= 0,
    CV_CHAIN_APPROX_NONE= 1,
    CV_CHAIN_APPROX_SIMPLE= 2,
    CV_CHAIN_APPROX_TC89_L1= 3,
    CV_CHAIN_APPROX_TC89_KCOS= 4,
    CV_LINK_RUNS= 5;

/*
Internal structure that is used for sequental retrieving contours from the image.
It supports both hierarchical and plane variants of Suzuki algorithm.
*/
@Opaque public static class CvContourScanner extends Pointer {
    public CvContourScanner() { }
    public CvContourScanner(Pointer p) { super(p); }
}

/* Freeman chain reader state */
public static class CvChainPtReader extends CvSeqReader {
    static { Loader.load(); }
    public CvChainPtReader() { allocate(); }
    public CvChainPtReader(int size) { allocateArray(size); }
    public CvChainPtReader(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvChainPtReader position(int position) {
        return (CvChainPtReader)super.position(position);
    }

    public native int header_size(); public native CvChainPtReader header_size(int header_size);                                       
    public native CvSeq seq(); public native CvChainPtReader seq(CvSeq seq);        /* sequence, beign read */             
    public native CvSeqBlock block(); public native CvChainPtReader block(CvSeqBlock block);      /* current block */                    
    public native @Cast("schar*") BytePointer ptr(); public native CvChainPtReader ptr(BytePointer ptr);        /* pointer to element be read next */  
    public native @Cast("schar*") BytePointer block_min(); public native CvChainPtReader block_min(BytePointer block_min);  /* pointer to the beginning of block */
    public native @Cast("schar*") BytePointer block_max(); public native CvChainPtReader block_max(BytePointer block_max);  /* pointer to the end of block */      
    public native int delta_index(); public native CvChainPtReader delta_index(int delta_index);/* = seq->first->start_index   */      
    public native @Cast("schar*") BytePointer prev_elem(); public native CvChainPtReader prev_elem(BytePointer prev_elem);  /* pointer to previous element */
    public native @Cast("char") byte code(); public native CvChainPtReader code(byte code);
    public native @ByVal CvPoint pt(); public native CvChainPtReader pt(CvPoint pt);
    public native @Cast("schar") byte deltas(int i, int j); public native CvChainPtReader deltas(int i, int j, byte deltas);
    @MemberGetter public native @Cast("schar(*)[2]") BytePointer deltas();
}

/* initializes 8-element array for fast access to 3x3 neighborhood of a pixel */
// #define  CV_INIT_3X3_DELTAS( deltas, step, nch )
//     ((deltas)[0] =  (nch),  (deltas)[1] = -(step) + (nch),
//      (deltas)[2] = -(step), (deltas)[3] = -(step) - (nch),
//      (deltas)[4] = -(nch),  (deltas)[5] =  (step) - (nch),
//      (deltas)[6] =  (step), (deltas)[7] =  (step) + (nch))


/****************************************************************************************\
*                              Planar subdivisions                                       *
\****************************************************************************************/

// #define CV_QUADEDGE2D_FIELDS()
//     int flags;
//     struct CvSubdiv2DPoint* pt[4];
//     CvSubdiv2DEdge  next[4];

// #define CV_SUBDIV2D_POINT_FIELDS()
//     int            flags;
//     CvSubdiv2DEdge first;
//     CvPoint2D32f   pt;
//     int id;

public static final int CV_SUBDIV2D_VIRTUAL_POINT_FLAG = (1 << 30);

public static class CvQuadEdge2D extends Pointer {
    static { Loader.load(); }
    public CvQuadEdge2D() { allocate(); }
    public CvQuadEdge2D(int size) { allocateArray(size); }
    public CvQuadEdge2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvQuadEdge2D position(int position) {
        return (CvQuadEdge2D)super.position(position);
    }

    public native int flags(); public native CvQuadEdge2D flags(int flags);                     
    public native CvSubdiv2DPoint pt(int i); public native CvQuadEdge2D pt(int i, CvSubdiv2DPoint pt);
    @MemberGetter public native @Cast("CvSubdiv2DPoint**") PointerPointer pt(); 
    public native @Cast("CvSubdiv2DEdge") long next(int i); public native CvQuadEdge2D next(int i, long next);
    @MemberGetter public native @Cast("CvSubdiv2DEdge*") SizeTPointer next();
}

public static class CvSubdiv2DPoint extends Pointer {
    static { Loader.load(); }
    public CvSubdiv2DPoint() { allocate(); }
    public CvSubdiv2DPoint(int size) { allocateArray(size); }
    public CvSubdiv2DPoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSubdiv2DPoint position(int position) {
        return (CvSubdiv2DPoint)super.position(position);
    }

    public native int flags(); public native CvSubdiv2DPoint flags(int flags);      
    public native @Cast("CvSubdiv2DEdge") long first(); public native CvSubdiv2DPoint first(long first);      
    public native @ByVal CvPoint2D32f pt(); public native CvSubdiv2DPoint pt(CvPoint2D32f pt);         
    public native int id(); public native CvSubdiv2DPoint id(int id);
}

// #define CV_SUBDIV2D_FIELDS()
//     CV_GRAPH_FIELDS()
//     int  quad_edges;
//     int  is_geometry_valid;
//     CvSubdiv2DEdge recent_edge;
//     CvPoint2D32f  topleft;
//     CvPoint2D32f  bottomright;

public static class CvSubdiv2D extends Pointer {
    static { Loader.load(); }
    public CvSubdiv2D() { allocate(); }
    public CvSubdiv2D(int size) { allocateArray(size); }
    public CvSubdiv2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSubdiv2D position(int position) {
        return (CvSubdiv2D)super.position(position);
    }

    public native int flags(); public native CvSubdiv2D flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvSubdiv2D header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvSubdiv2D h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvSubdiv2D h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvSubdiv2D v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvSubdiv2D v_next(CvSeq v_next);                                           
    public native int total(); public native CvSubdiv2D total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvSubdiv2D elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvSubdiv2D block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvSubdiv2D ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvSubdiv2D delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvSubdiv2D storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvSubdiv2D free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvSubdiv2D first(CvSeqBlock first);        /* Pointer to the first sequence block. */     
    public native CvSetElem free_elems(); public native CvSubdiv2D free_elems(CvSetElem free_elems);   
    public native int active_count(); public native CvSubdiv2D active_count(int active_count);          
    public native CvSet edges(); public native CvSubdiv2D edges(CvSet edges);           
    public native int quad_edges(); public native CvSubdiv2D quad_edges(int quad_edges);            
    public native int is_geometry_valid(); public native CvSubdiv2D is_geometry_valid(int is_geometry_valid);     
    public native @Cast("CvSubdiv2DEdge") long recent_edge(); public native CvSubdiv2D recent_edge(long recent_edge); 
    public native @ByVal CvPoint2D32f topleft(); public native CvSubdiv2D topleft(CvPoint2D32f topleft);      
    public native @ByVal CvPoint2D32f bottomright(); public native CvSubdiv2D bottomright(CvPoint2D32f bottomright);
}


/** enum CvSubdiv2DPointLocation */
public static final int
    CV_PTLOC_ERROR = -2,
    CV_PTLOC_OUTSIDE_RECT = -1,
    CV_PTLOC_INSIDE = 0,
    CV_PTLOC_VERTEX = 1,
    CV_PTLOC_ON_EDGE = 2;

/** enum CvNextEdgeType */
public static final int
    CV_NEXT_AROUND_ORG   =  0x00,
    CV_NEXT_AROUND_DST   =  0x22,
    CV_PREV_AROUND_ORG   =  0x11,
    CV_PREV_AROUND_DST   =  0x33,
    CV_NEXT_AROUND_LEFT  =  0x13,
    CV_NEXT_AROUND_RIGHT =  0x31,
    CV_PREV_AROUND_LEFT  =  0x20,
    CV_PREV_AROUND_RIGHT =  0x02;

/* get the next edge with the same origin point (counterwise) */
// #define  CV_SUBDIV2D_NEXT_EDGE( edge )  (((CvQuadEdge2D*)((edge) & ~3))->next[(edge)&3])


/* Contour approximation algorithms */
/** enum  */
public static final int
    CV_POLY_APPROX_DP = 0;

/* Shape matching methods */
/** enum  */
public static final int
    CV_CONTOURS_MATCH_I1  = 1,
    CV_CONTOURS_MATCH_I2  = 2,
    CV_CONTOURS_MATCH_I3  = 3;

/* Shape orientation */
/** enum  */
public static final int
    CV_CLOCKWISE         = 1,
    CV_COUNTER_CLOCKWISE = 2;


/* Convexity defect */
public static class CvConvexityDefect extends Pointer {
    static { Loader.load(); }
    public CvConvexityDefect() { allocate(); }
    public CvConvexityDefect(int size) { allocateArray(size); }
    public CvConvexityDefect(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvConvexityDefect position(int position) {
        return (CvConvexityDefect)super.position(position);
    }

    public native CvPoint start(); public native CvConvexityDefect start(CvPoint start); /* point of the contour where the defect begins */
    public native CvPoint end(); public native CvConvexityDefect end(CvPoint end); /* point of the contour where the defect ends */
    public native CvPoint depth_point(); public native CvConvexityDefect depth_point(CvPoint depth_point); /* the farthest from the convex hull point within the defect */
    public native float depth(); public native CvConvexityDefect depth(float depth); /* distance between the farthest point and the convex hull */
}


/* Histogram comparison methods */
/** enum  */
public static final int
    CV_COMP_CORREL        = 0,
    CV_COMP_CHISQR        = 1,
    CV_COMP_INTERSECT     = 2,
    CV_COMP_BHATTACHARYYA = 3,
    CV_COMP_HELLINGER     = CV_COMP_BHATTACHARYYA;

/* Mask size for distance transform */
/** enum  */
public static final int
    CV_DIST_MASK_3   = 3,
    CV_DIST_MASK_5   = 5,
    CV_DIST_MASK_PRECISE = 0;

/* Content of output label array: connected components or pixels */
/** enum  */
public static final int
  CV_DIST_LABEL_CCOMP = 0,
  CV_DIST_LABEL_PIXEL = 1;

/* Distance types for Distance Transform and M-estimators */
/** enum  */
public static final int
    CV_DIST_USER    = -1,  /* User defined distance */
    CV_DIST_L1      = 1,   /* distance = |x1-x2| + |y1-y2| */
    CV_DIST_L2      = 2,   /* the simple euclidean distance */
    CV_DIST_C       = 3,   /* distance = max(|x1-x2|,|y1-y2|) */
    CV_DIST_L12     = 4,   /* L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) */
    CV_DIST_FAIR    = 5,   /* distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 */
    CV_DIST_WELSCH  = 6,   /* distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 */
    CV_DIST_HUBER   = 7;    /* distance = |x|<c ? x^2/2 : c(|x|-c/2), c=1.345 */


/* Threshold types */
/** enum  */
public static final int
    CV_THRESH_BINARY      = 0,  /* value = value > threshold ? max_value : 0       */
    CV_THRESH_BINARY_INV  = 1,  /* value = value > threshold ? 0 : max_value       */
    CV_THRESH_TRUNC       = 2,  /* value = value > threshold ? threshold : value   */
    CV_THRESH_TOZERO      = 3,  /* value = value > threshold ? value : 0           */
    CV_THRESH_TOZERO_INV  = 4,  /* value = value > threshold ? 0 : value           */
    CV_THRESH_MASK        = 7,
    CV_THRESH_OTSU        = 8;  /* use Otsu algorithm to choose the optimal threshold value;
                                 combine the flag with one of the above CV_THRESH_* values */

/* Adaptive threshold methods */
/** enum  */
public static final int
    CV_ADAPTIVE_THRESH_MEAN_C  = 0,
    CV_ADAPTIVE_THRESH_GAUSSIAN_C  = 1;

/* FloodFill flags */
/** enum  */
public static final int
    CV_FLOODFILL_FIXED_RANGE = (1 << 16),
    CV_FLOODFILL_MASK_ONLY   = (1 << 17);


/* Canny edge detector flags */
/** enum  */
public static final int
    CV_CANNY_L2_GRADIENT  = (1 << 31);

/* Variants of a Hough transform */
/** enum  */
public static final int
    CV_HOUGH_STANDARD = 0,
    CV_HOUGH_PROBABILISTIC = 1,
    CV_HOUGH_MULTI_SCALE = 2,
    CV_HOUGH_GRADIENT = 3;


/* Fast search data structures  */
@Opaque public static class CvFeatureTree extends Pointer {
    public CvFeatureTree() { }
    public CvFeatureTree(Pointer p) { super(p); }
}
@Opaque public static class CvLSH extends Pointer {
    public CvLSH() { }
    public CvLSH(Pointer p) { super(p); }
}
@Opaque public static class CvLSHOperations extends Pointer {
    public CvLSHOperations() { }
    public CvLSHOperations(Pointer p) { super(p); }
}

// #ifdef __cplusplus
// #endif

// #endif


/* Wrapper for header file /usr/local/include/opencv2/imgproc/imgproc_c.h */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef __OPENCV_IMGPROC_IMGPROC_C_H__
// #define __OPENCV_IMGPROC_IMGPROC_C_H__

// #include "opencv2/core/core_c.h"
// #include "opencv2/imgproc/types_c.h"

// #ifdef __cplusplus
// #endif

/*********************** Background statistics accumulation *****************************/

/* Adds image to accumulator */
public static native void cvAcc( @Const CvArr image, CvArr sum,
                   @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Adds squared image to accumulator */
public static native void cvSquareAcc( @Const CvArr image, CvArr sqsum,
                         @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Adds a product of two images to accumulator */
public static native void cvMultiplyAcc( @Const CvArr image1, @Const CvArr image2, CvArr acc,
                           @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha */
public static native void cvRunningAvg( @Const CvArr image, CvArr acc, double alpha,
                          @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/****************************************************************************************\
*                                    Image Processing                                    *
\****************************************************************************************/

/* Copies source 2D array inside of the larger destination array and
   makes a border of the specified type (IPL_BORDER_*) around the copied area. */
public static native void cvCopyMakeBorder( @Const CvArr src, CvArr dst, @ByVal CvPoint offset,
                              int bordertype, @ByVal CvScalar value/*CV_DEFAULT(cvScalarAll(0))*/);

/* Smoothes array (removes noise) */
public static native void cvSmooth( @Const CvArr src, CvArr dst,
                      int smoothtype/*CV_DEFAULT(CV_GAUSSIAN)*/,
                      int size1/*CV_DEFAULT(3)*/,
                      int size2/*CV_DEFAULT(0)*/,
                      double sigma1/*CV_DEFAULT(0)*/,
                      double sigma2/*CV_DEFAULT(0)*/);

/* Convolves the image with the kernel */
public static native void cvFilter2D( @Const CvArr src, CvArr dst, @Const CvMat kernel,
                        @ByVal CvPoint anchor/*CV_DEFAULT(cvPoint(-1,-1))*/);

/* Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y) */
public static native void cvIntegral( @Const CvArr image, CvArr sum,
                       CvArr sqsum/*CV_DEFAULT(NULL)*/,
                       CvArr tilted_sum/*CV_DEFAULT(NULL)*/);

/*
   Smoothes the input image with gaussian kernel and then down-samples it.
   dst_width = floor(src_width/2)[+1],
   dst_height = floor(src_height/2)[+1]
*/
public static native void cvPyrDown( @Const CvArr src, CvArr dst,
                        int filter/*CV_DEFAULT(CV_GAUSSIAN_5x5)*/ );

/*
   Up-samples image and smoothes the result with gaussian kernel.
   dst_width = src_width*2,
   dst_height = src_height*2
*/
public static native void cvPyrUp( @Const CvArr src, CvArr dst,
                      int filter/*CV_DEFAULT(CV_GAUSSIAN_5x5)*/ );

/* Builds pyramid for an image */
public static native @Cast("CvMat**") PointerPointer cvCreatePyramid( @Const CvArr img, int extra_layers, double rate,
                                @Const CvSize layer_sizes/*CV_DEFAULT(0)*/,
                                CvArr bufarr/*CV_DEFAULT(0)*/,
                                int calc/*CV_DEFAULT(1)*/,
                                int filter/*CV_DEFAULT(CV_GAUSSIAN_5x5)*/ );

/* Releases pyramid */
public static native void cvReleasePyramid( @Cast("CvMat***") PointerPointer pyramid, int extra_layers );


/* Filters image using meanshift algorithm */
public static native void cvPyrMeanShiftFiltering( @Const CvArr src, CvArr dst,
    double sp, double sr, int max_level/*CV_DEFAULT(1)*/,
    @ByVal CvTermCriteria termcrit/*CV_DEFAULT(cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,5,1))*/);

/* Segments image using seed "markers" */
public static native void cvWatershed( @Const CvArr image, CvArr markers );

/* Calculates an image derivative using generalized Sobel
   (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.
   Scharr can be used only for the first dx or dy derivative */
public static native void cvSobel( @Const CvArr src, CvArr dst,
                    int xorder, int yorder,
                    int aperture_size/*CV_DEFAULT(3)*/);

/* Calculates the image Laplacian: (d2/dx + d2/dy)I */
public static native void cvLaplace( @Const CvArr src, CvArr dst,
                      int aperture_size/*CV_DEFAULT(3)*/ );

/* Converts input array pixels from one color space to another */
public static native void cvCvtColor( @Const CvArr src, CvArr dst, int code );


/* Resizes image (input array is resized to fit the destination array) */
public static native void cvResize( @Const CvArr src, CvArr dst,
                       int interpolation/*CV_DEFAULT( CV_INTER_LINEAR )*/);

/* Warps image with affine transform */
public static native void cvWarpAffine( @Const CvArr src, CvArr dst, @Const CvMat map_matrix,
                           int flags/*CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)*/,
                           @ByVal CvScalar fillval/*CV_DEFAULT(cvScalarAll(0))*/ );

/* Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2) */
public static native CvMat cvGetAffineTransform( @Const CvPoint2D32f src,
                                    @Const CvPoint2D32f dst,
                                    CvMat map_matrix );

/* Computes rotation_matrix matrix */
public static native CvMat cv2DRotationMatrix( @ByVal CvPoint2D32f center, double angle,
                                   double scale, CvMat map_matrix );

/* Warps image with perspective (projective) transform */
public static native void cvWarpPerspective( @Const CvArr src, CvArr dst, @Const CvMat map_matrix,
                                int flags/*CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)*/,
                                @ByVal CvScalar fillval/*CV_DEFAULT(cvScalarAll(0))*/ );

/* Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3) */
public static native CvMat cvGetPerspectiveTransform( @Const CvPoint2D32f src,
                                         @Const CvPoint2D32f dst,
                                         CvMat map_matrix );

/* Performs generic geometric transformation using the specified coordinate maps */
public static native void cvRemap( @Const CvArr src, CvArr dst,
                      @Const CvArr mapx, @Const CvArr mapy,
                      int flags/*CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)*/,
                      @ByVal CvScalar fillval/*CV_DEFAULT(cvScalarAll(0))*/ );

/* Converts mapx & mapy from floating-point to integer formats for cvRemap */
public static native void cvConvertMaps( @Const CvArr mapx, @Const CvArr mapy,
                            CvArr mapxy, CvArr mapalpha );

/* Performs forward or inverse log-polar image transform */
public static native void cvLogPolar( @Const CvArr src, CvArr dst,
                         @ByVal CvPoint2D32f center, double M,
                         int flags/*CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)*/);

/* Performs forward or inverse linear-polar image transform */
public static native void cvLinearPolar( @Const CvArr src, CvArr dst,
                         @ByVal CvPoint2D32f center, double maxRadius,
                         int flags/*CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)*/);

/* Transforms the input image to compensate lens distortion */
public static native void cvUndistort2( @Const CvArr src, CvArr dst,
                          @Const CvMat camera_matrix,
                          @Const CvMat distortion_coeffs,
                          @Const CvMat new_camera_matrix/*CV_DEFAULT(0)*/ );

/* Computes transformation map from intrinsic camera parameters
   that can used by cvRemap */
public static native void cvInitUndistortMap( @Const CvMat camera_matrix,
                                @Const CvMat distortion_coeffs,
                                CvArr mapx, CvArr mapy );

/* Computes undistortion+rectification map for a head of stereo camera */
public static native void cvInitUndistortRectifyMap( @Const CvMat camera_matrix,
                                       @Const CvMat dist_coeffs,
                                       @Const CvMat R, @Const CvMat new_camera_matrix,
                                       CvArr mapx, CvArr mapy );

/* Computes the original (undistorted) feature coordinates
   from the observed (distorted) coordinates */
public static native void cvUndistortPoints( @Const CvMat src, CvMat dst,
                               @Const CvMat camera_matrix,
                               @Const CvMat dist_coeffs,
                               @Const CvMat R/*CV_DEFAULT(0)*/,
                               @Const CvMat P/*CV_DEFAULT(0)*/);

/* creates structuring element used for morphological operations */
public static native IplConvKernel cvCreateStructuringElementEx(
            int cols, int rows, int anchor_x, int anchor_y,
            int shape, IntPointer values/*CV_DEFAULT(NULL)*/ );
public static native IplConvKernel cvCreateStructuringElementEx(
            int cols, int rows, int anchor_x, int anchor_y,
            int shape, IntBuffer values/*CV_DEFAULT(NULL)*/ );
public static native IplConvKernel cvCreateStructuringElementEx(
            int cols, int rows, int anchor_x, int anchor_y,
            int shape, int[] values/*CV_DEFAULT(NULL)*/ );

/* releases structuring element */
public static native void cvReleaseStructuringElement( @Cast("IplConvKernel**") PointerPointer element );
public static native void cvReleaseStructuringElement( @ByPtrPtr IplConvKernel element );

/* erodes input image (applies minimum filter) one or more times.
   If element pointer is NULL, 3x3 rectangular element is used */
public static native void cvErode( @Const CvArr src, CvArr dst,
                      IplConvKernel element/*CV_DEFAULT(NULL)*/,
                      int iterations/*CV_DEFAULT(1)*/ );

/* dilates input image (applies maximum filter) one or more times.
   If element pointer is NULL, 3x3 rectangular element is used */
public static native void cvDilate( @Const CvArr src, CvArr dst,
                       IplConvKernel element/*CV_DEFAULT(NULL)*/,
                       int iterations/*CV_DEFAULT(1)*/ );

/* Performs complex morphological transformation */
public static native void cvMorphologyEx( @Const CvArr src, CvArr dst,
                             CvArr temp, IplConvKernel element,
                             int operation, int iterations/*CV_DEFAULT(1)*/ );

/* Calculates all spatial and central moments up to the 3rd order */
public static native void cvMoments( @Const CvArr arr, CvMoments moments, int binary/*CV_DEFAULT(0)*/);

/* Retrieve particular spatial, central or normalized central moments */
public static native double cvGetSpatialMoment( CvMoments moments, int x_order, int y_order );
public static native double cvGetCentralMoment( CvMoments moments, int x_order, int y_order );
public static native double cvGetNormalizedCentralMoment( CvMoments moments,
                                             int x_order, int y_order );

/* Calculates 7 Hu's invariants from precalculated spatial and central moments */
public static native void cvGetHuMoments( CvMoments moments, CvHuMoments hu_moments );

/*********************************** data sampling **************************************/

/* Fetches pixels that belong to the specified line segment and stores them to the buffer.
   Returns the number of retrieved points. */
public static native int cvSampleLine( @Const CvArr image, @ByVal CvPoint pt1, @ByVal CvPoint pt2, Pointer buffer,
                          int connectivity/*CV_DEFAULT(8)*/);

/* Retrieves the rectangular image region with specified center from the input array.
 dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).
 Values of pixels with fractional coordinates are retrieved using bilinear interpolation*/
public static native void cvGetRectSubPix( @Const CvArr src, CvArr dst, @ByVal CvPoint2D32f center );


/* Retrieves quadrangle from the input array.
    matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)
                ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels
                                     with fractional coordinates)
*/
public static native void cvGetQuadrangleSubPix( @Const CvArr src, CvArr dst,
                                    @Const CvMat map_matrix );

/* Measures similarity between template and overlapped windows in the source image
   and fills the resultant image with the measurements */
public static native void cvMatchTemplate( @Const CvArr image, @Const CvArr templ,
                              CvArr result, int method );

/* Computes earth mover distance between
   two weighted point sets (called signatures) */
public static native float cvCalcEMD2( @Const CvArr signature1,
                          @Const CvArr signature2,
                          int distance_type,
                          CvDistanceFunction distance_func/*CV_DEFAULT(NULL)*/,
                          @Const CvArr cost_matrix/*CV_DEFAULT(NULL)*/,
                          CvArr flow/*CV_DEFAULT(NULL)*/,
                          FloatPointer lower_bound/*CV_DEFAULT(NULL)*/,
                          Pointer userdata/*CV_DEFAULT(NULL)*/);
public static native float cvCalcEMD2( @Const CvArr signature1,
                          @Const CvArr signature2,
                          int distance_type,
                          CvDistanceFunction distance_func/*CV_DEFAULT(NULL)*/,
                          @Const CvArr cost_matrix/*CV_DEFAULT(NULL)*/,
                          CvArr flow/*CV_DEFAULT(NULL)*/,
                          FloatBuffer lower_bound/*CV_DEFAULT(NULL)*/,
                          Pointer userdata/*CV_DEFAULT(NULL)*/);
public static native float cvCalcEMD2( @Const CvArr signature1,
                          @Const CvArr signature2,
                          int distance_type,
                          CvDistanceFunction distance_func/*CV_DEFAULT(NULL)*/,
                          @Const CvArr cost_matrix/*CV_DEFAULT(NULL)*/,
                          CvArr flow/*CV_DEFAULT(NULL)*/,
                          float[] lower_bound/*CV_DEFAULT(NULL)*/,
                          Pointer userdata/*CV_DEFAULT(NULL)*/);

/****************************************************************************************\
*                              Contours retrieving                                       *
\****************************************************************************************/

/* Retrieves outer and optionally inner boundaries of white (non-zero) connected
   components in the black (zero) background */
public static native int cvFindContours( CvArr image, CvMemStorage storage, @Cast("CvSeq**") PointerPointer first_contour,
                            int header_size/*CV_DEFAULT(sizeof(CvContour))*/,
                            int mode/*CV_DEFAULT(CV_RETR_LIST)*/,
                            int method/*CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)*/,
                            @ByVal CvPoint offset/*CV_DEFAULT(cvPoint(0,0))*/);
public static native int cvFindContours( CvArr image, CvMemStorage storage, @ByPtrPtr CvSeq first_contour,
                            int header_size/*CV_DEFAULT(sizeof(CvContour))*/,
                            int mode/*CV_DEFAULT(CV_RETR_LIST)*/,
                            int method/*CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)*/,
                            @ByVal CvPoint offset/*CV_DEFAULT(cvPoint(0,0))*/);

/* Initalizes contour retrieving process.
   Calls cvStartFindContours.
   Calls cvFindNextContour until null pointer is returned
   or some other condition becomes true.
   Calls cvEndFindContours at the end. */
public static native @ByVal CvContourScanner cvStartFindContours( CvArr image, CvMemStorage storage,
                            int header_size/*CV_DEFAULT(sizeof(CvContour))*/,
                            int mode/*CV_DEFAULT(CV_RETR_LIST)*/,
                            int method/*CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)*/,
                            @ByVal CvPoint offset/*CV_DEFAULT(cvPoint(0,0))*/);

/* Retrieves next contour */
public static native CvSeq cvFindNextContour( @ByVal CvContourScanner scanner );


/* Substitutes the last retrieved contour with the new one
   (if the substitutor is null, the last retrieved contour is removed from the tree) */
public static native void cvSubstituteContour( @ByVal CvContourScanner scanner, CvSeq new_contour );


/* Releases contour scanner and returns pointer to the first outer contour */
public static native CvSeq cvEndFindContours( CvContourScanner scanner );

/* Approximates a single Freeman chain or a tree of chains to polygonal curves */
public static native CvSeq cvApproxChains( CvSeq src_seq, CvMemStorage storage,
                            int method/*CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)*/,
                            double parameter/*CV_DEFAULT(0)*/,
                            int minimal_perimeter/*CV_DEFAULT(0)*/,
                            int recursive/*CV_DEFAULT(0)*/);

/* Initalizes Freeman chain reader.
   The reader is used to iteratively get coordinates of all the chain points.
   If the Freeman codes should be read as is, a simple sequence reader should be used */
public static native void cvStartReadChainPoints( CvChain chain, CvChainPtReader reader );

/* Retrieves the next chain point */
public static native @ByVal CvPoint cvReadChainPoint( CvChainPtReader reader );


/****************************************************************************************\
*                            Contour Processing and Shape Analysis                       *
\****************************************************************************************/

/* Approximates a single polygonal curve (contour) or
   a tree of polygonal curves (contours) */
public static native CvSeq cvApproxPoly( @Const Pointer src_seq,
                             int header_size, CvMemStorage storage,
                             int method, double eps,
                             int recursive/*CV_DEFAULT(0)*/);

/* Calculates perimeter of a contour or length of a part of contour */
public static native double cvArcLength( @Const Pointer curve,
                            @ByVal CvSlice slice/*CV_DEFAULT(CV_WHOLE_SEQ)*/,
                            int is_closed/*CV_DEFAULT(-1)*/);

public static native double cvContourPerimeter( @Const Pointer contour );


/* Calculates contour boundning rectangle (update=1) or
   just retrieves pre-calculated rectangle (update=0) */
public static native @ByVal CvRect cvBoundingRect( CvArr points, int update/*CV_DEFAULT(0)*/ );

/* Calculates area of a contour or contour segment */
public static native double cvContourArea( @Const CvArr contour,
                              @ByVal CvSlice slice/*CV_DEFAULT(CV_WHOLE_SEQ)*/,
                              int oriented/*CV_DEFAULT(0)*/);

/* Finds minimum area rotated rectangle bounding a set of points */
public static native @ByVal CvBox2D cvMinAreaRect2( @Const CvArr points,
                                CvMemStorage storage/*CV_DEFAULT(NULL)*/);

/* Finds minimum enclosing circle for a set of points */
public static native int cvMinEnclosingCircle( @Const CvArr points,
                                  CvPoint2D32f center, FloatPointer radius );
public static native int cvMinEnclosingCircle( @Const CvArr points,
                                  CvPoint2D32f center, FloatBuffer radius );
public static native int cvMinEnclosingCircle( @Const CvArr points,
                                  CvPoint2D32f center, float[] radius );

/* Compares two contours by matching their moments */
public static native double cvMatchShapes( @Const Pointer object1, @Const Pointer object2,
                              int method, double parameter/*CV_DEFAULT(0)*/);

/* Calculates exact convex hull of 2d point set */
public static native CvSeq cvConvexHull2( @Const CvArr input,
                             Pointer hull_storage/*CV_DEFAULT(NULL)*/,
                             int orientation/*CV_DEFAULT(CV_CLOCKWISE)*/,
                             int return_points/*CV_DEFAULT(0)*/);

/* Checks whether the contour is convex or not (returns 1 if convex, 0 if not) */
public static native int cvCheckContourConvexity( @Const CvArr contour );


/* Finds convexity defects for the contour */
public static native CvSeq cvConvexityDefects( @Const CvArr contour, @Const CvArr convexhull,
                                   CvMemStorage storage/*CV_DEFAULT(NULL)*/);

/* Fits ellipse into a set of 2d points */
public static native @ByVal CvBox2D cvFitEllipse2( @Const CvArr points );

/* Finds minimum rectangle containing two given rectangles */
public static native @ByVal CvRect cvMaxRect( @Const CvRect rect1, @Const CvRect rect2 );

/* Finds coordinates of the box vertices */
public static native void cvBoxPoints( @ByVal CvBox2D box, CvPoint2D32f pt );

/* Initializes sequence header for a matrix (column or row vector) of points -
   a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!) */
public static native CvSeq cvPointSeqFromMat( int seq_kind, @Const CvArr mat,
                                 CvContour contour_header,
                                 CvSeqBlock block );

/* Checks whether the point is inside polygon, outside, on an edge (at a vertex).
   Returns positive, negative or zero value, correspondingly.
   Optionally, measures a signed distance between
   the point and the nearest polygon edge (measure_dist=1) */
public static native double cvPointPolygonTest( @Const CvArr contour,
                                  @ByVal CvPoint2D32f pt, int measure_dist );

/****************************************************************************************\
*                                  Histogram functions                                   *
\****************************************************************************************/

/* Creates new histogram */
public static native CvHistogram cvCreateHist( int dims, IntPointer sizes, int type,
                                   @Cast("float**") PointerPointer ranges/*CV_DEFAULT(NULL)*/,
                                   int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvCreateHist( int dims, IntPointer sizes, int type,
                                   @ByPtrPtr FloatPointer ranges/*CV_DEFAULT(NULL)*/,
                                   int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvCreateHist( int dims, IntBuffer sizes, int type,
                                   @ByPtrPtr FloatBuffer ranges/*CV_DEFAULT(NULL)*/,
                                   int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvCreateHist( int dims, int[] sizes, int type,
                                   @ByPtrPtr float[] ranges/*CV_DEFAULT(NULL)*/,
                                   int uniform/*CV_DEFAULT(1)*/);

/* Assignes histogram bin ranges */
public static native void cvSetHistBinRanges( CvHistogram hist, @Cast("float**") PointerPointer ranges,
                                int uniform/*CV_DEFAULT(1)*/);
public static native void cvSetHistBinRanges( CvHistogram hist, @ByPtrPtr FloatPointer ranges,
                                int uniform/*CV_DEFAULT(1)*/);
public static native void cvSetHistBinRanges( CvHistogram hist, @ByPtrPtr FloatBuffer ranges,
                                int uniform/*CV_DEFAULT(1)*/);
public static native void cvSetHistBinRanges( CvHistogram hist, @ByPtrPtr float[] ranges,
                                int uniform/*CV_DEFAULT(1)*/);

/* Creates histogram header for array */
public static native CvHistogram cvMakeHistHeaderForArray(
                            int dims, IntPointer sizes, CvHistogram hist,
                            FloatPointer data, @Cast("float**") PointerPointer ranges/*CV_DEFAULT(NULL)*/,
                            int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvMakeHistHeaderForArray(
                            int dims, IntPointer sizes, CvHistogram hist,
                            FloatPointer data, @ByPtrPtr FloatPointer ranges/*CV_DEFAULT(NULL)*/,
                            int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvMakeHistHeaderForArray(
                            int dims, IntBuffer sizes, CvHistogram hist,
                            FloatBuffer data, @ByPtrPtr FloatBuffer ranges/*CV_DEFAULT(NULL)*/,
                            int uniform/*CV_DEFAULT(1)*/);
public static native CvHistogram cvMakeHistHeaderForArray(
                            int dims, int[] sizes, CvHistogram hist,
                            float[] data, @ByPtrPtr float[] ranges/*CV_DEFAULT(NULL)*/,
                            int uniform/*CV_DEFAULT(1)*/);

/* Releases histogram */
public static native void cvReleaseHist( @Cast("CvHistogram**") PointerPointer hist );
public static native void cvReleaseHist( @ByPtrPtr CvHistogram hist );

/* Clears all the histogram bins */
public static native void cvClearHist( CvHistogram hist );

/* Finds indices and values of minimum and maximum histogram bins */
public static native void cvGetMinMaxHistValue( @Const CvHistogram hist,
                                   FloatPointer min_value, FloatPointer max_value,
                                   IntPointer min_idx/*CV_DEFAULT(NULL)*/,
                                   IntPointer max_idx/*CV_DEFAULT(NULL)*/);
public static native void cvGetMinMaxHistValue( @Const CvHistogram hist,
                                   FloatBuffer min_value, FloatBuffer max_value,
                                   IntBuffer min_idx/*CV_DEFAULT(NULL)*/,
                                   IntBuffer max_idx/*CV_DEFAULT(NULL)*/);
public static native void cvGetMinMaxHistValue( @Const CvHistogram hist,
                                   float[] min_value, float[] max_value,
                                   int[] min_idx/*CV_DEFAULT(NULL)*/,
                                   int[] max_idx/*CV_DEFAULT(NULL)*/);


/* Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.
   After that sum of histogram bins is equal to <factor> */
public static native void cvNormalizeHist( CvHistogram hist, double factor );


/* Clear all histogram bins that are below the threshold */
public static native void cvThreshHist( CvHistogram hist, double threshold );


/* Compares two histogram */
public static native double cvCompareHist( @Const CvHistogram hist1,
                              @Const CvHistogram hist2,
                              int method);

/* Copies one histogram to another. Destination histogram is created if
   the destination pointer is NULL */
public static native void cvCopyHist( @Const CvHistogram src, @Cast("CvHistogram**") PointerPointer dst );
public static native void cvCopyHist( @Const CvHistogram src, @ByPtrPtr CvHistogram dst );


/* Calculates bayesian probabilistic histograms
   (each or src and dst is an array of <number> histograms */
public static native void cvCalcBayesianProb( @Cast("CvHistogram**") PointerPointer src, int number,
                                @Cast("CvHistogram**") PointerPointer dst);
public static native void cvCalcBayesianProb( @ByPtrPtr CvHistogram src, int number,
                                @ByPtrPtr CvHistogram dst);

/* Calculates array histogram */
public static native void cvCalcArrHist( @Cast("CvArr**") PointerPointer arr, CvHistogram hist,
                            int accumulate/*CV_DEFAULT(0)*/,
                            @Const CvArr mask/*CV_DEFAULT(NULL)*/ );
public static native void cvCalcArrHist( @ByPtrPtr CvArr arr, CvHistogram hist,
                            int accumulate/*CV_DEFAULT(0)*/,
                            @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

public static native void cvCalcHist( @Cast("IplImage**") PointerPointer image, CvHistogram hist,
                             int accumulate/*CV_DEFAULT(0)*/,
                             @Const CvArr mask/*CV_DEFAULT(NULL)*/ );
public static native void cvCalcHist( @ByPtrPtr IplImage image, CvHistogram hist,
                             int accumulate/*CV_DEFAULT(0)*/,
                             @Const CvArr mask/*CV_DEFAULT(NULL)*/ );

/* Calculates back project */
public static native void cvCalcArrBackProject( @Cast("CvArr**") PointerPointer image, CvArr dst,
                                   @Const CvHistogram hist );
public static native void cvCalcArrBackProject( @ByPtrPtr CvArr image, CvArr dst,
                                   @Const CvHistogram hist );
// #define  cvCalcBackProject(image, dst, hist) cvCalcArrBackProject((CvArr**)image, dst, hist)


/* Does some sort of template matching but compares histograms of
   template and each window location */
public static native void cvCalcArrBackProjectPatch( @Cast("CvArr**") PointerPointer image, CvArr dst, @ByVal CvSize range,
                                        CvHistogram hist, int method,
                                        double factor );
public static native void cvCalcArrBackProjectPatch( @ByPtrPtr CvArr image, CvArr dst, @ByVal CvSize range,
                                        CvHistogram hist, int method,
                                        double factor );
// #define  cvCalcBackProjectPatch( image, dst, range, hist, method, factor )
//      cvCalcArrBackProjectPatch( (CvArr**)image, dst, range, hist, method, factor )


/* calculates probabilistic density (divides one histogram by another) */
public static native void cvCalcProbDensity( @Const CvHistogram hist1, @Const CvHistogram hist2,
                                CvHistogram dst_hist, double scale/*CV_DEFAULT(255)*/ );

/* equalizes histogram of 8-bit single-channel image */
public static native void cvEqualizeHist( @Const CvArr src, CvArr dst );


/* Applies distance transform to binary image */
public static native void cvDistTransform( @Const CvArr src, CvArr dst,
                              int distance_type/*CV_DEFAULT(CV_DIST_L2)*/,
                              int mask_size/*CV_DEFAULT(3)*/,
                              @Const FloatPointer mask/*CV_DEFAULT(NULL)*/,
                              CvArr labels/*CV_DEFAULT(NULL)*/,
                              int labelType/*CV_DEFAULT(CV_DIST_LABEL_CCOMP)*/);
public static native void cvDistTransform( @Const CvArr src, CvArr dst,
                              int distance_type/*CV_DEFAULT(CV_DIST_L2)*/,
                              int mask_size/*CV_DEFAULT(3)*/,
                              @Const FloatBuffer mask/*CV_DEFAULT(NULL)*/,
                              CvArr labels/*CV_DEFAULT(NULL)*/,
                              int labelType/*CV_DEFAULT(CV_DIST_LABEL_CCOMP)*/);
public static native void cvDistTransform( @Const CvArr src, CvArr dst,
                              int distance_type/*CV_DEFAULT(CV_DIST_L2)*/,
                              int mask_size/*CV_DEFAULT(3)*/,
                              @Const float[] mask/*CV_DEFAULT(NULL)*/,
                              CvArr labels/*CV_DEFAULT(NULL)*/,
                              int labelType/*CV_DEFAULT(CV_DIST_LABEL_CCOMP)*/);


/* Applies fixed-level threshold to grayscale image.
   This is a basic operation applied before retrieving contours */
public static native double cvThreshold( @Const CvArr src, CvArr dst,
                            double threshold, double max_value,
                            int threshold_type );

/* Applies adaptive threshold to grayscale image.
   The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and
   CV_ADAPTIVE_THRESH_GAUSSIAN_C are:
   neighborhood size (3, 5, 7 etc.),
   and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...) */
public static native void cvAdaptiveThreshold( @Const CvArr src, CvArr dst, double max_value,
                                  int adaptive_method/*CV_DEFAULT(CV_ADAPTIVE_THRESH_MEAN_C)*/,
                                  int threshold_type/*CV_DEFAULT(CV_THRESH_BINARY)*/,
                                  int block_size/*CV_DEFAULT(3)*/,
                                  double param1/*CV_DEFAULT(5)*/);

/* Fills the connected component until the color difference gets large enough */
public static native void cvFloodFill( CvArr image, @ByVal CvPoint seed_point,
                          @ByVal CvScalar new_val, @ByVal CvScalar lo_diff/*CV_DEFAULT(cvScalarAll(0))*/,
                          @ByVal CvScalar up_diff/*CV_DEFAULT(cvScalarAll(0))*/,
                          CvConnectedComp comp/*CV_DEFAULT(NULL)*/,
                          int flags/*CV_DEFAULT(4)*/,
                          CvArr mask/*CV_DEFAULT(NULL)*/);

/****************************************************************************************\
*                                  Feature detection                                     *
\****************************************************************************************/

/* Runs canny edge detector */
public static native void cvCanny( @Const CvArr image, CvArr edges, double threshold1,
                      double threshold2, int aperture_size/*CV_DEFAULT(3)*/ );

/* Calculates constraint image for corner detection
   Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.
   Applying threshold to the result gives coordinates of corners */
public static native void cvPreCornerDetect( @Const CvArr image, CvArr corners,
                               int aperture_size/*CV_DEFAULT(3)*/ );

/* Calculates eigen values and vectors of 2x2
   gradient covariation matrix at every image pixel */
public static native void cvCornerEigenValsAndVecs( @Const CvArr image, CvArr eigenvv,
                                       int block_size, int aperture_size/*CV_DEFAULT(3)*/ );

/* Calculates minimal eigenvalue for 2x2 gradient covariation matrix at
   every image pixel */
public static native void cvCornerMinEigenVal( @Const CvArr image, CvArr eigenval,
                                  int block_size, int aperture_size/*CV_DEFAULT(3)*/ );

/* Harris corner detector:
   Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel */
public static native void cvCornerHarris( @Const CvArr image, CvArr harris_responce,
                             int block_size, int aperture_size/*CV_DEFAULT(3)*/,
                             double k/*CV_DEFAULT(0.04)*/ );

/* Adjust corner position using some sort of gradient search */
public static native void cvFindCornerSubPix( @Const CvArr image, CvPoint2D32f corners,
                                 int count, @ByVal CvSize win, @ByVal CvSize zero_zone,
                                 @ByVal CvTermCriteria criteria );

/* Finds a sparse set of points within the selected region
   that seem to be easy to track */
public static native void cvGoodFeaturesToTrack( @Const CvArr image, CvArr eig_image,
                                    CvArr temp_image, CvPoint2D32f corners,
                                    IntPointer corner_count, double quality_level,
                                    double min_distance,
                                    @Const CvArr mask/*CV_DEFAULT(NULL)*/,
                                    int block_size/*CV_DEFAULT(3)*/,
                                    int use_harris/*CV_DEFAULT(0)*/,
                                    double k/*CV_DEFAULT(0.04)*/ );
public static native void cvGoodFeaturesToTrack( @Const CvArr image, CvArr eig_image,
                                    CvArr temp_image, CvPoint2D32f corners,
                                    IntBuffer corner_count, double quality_level,
                                    double min_distance,
                                    @Const CvArr mask/*CV_DEFAULT(NULL)*/,
                                    int block_size/*CV_DEFAULT(3)*/,
                                    int use_harris/*CV_DEFAULT(0)*/,
                                    double k/*CV_DEFAULT(0.04)*/ );
public static native void cvGoodFeaturesToTrack( @Const CvArr image, CvArr eig_image,
                                    CvArr temp_image, CvPoint2D32f corners,
                                    int[] corner_count, double quality_level,
                                    double min_distance,
                                    @Const CvArr mask/*CV_DEFAULT(NULL)*/,
                                    int block_size/*CV_DEFAULT(3)*/,
                                    int use_harris/*CV_DEFAULT(0)*/,
                                    double k/*CV_DEFAULT(0.04)*/ );

/* Finds lines on binary image using one of several methods.
   line_storage is either memory storage or 1 x <max number of lines> CvMat, its
   number of columns is changed by the function.
   method is one of CV_HOUGH_*;
   rho, theta and threshold are used for each of those methods;
   param1 ~ line length, param2 ~ line gap - for probabilistic,
   param1 ~ srn, param2 ~ stn - for multi-scale */
public static native CvSeq cvHoughLines2( CvArr image, Pointer line_storage, int method,
                              double rho, double theta, int threshold,
                              double param1/*CV_DEFAULT(0)*/, double param2/*CV_DEFAULT(0)*/);

/* Finds circles in the image */
public static native CvSeq cvHoughCircles( CvArr image, Pointer circle_storage,
                              int method, double dp, double min_dist,
                              double param1/*CV_DEFAULT(100)*/,
                              double param2/*CV_DEFAULT(100)*/,
                              int min_radius/*CV_DEFAULT(0)*/,
                              int max_radius/*CV_DEFAULT(0)*/);

/* Fits a line into set of 2d or 3d points in a robust way (M-estimator technique) */
public static native void cvFitLine( @Const CvArr points, int dist_type, double param,
                        double reps, double aeps, FloatPointer line );
public static native void cvFitLine( @Const CvArr points, int dist_type, double param,
                        double reps, double aeps, FloatBuffer line );
public static native void cvFitLine( @Const CvArr points, int dist_type, double param,
                        double reps, double aeps, float[] line );

// #ifdef __cplusplus
// #endif

// #endif


}
