/* DO NOT EDIT THIS FILE - IT IS MACHINE GENERATED */

package com.googlecode.javacpp;

import com.googlecode.javacpp.*;
import com.googlecode.javacpp.annotation.*;
import java.nio.*;

import static com.googlecode.javacpp.opencv_core.*;
import static com.googlecode.javacpp.opencv_imgproc.*;
import static com.googlecode.javacpp.opencv_highgui.*;
import static com.googlecode.javacpp.opencv_calib3d.*;
import static com.googlecode.javacpp.opencv_video.*;

public class opencv_legacy extends com.googlecode.javacpp.presets.opencv_legacy {
    static { Loader.load(); }

/* Wrapper for header file /usr/local/include/opencv2/legacy/compat.hpp */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                        Intel License Agreement
//                For Open Source Computer Vision Library
//
// Copyright( C) 2000, Intel Corporation, all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of Intel Corporation may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
//(including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort(including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
   A few macros and definitions for backward compatibility
   with the previous versions of OpenCV. They are obsolete and
   are likely to be removed in future. To check whether your code
   uses any of these, define CV_NO_BACKWARD_COMPATIBILITY before
   including cv.h.
*/

// #ifndef __OPENCV_COMPAT_HPP__
// #define __OPENCV_COMPAT_HPP__

// #include "opencv2/core/core_c.h"
// #include "opencv2/imgproc/types_c.h"

// #include <math.h>
// #include <string.h>

// #ifdef __cplusplus
// #endif

/** enum  */
public static final int
    CV_MAT32F      =  CV_32FC1,
    CV_MAT3x1_32F  =  CV_32FC1,
    CV_MAT4x1_32F  =  CV_32FC1,
    CV_MAT3x3_32F  =  CV_32FC1,
    CV_MAT4x4_32F  =  CV_32FC1,

    CV_MAT64D      =  CV_64FC1,
    CV_MAT3x1_64D  =  CV_64FC1,
    CV_MAT4x1_64D  =  CV_64FC1,
    CV_MAT3x3_64D  =  CV_64FC1,
    CV_MAT4x4_64D  =  CV_64FC1;

/** enum  */
public static final int
    IPL_GAUSSIAN_5x5 = 7;

/* allocation/deallocation macros */
public static native void cvCreateImageData(CvArr arg1);
public static native void cvReleaseImageData(CvArr arg1);
public static native void cvSetImageData(CvArr arg1, Pointer arg2, int arg3);
public static native void cvGetImageRawData(CvArr arg1, @Cast("uchar**") PointerPointer arg2, IntPointer arg3, CvSize arg4);
public static native void cvGetImageRawData(CvArr arg1, @Cast("uchar**") @ByPtrPtr BytePointer arg2, IntPointer arg3, CvSize arg4);
public static native void cvGetImageRawData(CvArr arg1, @Cast("uchar**") @ByPtrPtr ByteBuffer arg2, IntBuffer arg3, CvSize arg4);
public static native void cvGetImageRawData(CvArr arg1, @Cast("uchar**") @ByPtrPtr byte[] arg2, int[] arg3, CvSize arg4);

public static native void cvmAlloc(CvArr arg1);
public static native void cvmFree(CvArr arg1);
public static native void cvmAllocArray(CvArr arg1);
public static native void cvmFreeArray(CvArr arg1);

public static native void cvIntegralImage(CvArr arg1, CvArr arg2, CvArr arg3, CvArr arg4);
public static native double cvMatchContours(Pointer arg1, Pointer arg2, int arg3, double arg4);

public static native @ByVal CvMat cvMatArray( int rows, int cols, int type,
                            int count, Pointer data/*CV_DEFAULT(0)*/);

public static native void cvUpdateMHIByTime(CvArr arg1, CvArr arg2, double arg3, double arg4);

public static native void cvAccMask(CvArr arg1, CvArr arg2, CvArr arg3);
public static native void cvSquareAccMask(CvArr arg1, CvArr arg2, CvArr arg3);
public static native void cvMultiplyAccMask(CvArr arg1, CvArr arg2, CvArr arg3, CvArr arg4);
public static native void cvRunningAvgMask(CvArr imgY, CvArr imgU, CvArr mask, double alpha);

public static native void cvSetHistThresh(CvHistogram arg1, @Cast("float**") PointerPointer arg2, int arg3);
public static native void cvSetHistThresh(CvHistogram arg1, @ByPtrPtr FloatPointer arg2, int arg3);
public static native void cvSetHistThresh(CvHistogram arg1, @ByPtrPtr FloatBuffer arg2, int arg3);
public static native void cvSetHistThresh(CvHistogram arg1, @ByPtrPtr float[] arg2, int arg3);
public static native void cvCalcHistMask(@Cast("IplImage**") PointerPointer img, CvArr mask, CvHistogram hist, int doNotClear);
public static native void cvCalcHistMask(@ByPtrPtr IplImage img, CvArr mask, CvHistogram hist, int doNotClear);

public static native double cvMean( @Const CvArr image, @Const CvArr mask/*CV_DEFAULT(0)*/);
public static native double cvSumPixels( @Const CvArr image );
public static native void cvMean_StdDev( @Const CvArr image, DoublePointer mean, DoublePointer sdv,
                                @Const CvArr mask/*CV_DEFAULT(0)*/);
public static native void cvMean_StdDev( @Const CvArr image, DoubleBuffer mean, DoubleBuffer sdv,
                                @Const CvArr mask/*CV_DEFAULT(0)*/);
public static native void cvMean_StdDev( @Const CvArr image, double[] mean, double[] sdv,
                                @Const CvArr mask/*CV_DEFAULT(0)*/);

public static native void cvmPerspectiveProject( @Const CvMat mat, @Const CvArr src, CvArr dst );
public static native void cvFillImage( CvArr mat, double color );

public static native void cvCvtPixToPlane(CvArr arg1, CvArr arg2, CvArr arg3, CvArr arg4, CvArr arg5);
public static native void cvCvtPlaneToPix(CvArr arg1, CvArr arg2, CvArr arg3, CvArr arg4, CvArr arg5);

public static class CvRandState extends Pointer {
    static { Loader.load(); }
    public CvRandState() { allocate(); }
    public CvRandState(int size) { allocateArray(size); }
    public CvRandState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvRandState position(int position) {
        return (CvRandState)super.position(position);
    }

    public native @Cast("CvRNG") int state(); public native CvRandState state(int state);    /* RNG state (the current seed and carry)*/
    public native int disttype(); public native CvRandState disttype(int disttype); /* distribution type */
    public native @ByVal CvScalar param(int i); public native CvRandState param(int i, CvScalar param);
    @MemberGetter public native CvScalar param(); /* parameters of RNG */
}

/* Changes RNG range while preserving RNG state */
public static native void cvRandSetRange( CvRandState state, double param1,
                                 double param2, int index/*CV_DEFAULT(-1)*/);

public static native void cvRandInit( CvRandState state, double param1,
                             double param2, int seed,
                             int disttype/*CV_DEFAULT(CV_RAND_UNI)*/);

/* Fills array with random numbers */
public static native void cvRand( CvRandState state, CvArr arr );

// #define cvRandNext( _state ) cvRandInt( &(_state)->state )

public static native void cvbRand( CvRandState state, FloatPointer dst, int len );
public static native void cvbRand( CvRandState state, FloatBuffer dst, int len );
public static native void cvbRand( CvRandState state, float[] dst, int len );

public static native void cvbCartToPolar( @Const FloatPointer y, @Const FloatPointer x,
                                 FloatPointer magnitude, FloatPointer angle, int len );
public static native void cvbCartToPolar( @Const FloatBuffer y, @Const FloatBuffer x,
                                 FloatBuffer magnitude, FloatBuffer angle, int len );
public static native void cvbCartToPolar( @Const float[] y, @Const float[] x,
                                 float[] magnitude, float[] angle, int len );
public static native void cvbFastArctan( @Const FloatPointer y, @Const FloatPointer x, FloatPointer angle, int len );
public static native void cvbFastArctan( @Const FloatBuffer y, @Const FloatBuffer x, FloatBuffer angle, int len );
public static native void cvbFastArctan( @Const float[] y, @Const float[] x, float[] angle, int len );
public static native void cvbSqrt( @Const FloatPointer x, FloatPointer y, int len );
public static native void cvbSqrt( @Const FloatBuffer x, FloatBuffer y, int len );
public static native void cvbSqrt( @Const float[] x, float[] y, int len );
public static native void cvbInvSqrt( @Const FloatPointer x, FloatPointer y, int len );
public static native void cvbInvSqrt( @Const FloatBuffer x, FloatBuffer y, int len );
public static native void cvbInvSqrt( @Const float[] x, float[] y, int len );
public static native void cvbReciprocal( @Const FloatPointer x, FloatPointer y, int len );
public static native void cvbReciprocal( @Const FloatBuffer x, FloatBuffer y, int len );
public static native void cvbReciprocal( @Const float[] x, float[] y, int len );
public static native void cvbFastExp( @Const FloatPointer x, DoublePointer y, int len );
public static native void cvbFastExp( @Const FloatBuffer x, DoubleBuffer y, int len );
public static native void cvbFastExp( @Const float[] x, double[] y, int len );
public static native void cvbFastLog( @Const DoublePointer x, FloatPointer y, int len );
public static native void cvbFastLog( @Const DoubleBuffer x, FloatBuffer y, int len );
public static native void cvbFastLog( @Const double[] x, float[] y, int len );

public static native @ByVal CvRect cvContourBoundingRect( Pointer point_set, int update/*CV_DEFAULT(0)*/);

public static native double cvPseudoInverse( @Const CvArr src, CvArr dst );
public static native double cvPseudoInv(CvArr arg1, CvArr arg2);

public static native void cvContourMoments(CvArr contour, CvMoments moments);

public static native Pointer cvGetPtrAt(CvArr arg1, int arg2, int arg3);
public static native @ByVal CvScalar cvGetAt(CvArr arg1, int arg2, int arg3);
public static native void cvSetAt(CvArr arr, @ByVal CvScalar val, int y, int x);

public static native double cvMeanMask(CvArr arg1, CvArr arg2);
public static native void cvMean_StdDevMask(CvArr img, CvArr mask, DoublePointer mean, DoublePointer sdv);
public static native void cvMean_StdDevMask(CvArr img, CvArr mask, DoubleBuffer mean, DoubleBuffer sdv);
public static native void cvMean_StdDevMask(CvArr img, CvArr mask, double[] mean, double[] sdv);

public static native double cvNormMask(CvArr imgA, CvArr imgB, CvArr mask, int normType);

// #define cvMinMaxLocMask(img, mask, min_val, max_val, min_loc, max_loc)
//         cvMinMaxLoc(img, min_val, max_val, min_loc, max_loc, mask)

public static native void cvRemoveMemoryManager(CvAllocFunc arg1, CvFreeFunc arg2, Pointer arg3);

// #define cvmSetZero( mat )               cvSetZero( mat )
// #define cvmSetIdentity( mat )           cvSetIdentity( mat )
// #define cvmAdd( src1, src2, dst )       cvAdd( src1, src2, dst, 0 )
// #define cvmSub( src1, src2, dst )       cvSub( src1, src2, dst, 0 )
// #define cvmCopy( src, dst )             cvCopy( src, dst, 0 )
// #define cvmMul( src1, src2, dst )       cvMatMulAdd( src1, src2, 0, dst )
// #define cvmTranspose( src, dst )        cvT( src, dst )
// #define cvmInvert( src, dst )           cvInv( src, dst )
// #define cvmMahalanobis(vec1, vec2, mat) cvMahalanobis( vec1, vec2, mat )
// #define cvmDotProduct( vec1, vec2 )     cvDotProduct( vec1, vec2 )
// #define cvmCrossProduct(vec1, vec2,dst) cvCrossProduct( vec1, vec2, dst )
// #define cvmTrace( mat )                 (cvTrace( mat )).val[0]
// #define cvmMulTransposed( src, dst, order ) cvMulTransposed( src, dst, order )
// #define cvmEigenVV( mat, evec, eval, eps)   cvEigenVV( mat, evec, eval, eps )
// #define cvmDet( mat )                   cvDet( mat )
// #define cvmScale( src, dst, scale )     cvScale( src, dst, scale )

public static native void cvCopyImage(CvArr src, CvArr dst);
public static native void cvReleaseMatHeader(@Cast("CvMat**") PointerPointer arg1);
public static native void cvReleaseMatHeader(@ByPtrPtr CvMat arg1);

/* Calculates exact convex hull of 2d point set */
public static native void cvConvexHull( CvPoint points, int num_points,
                             CvRect bound_rect,
                             int orientation, IntPointer hull, IntPointer hullsize );
public static native void cvConvexHull( CvPoint points, int num_points,
                             CvRect bound_rect,
                             int orientation, IntBuffer hull, IntBuffer hullsize );
public static native void cvConvexHull( CvPoint points, int num_points,
                             CvRect bound_rect,
                             int orientation, int[] hull, int[] hullsize );


public static native void cvMinAreaRect( CvPoint points, int n,
                              int left, int bottom,
                              int right, int top,
                              CvPoint2D32f anchor,
                              CvPoint2D32f vect1,
                              CvPoint2D32f vect2 );

public static native void cvFitLine3D( CvPoint3D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, FloatPointer line );
public static native void cvFitLine3D( CvPoint3D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, FloatBuffer line );
public static native void cvFitLine3D( CvPoint3D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, float[] line );

/* Fits a line into set of 2d points in a robust way (M-estimator technique) */
public static native void cvFitLine2D( CvPoint2D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, FloatPointer line );
public static native void cvFitLine2D( CvPoint2D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, FloatBuffer line );
public static native void cvFitLine2D( CvPoint2D32f points, int count, int dist,
                    Pointer param, float reps, float aeps, float[] line );

public static native void cvFitEllipse( @Const CvPoint2D32f points, int count, CvBox2D box );

/* Projects 2d points to one of standard coordinate planes
   (i.e. removes one of coordinates) */
public static native void cvProject3D( CvPoint3D32f points3D, int count,
                              CvPoint2D32f points2D,
                              int xIndx/*CV_DEFAULT(0)*/,
                              int yIndx/*CV_DEFAULT(1)*/);

/* Retrieves value of the particular bin
   of x-dimensional (x=1,2,3,...) histogram */
// #define cvQueryHistValue_1D( hist, idx0 )
//     ((float)cvGetReal1D( (hist)->bins, (idx0)))
// #define cvQueryHistValue_2D( hist, idx0, idx1 )
//     ((float)cvGetReal2D( (hist)->bins, (idx0), (idx1)))
// #define cvQueryHistValue_3D( hist, idx0, idx1, idx2 )
//     ((float)cvGetReal3D( (hist)->bins, (idx0), (idx1), (idx2)))
// #define cvQueryHistValue_nD( hist, idx )
//     ((float)cvGetRealND( (hist)->bins, (idx)))

/* Returns pointer to the particular bin of x-dimesional histogram.
   For sparse histogram the bin is created if it didn't exist before */
// #define cvGetHistValue_1D( hist, idx0 )
//     ((float*)cvPtr1D( (hist)->bins, (idx0), 0))
// #define cvGetHistValue_2D( hist, idx0, idx1 )
//     ((float*)cvPtr2D( (hist)->bins, (idx0), (idx1), 0))
// #define cvGetHistValue_3D( hist, idx0, idx1, idx2 )
//     ((float*)cvPtr3D( (hist)->bins, (idx0), (idx1), (idx2), 0))
// #define cvGetHistValue_nD( hist, idx )
//     ((float*)cvPtrND( (hist)->bins, (idx), 0))


public static native @Cast("bool") boolean CV_IS_SET_ELEM_EXISTS(CvSetElem arg1);


public static native int cvHoughLines( CvArr image, double rho,
                              double theta, int threshold,
                              FloatPointer lines, int linesNumber );
public static native int cvHoughLines( CvArr image, double rho,
                              double theta, int threshold,
                              FloatBuffer lines, int linesNumber );
public static native int cvHoughLines( CvArr image, double rho,
                              double theta, int threshold,
                              float[] lines, int linesNumber );

public static native int cvHoughLinesP( CvArr image, double rho,
                               double theta, int threshold,
                               int lineLength, int lineGap,
                               IntPointer lines, int linesNumber );
public static native int cvHoughLinesP( CvArr image, double rho,
                               double theta, int threshold,
                               int lineLength, int lineGap,
                               IntBuffer lines, int linesNumber );
public static native int cvHoughLinesP( CvArr image, double rho,
                               double theta, int threshold,
                               int lineLength, int lineGap,
                               int[] lines, int linesNumber );


public static native int cvHoughLinesSDiv( CvArr image, double rho, int srn,
                                  double theta, int stn, int threshold,
                                  FloatPointer lines, int linesNumber );
public static native int cvHoughLinesSDiv( CvArr image, double rho, int srn,
                                  double theta, int stn, int threshold,
                                  FloatBuffer lines, int linesNumber );
public static native int cvHoughLinesSDiv( CvArr image, double rho, int srn,
                                  double theta, int stn, int threshold,
                                  float[] lines, int linesNumber );

public static native float cvCalcEMD( @Const FloatPointer signature1, int size1,
                             @Const FloatPointer signature2, int size2,
                             int dims, int dist_type/*CV_DEFAULT(CV_DIST_L2)*/,
                             CvDistanceFunction dist_func/*CV_DEFAULT(0)*/,
                             FloatPointer lower_bound/*CV_DEFAULT(0)*/,
                             Pointer user_param/*CV_DEFAULT(0)*/);
public static native float cvCalcEMD( @Const FloatBuffer signature1, int size1,
                             @Const FloatBuffer signature2, int size2,
                             int dims, int dist_type/*CV_DEFAULT(CV_DIST_L2)*/,
                             CvDistanceFunction dist_func/*CV_DEFAULT(0)*/,
                             FloatBuffer lower_bound/*CV_DEFAULT(0)*/,
                             Pointer user_param/*CV_DEFAULT(0)*/);
public static native float cvCalcEMD( @Const float[] signature1, int size1,
                             @Const float[] signature2, int size2,
                             int dims, int dist_type/*CV_DEFAULT(CV_DIST_L2)*/,
                             CvDistanceFunction dist_func/*CV_DEFAULT(0)*/,
                             float[] lower_bound/*CV_DEFAULT(0)*/,
                             Pointer user_param/*CV_DEFAULT(0)*/);

public static native void cvKMeans( int num_clusters, @Cast("float**") PointerPointer samples,
                           int num_samples, int vec_size,
                           @ByVal CvTermCriteria termcrit, IntPointer cluster_idx );
public static native void cvKMeans( int num_clusters, @ByPtrPtr FloatPointer samples,
                           int num_samples, int vec_size,
                           @ByVal CvTermCriteria termcrit, IntPointer cluster_idx );
public static native void cvKMeans( int num_clusters, @ByPtrPtr FloatBuffer samples,
                           int num_samples, int vec_size,
                           @ByVal CvTermCriteria termcrit, IntBuffer cluster_idx );
public static native void cvKMeans( int num_clusters, @ByPtrPtr float[] samples,
                           int num_samples, int vec_size,
                           @ByVal CvTermCriteria termcrit, int[] cluster_idx );

public static native void cvStartScanGraph( CvGraph graph, CvGraphScanner scanner,
                                  CvGraphVtx vtx/*CV_DEFAULT(NULL)*/,
                                  int mask/*CV_DEFAULT(CV_GRAPH_ALL_ITEMS)*/);

public static native void cvEndScanGraph( CvGraphScanner scanner );


/* old drawing functions */
public static native void cvLineAA( CvArr img, @ByVal CvPoint pt1, @ByVal CvPoint pt2,
                            double color, int scale/*CV_DEFAULT(0)*/);

public static native void cvCircleAA( CvArr img, @ByVal CvPoint center, int radius,
                            double color, int scale/*CV_DEFAULT(0)*/ );

public static native void cvEllipseAA( CvArr img, @ByVal CvPoint center, @ByVal CvSize axes,
                              double angle, double start_angle,
                              double end_angle, double color,
                              int scale/*CV_DEFAULT(0)*/ );

public static native void cvPolyLineAA( CvArr img, @Cast("CvPoint**") PointerPointer pts, IntPointer npts, int contours,
                              int is_closed, double color, int scale/*CV_DEFAULT(0)*/ );
public static native void cvPolyLineAA( CvArr img, @ByPtrPtr CvPoint pts, IntPointer npts, int contours,
                              int is_closed, double color, int scale/*CV_DEFAULT(0)*/ );
public static native void cvPolyLineAA( CvArr img, @ByPtrPtr CvPoint pts, IntBuffer npts, int contours,
                              int is_closed, double color, int scale/*CV_DEFAULT(0)*/ );
public static native void cvPolyLineAA( CvArr img, @ByPtrPtr CvPoint pts, int[] npts, int contours,
                              int is_closed, double color, int scale/*CV_DEFAULT(0)*/ );

/****************************************************************************************\
*                                   Pixel Access Macros                                  *
\****************************************************************************************/

public static class CvPixelPosition8u extends Pointer {
    static { Loader.load(); }
    public CvPixelPosition8u() { allocate(); }
    public CvPixelPosition8u(int size) { allocateArray(size); }
    public CvPixelPosition8u(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPixelPosition8u position(int position) {
        return (CvPixelPosition8u)super.position(position);
    }

    public native @Cast("uchar*") BytePointer currline(); public native CvPixelPosition8u currline(BytePointer currline);      /* pointer to the start of the current pixel line   */
    public native @Cast("uchar*") BytePointer topline(); public native CvPixelPosition8u topline(BytePointer topline);       /* pointer to the start of the top pixel line       */
    public native @Cast("uchar*") BytePointer bottomline(); public native CvPixelPosition8u bottomline(BytePointer bottomline);    /* pointer to the start of the first line           */
                                    /* which is below the image                         */
    public native int x(); public native CvPixelPosition8u x(int x);                      /* current x coordinate ( in pixels )               */
    public native int width(); public native CvPixelPosition8u width(int width);                  /* width of the image  ( in pixels )                */
    public native int height(); public native CvPixelPosition8u height(int height);                 /* height of the image  ( in pixels )               */
    public native int step(); public native CvPixelPosition8u step(int step);                   /* distance between lines ( in elements of single   */
                                    /* plane )                                          */
    public native int step_arr(int i); public native CvPixelPosition8u step_arr(int i, int step_arr);
    @MemberGetter public native IntPointer step_arr();            /* array: ( 0, -step, step ). It is used for        */
                                    /* vertical moving                                  */
}

/* this structure differs from the above only in data type */
public static class CvPixelPosition8s extends Pointer {
    static { Loader.load(); }
    public CvPixelPosition8s() { allocate(); }
    public CvPixelPosition8s(int size) { allocateArray(size); }
    public CvPixelPosition8s(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPixelPosition8s position(int position) {
        return (CvPixelPosition8s)super.position(position);
    }

    public native @Cast("schar*") BytePointer currline(); public native CvPixelPosition8s currline(BytePointer currline);
    public native @Cast("schar*") BytePointer topline(); public native CvPixelPosition8s topline(BytePointer topline);
    public native @Cast("schar*") BytePointer bottomline(); public native CvPixelPosition8s bottomline(BytePointer bottomline);
    public native int x(); public native CvPixelPosition8s x(int x);
    public native int width(); public native CvPixelPosition8s width(int width);
    public native int height(); public native CvPixelPosition8s height(int height);
    public native int step(); public native CvPixelPosition8s step(int step);
    public native int step_arr(int i); public native CvPixelPosition8s step_arr(int i, int step_arr);
    @MemberGetter public native IntPointer step_arr();
}

/* this structure differs from the CvPixelPosition8u only in data type */
public static class CvPixelPosition32f extends Pointer {
    static { Loader.load(); }
    public CvPixelPosition32f() { allocate(); }
    public CvPixelPosition32f(int size) { allocateArray(size); }
    public CvPixelPosition32f(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvPixelPosition32f position(int position) {
        return (CvPixelPosition32f)super.position(position);
    }

    public native FloatPointer currline(); public native CvPixelPosition32f currline(FloatPointer currline);
    public native FloatPointer topline(); public native CvPixelPosition32f topline(FloatPointer topline);
    public native FloatPointer bottomline(); public native CvPixelPosition32f bottomline(FloatPointer bottomline);
    public native int x(); public native CvPixelPosition32f x(int x);
    public native int width(); public native CvPixelPosition32f width(int width);
    public native int height(); public native CvPixelPosition32f height(int height);
    public native int step(); public native CvPixelPosition32f step(int step);
    public native int step_arr(int i); public native CvPixelPosition32f step_arr(int i, int step_arr);
    @MemberGetter public native IntPointer step_arr();
}


/* Initialize one of the CvPixelPosition structures.   */
/*  pos    - initialized structure                     */
/*  origin - pointer to the left-top corner of the ROI */
/*  step   - width of the whole image in bytes         */
/*  roi    - width & height of the ROI                 */
/*  x, y   - initial position                          */
// #define CV_INIT_PIXEL_POS(pos, origin, _step, roi, _x, _y, orientation)
//     (
//     (pos).step = (_step)/sizeof((pos).crrline[0]) * (orientation ? -1 : 1),
//     (pos).width = (roi).width,
//     (pos).height = (roi).height,
//     (pos).bottomline = (origin) + (pos).step*(pos).height,
//     (pos).topline = (origin) - (pos).step,
//     (pos).step_arr[0] = 0,
//     (pos).step_arr[1] = -(pos).step,
//     (pos).step_arr[2] = (pos).step,
//     (pos).x = (_x),
//     (pos).crrline = (origin) + (pos).step*(_y) )


/* Move to specified point ( absolute shift ) */
/*  pos    - position structure               */
/*  x, y   - coordinates of the new position  */
/*  cs     - number of the image channels     */
// #define CV_MOVE_TO( pos, _x, _y, cs )
// ((pos).crrline = (_y) >= 0 && (_y) < (pos).height ? (pos).topline + ((_y)+1)*(pos).step : 0,
//  (pos).x = (_x) >= 0 && (_x) < (pos).width ? (_x) : 0, (pos).crrline + (_x) * (cs) )

/* Get current coordinates                    */
/*  pos    - position structure               */
/*  x, y   - coordinates of the new position  */
/*  cs     - number of the image channels     */
// #define CV_GET_CURRENT( pos, cs )  ((pos).crrline + (pos).x * (cs))

/* Move by one pixel relatively to current position */
/*  pos    - position structure                     */
/*  cs     - number of the image channels           */

/* left */
// #define CV_MOVE_LEFT( pos, cs )
//  ( --(pos).x >= 0 ? (pos).crrline + (pos).x*(cs) : 0 )

/* right */
// #define CV_MOVE_RIGHT( pos, cs )
//  ( ++(pos).x < (pos).width ? (pos).crrline + (pos).x*(cs) : 0 )

/* up */
// #define CV_MOVE_UP( pos, cs )
//  (((pos).crrline -= (pos).step) != (pos).topline ? (pos).crrline + (pos).x*(cs) : 0 )

/* down */
// #define CV_MOVE_DOWN( pos, cs )
//  (((pos).crrline += (pos).step) != (pos).bottomline ? (pos).crrline + (pos).x*(cs) : 0 )

/* left up */
// #define CV_MOVE_LU( pos, cs ) ( CV_MOVE_LEFT(pos, cs), CV_MOVE_UP(pos, cs))

/* right up */
// #define CV_MOVE_RU( pos, cs ) ( CV_MOVE_RIGHT(pos, cs), CV_MOVE_UP(pos, cs))

/* left down */
// #define CV_MOVE_LD( pos, cs ) ( CV_MOVE_LEFT(pos, cs), CV_MOVE_DOWN(pos, cs))

/* right down */
// #define CV_MOVE_RD( pos, cs ) ( CV_MOVE_RIGHT(pos, cs), CV_MOVE_DOWN(pos, cs))



/* Move by one pixel relatively to current position with wrapping when the position     */
/* achieves image boundary                                                              */
/*  pos    - position structure                                                         */
/*  cs     - number of the image channels                                               */

/* left */
// #define CV_MOVE_LEFT_WRAP( pos, cs )
//  ((pos).crrline + ( --(pos).x >= 0 ? (pos).x : ((pos).x = (pos).width-1))*(cs))

/* right */
// #define CV_MOVE_RIGHT_WRAP( pos, cs )
//  ((pos).crrline + ( ++(pos).x < (pos).width ? (pos).x : ((pos).x = 0))*(cs) )

/* up */
// #define CV_MOVE_UP_WRAP( pos, cs )
//     ((((pos).crrline -= (pos).step) != (pos).topline ?
//     (pos).crrline : ((pos).crrline = (pos).bottomline - (pos).step)) + (pos).x*(cs) )

/* down */
// #define CV_MOVE_DOWN_WRAP( pos, cs )
//     ((((pos).crrline += (pos).step) != (pos).bottomline ?
//     (pos).crrline : ((pos).crrline = (pos).topline + (pos).step)) + (pos).x*(cs) )

/* left up */
// #define CV_MOVE_LU_WRAP( pos, cs ) ( CV_MOVE_LEFT_WRAP(pos, cs), CV_MOVE_UP_WRAP(pos, cs))
/* right up */
// #define CV_MOVE_RU_WRAP( pos, cs ) ( CV_MOVE_RIGHT_WRAP(pos, cs), CV_MOVE_UP_WRAP(pos, cs))
/* left down */
// #define CV_MOVE_LD_WRAP( pos, cs ) ( CV_MOVE_LEFT_WRAP(pos, cs), CV_MOVE_DOWN_WRAP(pos, cs))
/* right down */
// #define CV_MOVE_RD_WRAP( pos, cs ) ( CV_MOVE_RIGHT_WRAP(pos, cs), CV_MOVE_DOWN_WRAP(pos, cs))

/* Numeric constants which used for moving in arbitrary direction  */
/** enum  */
public static final int
    CV_SHIFT_NONE = 2,
    CV_SHIFT_LEFT = 1,
    CV_SHIFT_RIGHT = 3,
    CV_SHIFT_UP = 6,
    CV_SHIFT_DOWN = 10,
    CV_SHIFT_LU = 5,
    CV_SHIFT_RU = 7,
    CV_SHIFT_LD = 9,
    CV_SHIFT_RD = 11;

/* Move by one pixel in specified direction                                     */
/*  pos    - position structure                                                 */
/*  shift  - direction ( it's value must be one of the CV_SHIFT_Ö constants ) */
/*  cs     - number of the image channels                                       */
// #define CV_MOVE_PARAM( pos, shift, cs )
//     ( (pos).crrline += (pos).step_arr[(shift)>>2], (pos).x += ((shift)&3)-2,
//     ((pos).crrline != (pos).topline && (pos).crrline != (pos).bottomline &&
//     (pos).x >= 0 && (pos).x < (pos).width) ? (pos).crrline + (pos).x*(cs) : 0 )

/* Move by one pixel in specified direction with wrapping when the               */
/* position achieves image boundary                                              */
/*  pos    - position structure                                                  */
/*  shift  - direction ( it's value must be one of the CV_SHIFT_Ö constants )  */
/*  cs     - number of the image channels                                        */
// #define CV_MOVE_PARAM_WRAP( pos, shift, cs )
//     ( (pos).crrline += (pos).step_arr[(shift)>>2],
//     (pos).crrline = ((pos).crrline == (pos).topline ?
//     (pos).bottomline - (pos).step :
//     (pos).crrline == (pos).bottomline ?
//     (pos).topline + (pos).step : (pos).crrline),
// 
//     (pos).x += ((shift)&3)-2,
//     (pos).x = ((pos).x < 0 ? (pos).width-1 : (pos).x >= (pos).width ? 0 : (pos).x),
// 
//     (pos).crrline + (pos).x*(cs) )

public static native void cvUnDistortOnce( @Const CvArr src, CvArr dst,
                                @Const FloatPointer intrinsic_matrix,
                                @Const FloatPointer distortion_coeffs,
                                int interpolate );
public static native void cvUnDistortOnce( @Const CvArr src, CvArr dst,
                                @Const FloatBuffer intrinsic_matrix,
                                @Const FloatBuffer distortion_coeffs,
                                int interpolate );
public static native void cvUnDistortOnce( @Const CvArr src, CvArr dst,
                                @Const float[] intrinsic_matrix,
                                @Const float[] distortion_coeffs,
                                int interpolate );

/* the two functions below have quite hackerish implementations, use with care
   (or, which is better, switch to cvUndistortInitMap and cvRemap instead */
public static native void cvUnDistortInit( @Const CvArr src,
                                CvArr undistortion_map,
                                @Const FloatPointer A, @Const FloatPointer k,
                                int interpolate );
public static native void cvUnDistortInit( @Const CvArr src,
                                CvArr undistortion_map,
                                @Const FloatBuffer A, @Const FloatBuffer k,
                                int interpolate );
public static native void cvUnDistortInit( @Const CvArr src,
                                CvArr undistortion_map,
                                @Const float[] A, @Const float[] k,
                                int interpolate );

public static native void cvUnDistort( @Const CvArr src, CvArr dst,
                             @Const CvArr undistortion_map,
                             int interpolate );

/* Find fundamental matrix */
public static native void cvFindFundamentalMatrix( IntPointer points1, IntPointer points2,
    int numpoints, int method, FloatPointer matrix );
public static native void cvFindFundamentalMatrix( IntBuffer points1, IntBuffer points2,
    int numpoints, int method, FloatBuffer matrix );
public static native void cvFindFundamentalMatrix( int[] points1, int[] points2,
    int numpoints, int method, float[] matrix );


public static native int cvFindChessBoardCornerGuesses( @Const Pointer arr, Pointer thresharr,
                               CvMemStorage storage,
                               @ByVal CvSize pattern_size, CvPoint2D32f corners,
                               IntPointer corner_count );
public static native int cvFindChessBoardCornerGuesses( @Const Pointer arr, Pointer thresharr,
                               CvMemStorage storage,
                               @ByVal CvSize pattern_size, CvPoint2D32f corners,
                               IntBuffer corner_count );
public static native int cvFindChessBoardCornerGuesses( @Const Pointer arr, Pointer thresharr,
                               CvMemStorage storage,
                               @ByVal CvSize pattern_size, CvPoint2D32f corners,
                               int[] corner_count );

/* Calibrates camera using multiple views of calibration pattern */
public static native void cvCalibrateCamera( int image_count, IntPointer _point_counts,
    @ByVal CvSize image_size, CvPoint2D32f _image_points, CvPoint3D32f _object_points,
    FloatPointer _distortion_coeffs, FloatPointer _camera_matrix, FloatPointer _translation_vectors,
    FloatPointer _rotation_matrices, int flags );
public static native void cvCalibrateCamera( int image_count, IntBuffer _point_counts,
    @ByVal CvSize image_size, CvPoint2D32f _image_points, CvPoint3D32f _object_points,
    FloatBuffer _distortion_coeffs, FloatBuffer _camera_matrix, FloatBuffer _translation_vectors,
    FloatBuffer _rotation_matrices, int flags );
public static native void cvCalibrateCamera( int image_count, int[] _point_counts,
    @ByVal CvSize image_size, CvPoint2D32f _image_points, CvPoint3D32f _object_points,
    float[] _distortion_coeffs, float[] _camera_matrix, float[] _translation_vectors,
    float[] _rotation_matrices, int flags );


public static native void cvCalibrateCamera_64d( int image_count, IntPointer _point_counts,
    @ByVal CvSize image_size, CvPoint2D64f _image_points, CvPoint3D64f _object_points,
    DoublePointer _distortion_coeffs, DoublePointer _camera_matrix, DoublePointer _translation_vectors,
    DoublePointer _rotation_matrices, int flags );
public static native void cvCalibrateCamera_64d( int image_count, IntBuffer _point_counts,
    @ByVal CvSize image_size, CvPoint2D64f _image_points, CvPoint3D64f _object_points,
    DoubleBuffer _distortion_coeffs, DoubleBuffer _camera_matrix, DoubleBuffer _translation_vectors,
    DoubleBuffer _rotation_matrices, int flags );
public static native void cvCalibrateCamera_64d( int image_count, int[] _point_counts,
    @ByVal CvSize image_size, CvPoint2D64f _image_points, CvPoint3D64f _object_points,
    double[] _distortion_coeffs, double[] _camera_matrix, double[] _translation_vectors,
    double[] _rotation_matrices, int flags );


/* Find 3d position of object given intrinsic camera parameters,
   3d model of the object and projection of the object into view plane */
public static native void cvFindExtrinsicCameraParams( int point_count,
    @ByVal CvSize image_size, CvPoint2D32f _image_points,
    CvPoint3D32f _object_points, FloatPointer focal_length,
    @ByVal CvPoint2D32f principal_point, FloatPointer _distortion_coeffs,
    FloatPointer _rotation_vector, FloatPointer _translation_vector );
public static native void cvFindExtrinsicCameraParams( int point_count,
    @ByVal CvSize image_size, CvPoint2D32f _image_points,
    CvPoint3D32f _object_points, FloatBuffer focal_length,
    @ByVal CvPoint2D32f principal_point, FloatBuffer _distortion_coeffs,
    FloatBuffer _rotation_vector, FloatBuffer _translation_vector );
public static native void cvFindExtrinsicCameraParams( int point_count,
    @ByVal CvSize image_size, CvPoint2D32f _image_points,
    CvPoint3D32f _object_points, float[] focal_length,
    @ByVal CvPoint2D32f principal_point, float[] _distortion_coeffs,
    float[] _rotation_vector, float[] _translation_vector );

/* Variant of the previous function that takes double-precision parameters */
public static native void cvFindExtrinsicCameraParams_64d( int point_count,
    @ByVal CvSize image_size, CvPoint2D64f _image_points,
    CvPoint3D64f _object_points, DoublePointer focal_length,
    @ByVal CvPoint2D64f principal_point, DoublePointer _distortion_coeffs,
    DoublePointer _rotation_vector, DoublePointer _translation_vector );
public static native void cvFindExtrinsicCameraParams_64d( int point_count,
    @ByVal CvSize image_size, CvPoint2D64f _image_points,
    CvPoint3D64f _object_points, DoubleBuffer focal_length,
    @ByVal CvPoint2D64f principal_point, DoubleBuffer _distortion_coeffs,
    DoubleBuffer _rotation_vector, DoubleBuffer _translation_vector );
public static native void cvFindExtrinsicCameraParams_64d( int point_count,
    @ByVal CvSize image_size, CvPoint2D64f _image_points,
    CvPoint3D64f _object_points, double[] focal_length,
    @ByVal CvPoint2D64f principal_point, double[] _distortion_coeffs,
    double[] _rotation_vector, double[] _translation_vector );

/* Rodrigues transform */
/** enum  */
public static final int
    CV_RODRIGUES_M2V = 0,
    CV_RODRIGUES_V2M = 1;

/* Converts rotation_matrix matrix to rotation_matrix vector or vice versa */
public static native void cvRodrigues( CvMat rotation_matrix, CvMat rotation_vector,
                              CvMat jacobian, int conv_type );

/* Does reprojection of 3d object points to the view plane */
public static native void cvProjectPoints( int point_count, CvPoint3D64f _object_points,
    DoublePointer _rotation_vector, DoublePointer _translation_vector,
    DoublePointer focal_length, @ByVal CvPoint2D64f principal_point,
    DoublePointer _distortion, CvPoint2D64f _image_points,
    DoublePointer _deriv_points_rotation_matrix,
    DoublePointer _deriv_points_translation_vect,
    DoublePointer _deriv_points_focal,
    DoublePointer _deriv_points_principal_point,
    DoublePointer _deriv_points_distortion_coeffs );
public static native void cvProjectPoints( int point_count, CvPoint3D64f _object_points,
    DoubleBuffer _rotation_vector, DoubleBuffer _translation_vector,
    DoubleBuffer focal_length, @ByVal CvPoint2D64f principal_point,
    DoubleBuffer _distortion, CvPoint2D64f _image_points,
    DoubleBuffer _deriv_points_rotation_matrix,
    DoubleBuffer _deriv_points_translation_vect,
    DoubleBuffer _deriv_points_focal,
    DoubleBuffer _deriv_points_principal_point,
    DoubleBuffer _deriv_points_distortion_coeffs );
public static native void cvProjectPoints( int point_count, CvPoint3D64f _object_points,
    double[] _rotation_vector, double[] _translation_vector,
    double[] focal_length, @ByVal CvPoint2D64f principal_point,
    double[] _distortion, CvPoint2D64f _image_points,
    double[] _deriv_points_rotation_matrix,
    double[] _deriv_points_translation_vect,
    double[] _deriv_points_focal,
    double[] _deriv_points_principal_point,
    double[] _deriv_points_distortion_coeffs );


/* Simpler version of the previous function */
public static native void cvProjectPointsSimple( int point_count, CvPoint3D64f _object_points,
    DoublePointer _rotation_matrix, DoublePointer _translation_vector,
    DoublePointer _camera_matrix, DoublePointer _distortion, CvPoint2D64f _image_points );
public static native void cvProjectPointsSimple( int point_count, CvPoint3D64f _object_points,
    DoubleBuffer _rotation_matrix, DoubleBuffer _translation_vector,
    DoubleBuffer _camera_matrix, DoubleBuffer _distortion, CvPoint2D64f _image_points );
public static native void cvProjectPointsSimple( int point_count, CvPoint3D64f _object_points,
    double[] _rotation_matrix, double[] _translation_vector,
    double[] _camera_matrix, double[] _distortion, CvPoint2D64f _image_points );


public static native void cvMake2DPoints(CvMat arg1, CvMat arg2);
public static native void cvMake3DPoints(CvMat arg1, CvMat arg2);

public static native CvMat cvWarpPerspectiveQMatrix(CvPoint2D32f arg1, CvPoint2D32f arg2, CvMat arg3);

public static native void cvConvertPointsHomogenious(CvMat arg1, CvMat arg2);


//////////////////////////////////// feature extractors: obsolete API //////////////////////////////////

public static class CvSURFPoint extends Pointer {
    static { Loader.load(); }
    public CvSURFPoint() { allocate(); }
    public CvSURFPoint(int size) { allocateArray(size); }
    public CvSURFPoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSURFPoint position(int position) {
        return (CvSURFPoint)super.position(position);
    }

    public native @ByVal CvPoint2D32f pt(); public native CvSURFPoint pt(CvPoint2D32f pt);

    public native int laplacian(); public native CvSURFPoint laplacian(int laplacian);
    public native int size(); public native CvSURFPoint size(int size);
    public native float dir(); public native CvSURFPoint dir(float dir);
    public native float hessian(); public native CvSURFPoint hessian(float hessian);

}

public static native @ByVal CvSURFPoint cvSURFPoint( @ByVal CvPoint2D32f pt, int laplacian,
                                  int size, float dir/*CV_DEFAULT(0)*/,
                                  float hessian/*CV_DEFAULT(0)*/);

public static class CvSURFParams extends Pointer {
    static { Loader.load(); }
    public CvSURFParams() { allocate(); }
    public CvSURFParams(int size) { allocateArray(size); }
    public CvSURFParams(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvSURFParams position(int position) {
        return (CvSURFParams)super.position(position);
    }

    public native int extended(); public native CvSURFParams extended(int extended);
    public native int upright(); public native CvSURFParams upright(int upright);
    public native double hessianThreshold(); public native CvSURFParams hessianThreshold(double hessianThreshold);

    public native int nOctaves(); public native CvSURFParams nOctaves(int nOctaves);
    public native int nOctaveLayers(); public native CvSURFParams nOctaveLayers(int nOctaveLayers);

}

public static native @ByVal CvSURFParams cvSURFParams( double hessianThreshold, int extended/*CV_DEFAULT(0)*/ );

// If useProvidedKeyPts!=0, keypoints are not detected, but descriptors are computed
//  at the locations provided in keypoints (a CvSeq of CvSURFPoint).
public static native void cvExtractSURF( @Const CvArr img, @Const CvArr mask,
                          @Cast("CvSeq**") PointerPointer keypoints, @Cast("CvSeq**") PointerPointer descriptors,
                          CvMemStorage storage, @ByVal CvSURFParams params,
                             int useProvidedKeyPts/*CV_DEFAULT(0)*/  );
public static native void cvExtractSURF( @Const CvArr img, @Const CvArr mask,
                          @ByPtrPtr CvSeq keypoints, @ByPtrPtr CvSeq descriptors,
                          CvMemStorage storage, @ByVal CvSURFParams params,
                             int useProvidedKeyPts/*CV_DEFAULT(0)*/  );

/**
 Maximal Stable Regions Parameters
 */
public static class CvMSERParams extends Pointer {
    static { Loader.load(); }
    public CvMSERParams() { allocate(); }
    public CvMSERParams(int size) { allocateArray(size); }
    public CvMSERParams(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMSERParams position(int position) {
        return (CvMSERParams)super.position(position);
    }

    /** delta, in the code, it compares (size_{i}-size_{i-delta})/size_{i-delta} */
    public native int delta(); public native CvMSERParams delta(int delta);
    /** prune the area which bigger than maxArea */
    public native int maxArea(); public native CvMSERParams maxArea(int maxArea);
    /** prune the area which smaller than minArea */
    public native int minArea(); public native CvMSERParams minArea(int minArea);
    /** prune the area have simliar size to its children */
    public native float maxVariation(); public native CvMSERParams maxVariation(float maxVariation);
    /** trace back to cut off mser with diversity < min_diversity */
    public native float minDiversity(); public native CvMSERParams minDiversity(float minDiversity);

    /////// the next few params for MSER of color image

    /** for color image, the evolution steps */
    public native int maxEvolution(); public native CvMSERParams maxEvolution(int maxEvolution);
    /** the area threshold to cause re-initialize */
    public native double areaThreshold(); public native CvMSERParams areaThreshold(double areaThreshold);
    /** ignore too small margin */
    public native double minMargin(); public native CvMSERParams minMargin(double minMargin);
    /** the aperture size for edge blur */
    public native int edgeBlurSize(); public native CvMSERParams edgeBlurSize(int edgeBlurSize);
}

public static native @ByVal CvMSERParams cvMSERParams( int delta/*CV_DEFAULT(5)*/, int min_area/*CV_DEFAULT(60)*/,
                                 int max_area/*CV_DEFAULT(14400)*/, float max_variation/*CV_DEFAULT(.25f)*/,
                                 float min_diversity/*CV_DEFAULT(.2f)*/, int max_evolution/*CV_DEFAULT(200)*/,
                                 double area_threshold/*CV_DEFAULT(1.01)*/,
                                 double min_margin/*CV_DEFAULT(.003)*/,
                                 int edge_blur_size/*CV_DEFAULT(5)*/ );

// Extracts the contours of Maximally Stable Extremal Regions
public static native void cvExtractMSER( CvArr _img, CvArr _mask, @Cast("CvSeq**") PointerPointer contours, CvMemStorage storage, @ByVal CvMSERParams params );
public static native void cvExtractMSER( CvArr _img, CvArr _mask, @ByPtrPtr CvSeq contours, CvMemStorage storage, @ByVal CvMSERParams params );


public static class CvStarKeypoint extends Pointer {
    static { Loader.load(); }
    public CvStarKeypoint() { allocate(); }
    public CvStarKeypoint(int size) { allocateArray(size); }
    public CvStarKeypoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStarKeypoint position(int position) {
        return (CvStarKeypoint)super.position(position);
    }

    public native @ByVal CvPoint pt(); public native CvStarKeypoint pt(CvPoint pt);
    public native int size(); public native CvStarKeypoint size(int size);
    public native float response(); public native CvStarKeypoint response(float response);
}

public static native @ByVal CvStarKeypoint cvStarKeypoint(@ByVal CvPoint pt, int size, float response);

public static class CvStarDetectorParams extends Pointer {
    static { Loader.load(); }
    public CvStarDetectorParams() { allocate(); }
    public CvStarDetectorParams(int size) { allocateArray(size); }
    public CvStarDetectorParams(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStarDetectorParams position(int position) {
        return (CvStarDetectorParams)super.position(position);
    }

    public native int maxSize(); public native CvStarDetectorParams maxSize(int maxSize);
    public native int responseThreshold(); public native CvStarDetectorParams responseThreshold(int responseThreshold);
    public native int lineThresholdProjected(); public native CvStarDetectorParams lineThresholdProjected(int lineThresholdProjected);
    public native int lineThresholdBinarized(); public native CvStarDetectorParams lineThresholdBinarized(int lineThresholdBinarized);
    public native int suppressNonmaxSize(); public native CvStarDetectorParams suppressNonmaxSize(int suppressNonmaxSize);
}

public static native @ByVal CvStarDetectorParams cvStarDetectorParams(
                                                    int maxSize/*CV_DEFAULT(45)*/,
                                                    int responseThreshold/*CV_DEFAULT(30)*/,
                                                    int lineThresholdProjected/*CV_DEFAULT(10)*/,
                                                    int lineThresholdBinarized/*CV_DEFAULT(8)*/,
                                                    int suppressNonmaxSize/*CV_DEFAULT(5)*/);

public static native CvSeq cvGetStarKeypoints( @Const CvArr img, CvMemStorage storage,
                                 @ByVal CvStarDetectorParams params/*CV_DEFAULT(cvStarDetectorParams())*/);

// #ifdef __cplusplus
// #endif

// #endif


/* Wrapper for header file /usr/local/include/opencv2/legacy/legacy.hpp */

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                        Intel License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000, Intel Corporation, all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of Intel Corporation may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef __OPENCV_LEGACY_HPP__
// #define __OPENCV_LEGACY_HPP__

// #include "opencv2/imgproc/imgproc.hpp"
// #include "opencv2/imgproc/imgproc_c.h"
// #include "opencv2/features2d/features2d.hpp"
// #include "opencv2/calib3d/calib3d.hpp"
// #include "opencv2/ml/ml.hpp"

// #ifdef __cplusplus
// #endif

public static native CvSeq cvSegmentImage( @Const CvArr srcarr, CvArr dstarr,
                                    double canny_threshold,
                                    double ffill_threshold,
                                    CvMemStorage storage );

/****************************************************************************************\
*                                  Eigen objects                                         *
\****************************************************************************************/

public static class CvCallback extends FunctionPointer {
    static { Loader.load(); }
    public    CvCallback(Pointer p) { super(p); }
    protected CvCallback() { allocate(); }
    private native void allocate();
    public native int call(int index, Pointer buffer, Pointer user_data);
}
public static class CvInput extends Pointer {
    static { Loader.load(); }
    public CvInput() { allocate(); }
    public CvInput(int size) { allocateArray(size); }
    public CvInput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvInput position(int position) {
        return (CvInput)super.position(position);
    }

    public native CvCallback callback(); public native CvInput callback(CvCallback callback);
    public native Pointer data(); public native CvInput data(Pointer data);
}

public static final int CV_EIGOBJ_NO_CALLBACK =     0;
public static final int CV_EIGOBJ_INPUT_CALLBACK =  1;
public static final int CV_EIGOBJ_OUTPUT_CALLBACK = 2;
public static final int CV_EIGOBJ_BOTH_CALLBACK =   3;

/* Calculates covariation matrix of a set of arrays */
public static native void cvCalcCovarMatrixEx( int nObjects, Pointer input, int ioFlags,
                                  int ioBufSize, @Cast("uchar*") BytePointer buffer, Pointer userData,
                                  IplImage avg, FloatPointer covarMatrix );
public static native void cvCalcCovarMatrixEx( int nObjects, Pointer input, int ioFlags,
                                  int ioBufSize, @Cast("uchar*") ByteBuffer buffer, Pointer userData,
                                  IplImage avg, FloatBuffer covarMatrix );
public static native void cvCalcCovarMatrixEx( int nObjects, Pointer input, int ioFlags,
                                  int ioBufSize, @Cast("uchar*") byte[] buffer, Pointer userData,
                                  IplImage avg, float[] covarMatrix );

/* Calculates eigen values and vectors of covariation matrix of a set of
   arrays */
public static native void cvCalcEigenObjects( int nObjects, Pointer input, Pointer output,
                                 int ioFlags, int ioBufSize, Pointer userData,
                                 CvTermCriteria calcLimit, IplImage avg,
                                 FloatPointer eigVals );
public static native void cvCalcEigenObjects( int nObjects, Pointer input, Pointer output,
                                 int ioFlags, int ioBufSize, Pointer userData,
                                 CvTermCriteria calcLimit, IplImage avg,
                                 FloatBuffer eigVals );
public static native void cvCalcEigenObjects( int nObjects, Pointer input, Pointer output,
                                 int ioFlags, int ioBufSize, Pointer userData,
                                 CvTermCriteria calcLimit, IplImage avg,
                                 float[] eigVals );

/* Calculates dot product (obj - avg) * eigObj (i.e. projects image to eigen vector) */
public static native double cvCalcDecompCoeff( IplImage obj, IplImage eigObj, IplImage avg );

/* Projects image to eigen space (finds all decomposion coefficients */
public static native void cvEigenDecomposite( IplImage obj, int nEigObjs, Pointer eigInput,
                                 int ioFlags, Pointer userData, IplImage avg,
                                 FloatPointer coeffs );
public static native void cvEigenDecomposite( IplImage obj, int nEigObjs, Pointer eigInput,
                                 int ioFlags, Pointer userData, IplImage avg,
                                 FloatBuffer coeffs );
public static native void cvEigenDecomposite( IplImage obj, int nEigObjs, Pointer eigInput,
                                 int ioFlags, Pointer userData, IplImage avg,
                                 float[] coeffs );

/* Projects original objects used to calculate eigen space basis to that space */
public static native void cvEigenProjection( Pointer eigInput, int nEigObjs, int ioFlags,
                                Pointer userData, FloatPointer coeffs, IplImage avg,
                                IplImage proj );
public static native void cvEigenProjection( Pointer eigInput, int nEigObjs, int ioFlags,
                                Pointer userData, FloatBuffer coeffs, IplImage avg,
                                IplImage proj );
public static native void cvEigenProjection( Pointer eigInput, int nEigObjs, int ioFlags,
                                Pointer userData, float[] coeffs, IplImage avg,
                                IplImage proj );

/****************************************************************************************\
*                                       1D/2D HMM                                        *
\****************************************************************************************/

public static class CvImgObsInfo extends Pointer {
    static { Loader.load(); }
    public CvImgObsInfo() { allocate(); }
    public CvImgObsInfo(int size) { allocateArray(size); }
    public CvImgObsInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvImgObsInfo position(int position) {
        return (CvImgObsInfo)super.position(position);
    }

    public native int obs_x(); public native CvImgObsInfo obs_x(int obs_x);
    public native int obs_y(); public native CvImgObsInfo obs_y(int obs_y);
    public native int obs_size(); public native CvImgObsInfo obs_size(int obs_size);
    public native FloatPointer obs(); public native CvImgObsInfo obs(FloatPointer obs);//consequtive observations

    public native IntPointer state(); public native CvImgObsInfo state(IntPointer state);/* arr of pairs superstate/state to which observation belong */
    public native IntPointer mix(); public native CvImgObsInfo mix(IntPointer mix);  /* number of mixture to which observation belong */

}/*struct for 1 image*/

public static class CvEHMMState extends Pointer {
    static { Loader.load(); }
    public CvEHMMState() { allocate(); }
    public CvEHMMState(int size) { allocateArray(size); }
    public CvEHMMState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvEHMMState position(int position) {
        return (CvEHMMState)super.position(position);
    }

    public native int num_mix(); public native CvEHMMState num_mix(int num_mix);        /*number of mixtures in this state*/
    public native FloatPointer mu(); public native CvEHMMState mu(FloatPointer mu);          /*mean vectors corresponding to each mixture*/
    public native FloatPointer inv_var(); public native CvEHMMState inv_var(FloatPointer inv_var);     /* square root of inversed variances corresp. to each mixture*/
    public native FloatPointer log_var_val(); public native CvEHMMState log_var_val(FloatPointer log_var_val); /* sum of 0.5 (LN2PI + ln(variance[i]) ) for i=1,n */
    public native FloatPointer weight(); public native CvEHMMState weight(FloatPointer weight);      /*array of mixture weights. Summ of all weights in state is 1. */

}

public static class CvEHMM extends Pointer {
    static { Loader.load(); }
    public CvEHMM() { allocate(); }
    public CvEHMM(int size) { allocateArray(size); }
    public CvEHMM(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvEHMM position(int position) {
        return (CvEHMM)super.position(position);
    }

    public native int level(); public native CvEHMM level(int level); /* 0 - lowest(i.e its states are real states), ..... */
    public native int num_states(); public native CvEHMM num_states(int num_states); /* number of HMM states */
    public native FloatPointer transP(); public native CvEHMM transP(FloatPointer transP);/*transition probab. matrices for states */
    public native FloatPointer obsProb(int i); public native CvEHMM obsProb(int i, FloatPointer obsProb);
    @MemberGetter public native @Cast("float**") PointerPointer obsProb(); /* if level == 0 - array of brob matrices corresponding to hmm
                        if level == 1 - martix of matrices */
        @Name({"u", ".state"}) public native CvEHMMState u_state(); public native CvEHMM u_state(CvEHMMState u_state); /* if level == 0 points to real states array,
                               if not - points to embedded hmms */
        @Name({"u", ".ehmm"}) public native CvEHMM u_ehmm(); public native CvEHMM u_ehmm(CvEHMM u_ehmm); /* pointer to an embedded model or NULL, if it is a leaf */

}

/*CVAPI(int)  icvCreate1DHMM( CvEHMM** this_hmm,
                                   int state_number, int* num_mix, int obs_size );

CVAPI(int)  icvRelease1DHMM( CvEHMM** phmm );

CVAPI(int)  icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm );

CVAPI(int)  icvInit1DMixSegm( Cv1DObsInfo** obs_info_array, int num_img, CvEHMM* hmm);

CVAPI(int)  icvEstimate1DHMMStateParams( CvImgObsInfo** obs_info_array, int num_img, CvEHMM* hmm);

CVAPI(int)  icvEstimate1DObsProb( CvImgObsInfo* obs_info, CvEHMM* hmm );

CVAPI(int)  icvEstimate1DTransProb( Cv1DObsInfo** obs_info_array,
                                           int num_seq,
                                           CvEHMM* hmm );

CVAPI(float)  icvViterbi( Cv1DObsInfo* obs_info, CvEHMM* hmm);

CVAPI(int)  icv1DMixSegmL2( CvImgObsInfo** obs_info_array, int num_img, CvEHMM* hmm );*/

/*********************************** Embedded HMMs *************************************/

/* Creates 2D HMM */
public static native CvEHMM cvCreate2DHMM( IntPointer stateNumber, IntPointer numMix, int obsSize );
public static native CvEHMM cvCreate2DHMM( IntBuffer stateNumber, IntBuffer numMix, int obsSize );
public static native CvEHMM cvCreate2DHMM( int[] stateNumber, int[] numMix, int obsSize );

/* Releases HMM */
public static native void cvRelease2DHMM( @Cast("CvEHMM**") PointerPointer hmm );
public static native void cvRelease2DHMM( @ByPtrPtr CvEHMM hmm );

// #define CV_COUNT_OBS(roi, win, delta, numObs )
// {
//    (numObs)->width  =((roi)->width  -(win)->width  +(delta)->width)/(delta)->width;
//    (numObs)->height =((roi)->height -(win)->height +(delta)->height)/(delta)->height;
// }

/* Creates storage for observation vectors */
public static native CvImgObsInfo cvCreateObsInfo( @ByVal CvSize numObs, int obsSize );

/* Releases storage for observation vectors */
public static native void cvReleaseObsInfo( @Cast("CvImgObsInfo**") PointerPointer obs_info );
public static native void cvReleaseObsInfo( @ByPtrPtr CvImgObsInfo obs_info );


/* The function takes an image on input and and returns the sequnce of observations
   to be used with an embedded HMM; Each observation is top-left block of DCT
   coefficient matrix */
public static native void cvImgToObs_DCT( @Const CvArr arr, FloatPointer obs, @ByVal CvSize dctSize,
                             @ByVal CvSize obsSize, @ByVal CvSize delta );
public static native void cvImgToObs_DCT( @Const CvArr arr, FloatBuffer obs, @ByVal CvSize dctSize,
                             @ByVal CvSize obsSize, @ByVal CvSize delta );
public static native void cvImgToObs_DCT( @Const CvArr arr, float[] obs, @ByVal CvSize dctSize,
                             @ByVal CvSize obsSize, @ByVal CvSize delta );


/* Uniformly segments all observation vectors extracted from image */
public static native void cvUniformImgSegm( CvImgObsInfo obs_info, CvEHMM ehmm );

/* Does mixture segmentation of the states of embedded HMM */
public static native void cvInitMixSegm( @Cast("CvImgObsInfo**") PointerPointer obs_info_array,
                            int num_img, CvEHMM hmm );
public static native void cvInitMixSegm( @ByPtrPtr CvImgObsInfo obs_info_array,
                            int num_img, CvEHMM hmm );

/* Function calculates means, variances, weights of every Gaussian mixture
   of every low-level state of embedded HMM */
public static native void cvEstimateHMMStateParams( @Cast("CvImgObsInfo**") PointerPointer obs_info_array,
                                       int num_img, CvEHMM hmm );
public static native void cvEstimateHMMStateParams( @ByPtrPtr CvImgObsInfo obs_info_array,
                                       int num_img, CvEHMM hmm );

/* Function computes transition probability matrices of embedded HMM
   given observations segmentation */
public static native void cvEstimateTransProb( @Cast("CvImgObsInfo**") PointerPointer obs_info_array,
                                  int num_img, CvEHMM hmm );
public static native void cvEstimateTransProb( @ByPtrPtr CvImgObsInfo obs_info_array,
                                  int num_img, CvEHMM hmm );

/* Function computes probabilities of appearing observations at any state
   (i.e. computes P(obs|state) for every pair(obs,state)) */
public static native void cvEstimateObsProb( CvImgObsInfo obs_info,
                                CvEHMM hmm );

/* Runs Viterbi algorithm for embedded HMM */
public static native float cvEViterbi( CvImgObsInfo obs_info, CvEHMM hmm );


/* Function clusters observation vectors from several images
   given observations segmentation.
   Euclidean distance used for clustering vectors.
   Centers of clusters are given means of every mixture */
public static native void cvMixSegmL2( @Cast("CvImgObsInfo**") PointerPointer obs_info_array,
                          int num_img, CvEHMM hmm );
public static native void cvMixSegmL2( @ByPtrPtr CvImgObsInfo obs_info_array,
                          int num_img, CvEHMM hmm );

/****************************************************************************************\
*               A few functions from old stereo gesture recognition demosions            *
\****************************************************************************************/

/* Creates hand mask image given several points on the hand */
public static native void cvCreateHandMask( CvSeq hand_points,
                                   IplImage img_mask, CvRect roi);

/* Finds hand region in range image data */
public static native void cvFindHandRegion(CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatPointer line, @ByVal CvSize2D32f size, int flag,
                                CvPoint3D32f center,
                                CvMemStorage storage, @Cast("CvSeq**") PointerPointer numbers);
public static native void cvFindHandRegion(CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatPointer line, @ByVal CvSize2D32f size, int flag,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);
public static native void cvFindHandRegion(CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatBuffer line, @ByVal CvSize2D32f size, int flag,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);
public static native void cvFindHandRegion(CvPoint3D32f points, int count,
                                CvSeq indexs,
                                float[] line, @ByVal CvSize2D32f size, int flag,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);

/* Finds hand region in range image data (advanced version) */
public static native void cvFindHandRegionA( CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatPointer line, @ByVal CvSize2D32f size, int jc,
                                CvPoint3D32f center,
                                CvMemStorage storage, @Cast("CvSeq**") PointerPointer numbers);
public static native void cvFindHandRegionA( CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatPointer line, @ByVal CvSize2D32f size, int jc,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);
public static native void cvFindHandRegionA( CvPoint3D32f points, int count,
                                CvSeq indexs,
                                FloatBuffer line, @ByVal CvSize2D32f size, int jc,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);
public static native void cvFindHandRegionA( CvPoint3D32f points, int count,
                                CvSeq indexs,
                                float[] line, @ByVal CvSize2D32f size, int jc,
                                CvPoint3D32f center,
                                CvMemStorage storage, @ByPtrPtr CvSeq numbers);

/* Calculates the cooficients of the homography matrix */
public static native void cvCalcImageHomography( FloatPointer line, CvPoint3D32f center,
                                    FloatPointer intrinsic, FloatPointer homography );
public static native void cvCalcImageHomography( FloatBuffer line, CvPoint3D32f center,
                                    FloatBuffer intrinsic, FloatBuffer homography );
public static native void cvCalcImageHomography( float[] line, CvPoint3D32f center,
                                    float[] intrinsic, float[] homography );

/****************************************************************************************\
*                           More operations on sequences                                 *
\****************************************************************************************/

/*****************************************************************************************/

// #define CV_CURRENT_INT( reader ) (*((int *)(reader).ptr))
// #define CV_PREV_INT( reader ) (*((int *)(reader).prev_elem))

// #define  CV_GRAPH_WEIGHTED_VERTEX_FIELDS() CV_GRAPH_VERTEX_FIELDS()
//     float weight;

// #define  CV_GRAPH_WEIGHTED_EDGE_FIELDS() CV_GRAPH_EDGE_FIELDS()

public static class CvGraphWeightedVtx extends Pointer {
    static { Loader.load(); }
    public CvGraphWeightedVtx() { allocate(); }
    public CvGraphWeightedVtx(int size) { allocateArray(size); }
    public CvGraphWeightedVtx(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphWeightedVtx position(int position) {
        return (CvGraphWeightedVtx)super.position(position);
    }

    public native int flags(); public native CvGraphWeightedVtx flags(int flags);                      
    public native CvGraphEdge first(); public native CvGraphWeightedVtx first(CvGraphEdge first);
    public native float weight(); public native CvGraphWeightedVtx weight(float weight);
}

public static class CvGraphWeightedEdge extends Pointer {
    static { Loader.load(); }
    public CvGraphWeightedEdge() { allocate(); }
    public CvGraphWeightedEdge(int size) { allocateArray(size); }
    public CvGraphWeightedEdge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGraphWeightedEdge position(int position) {
        return (CvGraphWeightedEdge)super.position(position);
    }

    public native int flags(); public native CvGraphWeightedEdge flags(int flags);                      
    public native float weight(); public native CvGraphWeightedEdge weight(float weight);                   
    public native CvGraphEdge next(int i); public native CvGraphWeightedEdge next(int i, CvGraphEdge next);
    @MemberGetter public native @Cast("CvGraphEdge**") PointerPointer next();    
    public native CvGraphVtx vtx(int i); public native CvGraphWeightedEdge vtx(int i, CvGraphVtx vtx);
    @MemberGetter public native @Cast("CvGraphVtx**") PointerPointer vtx();
}

/** enum CvGraphWeightType */
public static final int
    CV_NOT_WEIGHTED = 0,
    CV_WEIGHTED_VTX = 1,
    CV_WEIGHTED_EDGE = 2,
    CV_WEIGHTED_ALL = 3;


/* Calculates histogram of a contour */
public static native void cvCalcPGH( @Const CvSeq contour, CvHistogram hist );

public static final int CV_DOMINANT_IPAN = 1;

/* Finds high-curvature points of the contour */
public static native CvSeq cvFindDominantPoints( CvSeq contour, CvMemStorage storage,
                                   int method/*CV_DEFAULT(CV_DOMINANT_IPAN)*/,
                                   double parameter1/*CV_DEFAULT(0)*/,
                                   double parameter2/*CV_DEFAULT(0)*/,
                                   double parameter3/*CV_DEFAULT(0)*/,
                                   double parameter4/*CV_DEFAULT(0)*/);

/*****************************************************************************************/


/*******************************Stereo correspondence*************************************/

public static class CvCliqueFinder extends Pointer {
    static { Loader.load(); }
    public CvCliqueFinder() { allocate(); }
    public CvCliqueFinder(int size) { allocateArray(size); }
    public CvCliqueFinder(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvCliqueFinder position(int position) {
        return (CvCliqueFinder)super.position(position);
    }

    public native CvGraph graph(); public native CvCliqueFinder graph(CvGraph graph);
    public native IntPointer adj_matr(int i); public native CvCliqueFinder adj_matr(int i, IntPointer adj_matr);
    @MemberGetter public native @Cast("int**") PointerPointer adj_matr();
    public native int N(); public native CvCliqueFinder N(int N); //graph size

    // stacks, counters etc/
    public native int k(); public native CvCliqueFinder k(int k); //stack size
    public native IntPointer current_comp(); public native CvCliqueFinder current_comp(IntPointer current_comp);
    public native IntPointer All(int i); public native CvCliqueFinder All(int i, IntPointer All);
    @MemberGetter public native @Cast("int**") PointerPointer All();

    public native IntPointer ne(); public native CvCliqueFinder ne(IntPointer ne);
    public native IntPointer ce(); public native CvCliqueFinder ce(IntPointer ce);
    public native IntPointer fixp(); public native CvCliqueFinder fixp(IntPointer fixp); //node with minimal disconnections
    public native IntPointer nod(); public native CvCliqueFinder nod(IntPointer nod);
    public native IntPointer s(); public native CvCliqueFinder s(IntPointer s); //for selected candidate
    public native int status(); public native CvCliqueFinder status(int status);
    public native int best_score(); public native CvCliqueFinder best_score(int best_score);
    public native int weighted(); public native CvCliqueFinder weighted(int weighted);
    public native int weighted_edges(); public native CvCliqueFinder weighted_edges(int weighted_edges);
    public native float best_weight(); public native CvCliqueFinder best_weight(float best_weight);
    public native FloatPointer edge_weights(); public native CvCliqueFinder edge_weights(FloatPointer edge_weights);
    public native FloatPointer vertex_weights(); public native CvCliqueFinder vertex_weights(FloatPointer vertex_weights);
    public native FloatPointer cur_weight(); public native CvCliqueFinder cur_weight(FloatPointer cur_weight);
    public native FloatPointer cand_weight(); public native CvCliqueFinder cand_weight(FloatPointer cand_weight);

}

public static final int CLIQUE_TIME_OFF = 2;
public static final int CLIQUE_FOUND = 1;
public static final int CLIQUE_END =   0;

/*CVAPI(void) cvStartFindCliques( CvGraph* graph, CvCliqueFinder* finder, int reverse,
                                   int weighted CV_DEFAULT(0),  int weighted_edges CV_DEFAULT(0));
CVAPI(int) cvFindNextMaximalClique( CvCliqueFinder* finder, int* clock_rest CV_DEFAULT(0) );
CVAPI(void) cvEndFindCliques( CvCliqueFinder* finder );

CVAPI(void) cvBronKerbosch( CvGraph* graph );*/


/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvSubgraphWeight
//    Purpose: finds weight of subgraph in a graph
//    Context:
//    Parameters:
//      graph - input graph.
//      subgraph - sequence of pairwise different ints.  These are indices of vertices of subgraph.
//      weight_type - describes the way we measure weight.
//            one of the following:
//            CV_NOT_WEIGHTED - weight of a clique is simply its size
//            CV_WEIGHTED_VTX - weight of a clique is the sum of weights of its vertices
//            CV_WEIGHTED_EDGE - the same but edges
//            CV_WEIGHTED_ALL - the same but both edges and vertices
//      weight_vtx - optional vector of floats, with size = graph->total.
//            If weight_type is either CV_WEIGHTED_VTX or CV_WEIGHTED_ALL
//            weights of vertices must be provided.  If weight_vtx not zero
//            these weights considered to be here, otherwise function assumes
//            that vertices of graph are inherited from CvGraphWeightedVtx.
//      weight_edge - optional matrix of floats, of width and height = graph->total.
//            If weight_type is either CV_WEIGHTED_EDGE or CV_WEIGHTED_ALL
//            weights of edges ought to be supplied.  If weight_edge is not zero
//            function finds them here, otherwise function expects
//            edges of graph to be inherited from CvGraphWeightedEdge.
//            If this parameter is not zero structure of the graph is determined from matrix
//            rather than from CvGraphEdge's.  In particular, elements corresponding to
//            absent edges should be zero.
//    Returns:
//      weight of subgraph.
//    Notes:
//F*/
/*CVAPI(float) cvSubgraphWeight( CvGraph *graph, CvSeq *subgraph,
                                  CvGraphWeightType weight_type CV_DEFAULT(CV_NOT_WEIGHTED),
                                  CvVect32f weight_vtx CV_DEFAULT(0),
                                  CvMatr32f weight_edge CV_DEFAULT(0) );*/


/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvFindCliqueEx
//    Purpose: tries to find clique with maximum possible weight in a graph
//    Context:
//    Parameters:
//      graph - input graph.
//      storage - memory storage to be used by the result.
//      is_complementary - optional flag showing whether function should seek for clique
//            in complementary graph.
//      weight_type - describes our notion about weight.
//            one of the following:
//            CV_NOT_WEIGHTED - weight of a clique is simply its size
//            CV_WEIGHTED_VTX - weight of a clique is the sum of weights of its vertices
//            CV_WEIGHTED_EDGE - the same but edges
//            CV_WEIGHTED_ALL - the same but both edges and vertices
//      weight_vtx - optional vector of floats, with size = graph->total.
//            If weight_type is either CV_WEIGHTED_VTX or CV_WEIGHTED_ALL
//            weights of vertices must be provided.  If weight_vtx not zero
//            these weights considered to be here, otherwise function assumes
//            that vertices of graph are inherited from CvGraphWeightedVtx.
//      weight_edge - optional matrix of floats, of width and height = graph->total.
//            If weight_type is either CV_WEIGHTED_EDGE or CV_WEIGHTED_ALL
//            weights of edges ought to be supplied.  If weight_edge is not zero
//            function finds them here, otherwise function expects
//            edges of graph to be inherited from CvGraphWeightedEdge.
//            Note that in case of CV_WEIGHTED_EDGE or CV_WEIGHTED_ALL
//            nonzero is_complementary implies nonzero weight_edge.
//      start_clique - optional sequence of pairwise different ints.  They are indices of
//            vertices that shall be present in the output clique.
//      subgraph_of_ban - optional sequence of (maybe equal) ints.  They are indices of
//            vertices that shall not be present in the output clique.
//      clique_weight_ptr - optional output parameter.  Weight of found clique stored here.
//      num_generations - optional number of generations in evolutionary part of algorithm,
//            zero forces to return first found clique.
//      quality - optional parameter determining degree of required quality/speed tradeoff.
//            Must be in the range from 0 to 9.
//            0 is fast and dirty, 9 is slow but hopefully yields good clique.
//    Returns:
//      sequence of pairwise different ints.
//      These are indices of vertices that form found clique.
//    Notes:
//      in cases of CV_WEIGHTED_EDGE and CV_WEIGHTED_ALL weights should be nonnegative.
//      start_clique has a priority over subgraph_of_ban.
//F*/
/*CVAPI(CvSeq*) cvFindCliqueEx( CvGraph *graph, CvMemStorage *storage,
                                 int is_complementary CV_DEFAULT(0),
                                 CvGraphWeightType weight_type CV_DEFAULT(CV_NOT_WEIGHTED),
                                 CvVect32f weight_vtx CV_DEFAULT(0),
                                 CvMatr32f weight_edge CV_DEFAULT(0),
                                 CvSeq *start_clique CV_DEFAULT(0),
                                 CvSeq *subgraph_of_ban CV_DEFAULT(0),
                                 float *clique_weight_ptr CV_DEFAULT(0),
                                 int num_generations CV_DEFAULT(3),
                                 int quality CV_DEFAULT(2) );*/


public static final int CV_UNDEF_SC_PARAM =         12345; //default value of parameters

public static final int CV_IDP_BIRCHFIELD_PARAM1 =  25;
public static final int CV_IDP_BIRCHFIELD_PARAM2 =  5;
public static final int CV_IDP_BIRCHFIELD_PARAM3 =  12;
public static final int CV_IDP_BIRCHFIELD_PARAM4 =  15;
public static final int CV_IDP_BIRCHFIELD_PARAM5 =  25;


public static final int CV_DISPARITY_BIRCHFIELD =  0;


/*F///////////////////////////////////////////////////////////////////////////
//
//    Name:    cvFindStereoCorrespondence
//    Purpose: find stereo correspondence on stereo-pair
//    Context:
//    Parameters:
//      leftImage - left image of stereo-pair (format 8uC1).
//      rightImage - right image of stereo-pair (format 8uC1).
//   mode - mode of correspondence retrieval (now CV_DISPARITY_BIRCHFIELD only)
//      dispImage - destination disparity image
//      maxDisparity - maximal disparity
//      param1, param2, param3, param4, param5 - parameters of algorithm
//    Returns:
//    Notes:
//      Images must be rectified.
//      All images must have format 8uC1.
//F*/
public static native void cvFindStereoCorrespondence(
                   @Const CvArr leftImage, @Const CvArr rightImage,
                   int mode,
                   CvArr dispImage,
                   int maxDisparity,
                   double param1/*CV_DEFAULT(CV_UNDEF_SC_PARAM)*/,
                   double param2/*CV_DEFAULT(CV_UNDEF_SC_PARAM)*/,
                   double param3/*CV_DEFAULT(CV_UNDEF_SC_PARAM)*/,
                   double param4/*CV_DEFAULT(CV_UNDEF_SC_PARAM)*/,
                   double param5/*CV_DEFAULT(CV_UNDEF_SC_PARAM)*/ );

/*****************************************************************************************/
/************ Epiline functions *******************/



public static class CvStereoLineCoeff extends Pointer {
    static { Loader.load(); }
    public CvStereoLineCoeff() { allocate(); }
    public CvStereoLineCoeff(int size) { allocateArray(size); }
    public CvStereoLineCoeff(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStereoLineCoeff position(int position) {
        return (CvStereoLineCoeff)super.position(position);
    }

    public native double Xcoef(); public native CvStereoLineCoeff Xcoef(double Xcoef);
    public native double XcoefA(); public native CvStereoLineCoeff XcoefA(double XcoefA);
    public native double XcoefB(); public native CvStereoLineCoeff XcoefB(double XcoefB);
    public native double XcoefAB(); public native CvStereoLineCoeff XcoefAB(double XcoefAB);

    public native double Ycoef(); public native CvStereoLineCoeff Ycoef(double Ycoef);
    public native double YcoefA(); public native CvStereoLineCoeff YcoefA(double YcoefA);
    public native double YcoefB(); public native CvStereoLineCoeff YcoefB(double YcoefB);
    public native double YcoefAB(); public native CvStereoLineCoeff YcoefAB(double YcoefAB);

    public native double Zcoef(); public native CvStereoLineCoeff Zcoef(double Zcoef);
    public native double ZcoefA(); public native CvStereoLineCoeff ZcoefA(double ZcoefA);
    public native double ZcoefB(); public native CvStereoLineCoeff ZcoefB(double ZcoefB);
    public native double ZcoefAB(); public native CvStereoLineCoeff ZcoefAB(double ZcoefAB);
}


public static class CvCamera extends Pointer {
    static { Loader.load(); }
    public CvCamera() { allocate(); }
    public CvCamera(int size) { allocateArray(size); }
    public CvCamera(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvCamera position(int position) {
        return (CvCamera)super.position(position);
    }

    public native float imgSize(int i); public native CvCamera imgSize(int i, float imgSize);
    @MemberGetter public native FloatPointer imgSize(); /* size of the camera view, used during calibration */
    public native float matrix(int i); public native CvCamera matrix(int i, float matrix);
    @MemberGetter public native FloatPointer matrix(); /* intinsic camera parameters:  [ fx 0 cx; 0 fy cy; 0 0 1 ] */
    public native float distortion(int i); public native CvCamera distortion(int i, float distortion);
    @MemberGetter public native FloatPointer distortion(); /* distortion coefficients - two coefficients for radial distortion
                              and another two for tangential: [ k1 k2 p1 p2 ] */
    public native float rotMatr(int i); public native CvCamera rotMatr(int i, float rotMatr);
    @MemberGetter public native FloatPointer rotMatr();
    public native float transVect(int i); public native CvCamera transVect(int i, float transVect);
    @MemberGetter public native FloatPointer transVect(); /* rotation matrix and transition vector relatively
                             to some reference point in the space. */
}

public static class CvStereoCamera extends Pointer {
    static { Loader.load(); }
    public CvStereoCamera() { allocate(); }
    public CvStereoCamera(int size) { allocateArray(size); }
    public CvStereoCamera(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStereoCamera position(int position) {
        return (CvStereoCamera)super.position(position);
    }

    public native CvCamera camera(int i); public native CvStereoCamera camera(int i, CvCamera camera);
    @MemberGetter public native @Cast("CvCamera**") PointerPointer camera(); /* two individual camera parameters */
    public native float fundMatr(int i); public native CvStereoCamera fundMatr(int i, float fundMatr);
    @MemberGetter public native FloatPointer fundMatr(); /* fundamental matrix */

    /* New part for stereo */
    public native @ByVal CvPoint3D32f epipole(int i); public native CvStereoCamera epipole(int i, CvPoint3D32f epipole);
    @MemberGetter public native CvPoint3D32f epipole();
    public native @ByVal CvPoint2D32f quad(int i, int j); public native CvStereoCamera quad(int i, int j, CvPoint2D32f quad);
    @MemberGetter public native @Cast("CvPoint2D32f(*)[4]") CvPoint2D32f quad(); /* coordinates of destination quadrangle after
                                epipolar geometry rectification */
    public native double coeffs(int i, int j, int k); public native CvStereoCamera coeffs(int i, int j, int k, double coeffs);
    @MemberGetter public native @Cast("double(*)[3][3]") DoublePointer coeffs();/* coefficients for transformation */
    public native @ByVal CvPoint2D32f border(int i, int j); public native CvStereoCamera border(int i, int j, CvPoint2D32f border);
    @MemberGetter public native @Cast("CvPoint2D32f(*)[4]") CvPoint2D32f border();
    public native @ByVal CvSize warpSize(); public native CvStereoCamera warpSize(CvSize warpSize);
    public native CvStereoLineCoeff lineCoeffs(); public native CvStereoCamera lineCoeffs(CvStereoLineCoeff lineCoeffs);
    public native int needSwapCameras(); public native CvStereoCamera needSwapCameras(int needSwapCameras);/* flag set to 1 if need to swap cameras for good reconstruction */
    public native float rotMatrix(int i); public native CvStereoCamera rotMatrix(int i, float rotMatrix);
    @MemberGetter public native FloatPointer rotMatrix();
    public native float transVector(int i); public native CvStereoCamera transVector(int i, float transVector);
    @MemberGetter public native FloatPointer transVector();
}


public static class CvContourOrientation extends Pointer {
    static { Loader.load(); }
    public CvContourOrientation() { allocate(); }
    public CvContourOrientation(int size) { allocateArray(size); }
    public CvContourOrientation(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvContourOrientation position(int position) {
        return (CvContourOrientation)super.position(position);
    }

    public native float egvals(int i); public native CvContourOrientation egvals(int i, float egvals);
    @MemberGetter public native FloatPointer egvals();
    public native float egvects(int i); public native CvContourOrientation egvects(int i, float egvects);
    @MemberGetter public native FloatPointer egvects();

    public native float max(); public native CvContourOrientation max(float max);
    public native float min(); public native CvContourOrientation min(float min); // minimum and maximum projections
    public native int imax(); public native CvContourOrientation imax(int imax);
    public native int imin(); public native CvContourOrientation imin(int imin);
}

public static final int CV_CAMERA_TO_WARP = 1;
public static final int CV_WARP_TO_CAMERA = 2;

public static native int icvConvertWarpCoordinates(@Cast("double(*)[3]") DoublePointer coeffs,
                                CvPoint2D32f cameraPoint,
                                CvPoint2D32f warpPoint,
                                int direction);
public static native int icvConvertWarpCoordinates(@Cast("double(*)[3]") DoubleBuffer coeffs,
                                CvPoint2D32f cameraPoint,
                                CvPoint2D32f warpPoint,
                                int direction);
public static native int icvConvertWarpCoordinates(@Cast("double(*)[3]") double[] coeffs,
                                CvPoint2D32f cameraPoint,
                                CvPoint2D32f warpPoint,
                                int direction);

public static native int icvGetSymPoint3D(  @ByVal CvPoint3D64f pointCorner,
                            @ByVal CvPoint3D64f point1,
                            @ByVal CvPoint3D64f point2,
                            CvPoint3D64f pointSym2);

public static native void icvGetPieceLength3D(@ByVal CvPoint3D64f point1,@ByVal CvPoint3D64f point2,DoublePointer dist);
public static native void icvGetPieceLength3D(@ByVal CvPoint3D64f point1,@ByVal CvPoint3D64f point2,DoubleBuffer dist);
public static native void icvGetPieceLength3D(@ByVal CvPoint3D64f point1,@ByVal CvPoint3D64f point2,double[] dist);

public static native int icvCompute3DPoint(    double alpha,double betta,
                            CvStereoLineCoeff coeffs,
                            CvPoint3D64f point);

public static native int icvCreateConvertMatrVect( DoublePointer rotMatr1,
                                DoublePointer transVect1,
                                DoublePointer rotMatr2,
                                DoublePointer transVect2,
                                DoublePointer convRotMatr,
                                DoublePointer convTransVect);
public static native int icvCreateConvertMatrVect( DoubleBuffer rotMatr1,
                                DoubleBuffer transVect1,
                                DoubleBuffer rotMatr2,
                                DoubleBuffer transVect2,
                                DoubleBuffer convRotMatr,
                                DoubleBuffer convTransVect);
public static native int icvCreateConvertMatrVect( double[] rotMatr1,
                                double[] transVect1,
                                double[] rotMatr2,
                                double[] transVect2,
                                double[] convRotMatr,
                                double[] convTransVect);

public static native int icvConvertPointSystem(@ByVal CvPoint3D64f M2,
                            CvPoint3D64f M1,
                            DoublePointer rotMatr,
                            DoublePointer transVect
                            );
public static native int icvConvertPointSystem(@ByVal CvPoint3D64f M2,
                            CvPoint3D64f M1,
                            DoubleBuffer rotMatr,
                            DoubleBuffer transVect
                            );
public static native int icvConvertPointSystem(@ByVal CvPoint3D64f M2,
                            CvPoint3D64f M1,
                            double[] rotMatr,
                            double[] transVect
                            );

public static native int icvComputeCoeffForStereo(  CvStereoCamera stereoCamera);

public static native int icvGetCrossPieceVector(@ByVal CvPoint2D32f p1_start,@ByVal CvPoint2D32f p1_end,@ByVal CvPoint2D32f v2_start,@ByVal CvPoint2D32f v2_end,CvPoint2D32f cross);
public static native int icvGetCrossLineDirect(@ByVal CvPoint2D32f p1,@ByVal CvPoint2D32f p2,float a,float b,float c,CvPoint2D32f cross);
public static native float icvDefinePointPosition(@ByVal CvPoint2D32f point1,@ByVal CvPoint2D32f point2,@ByVal CvPoint2D32f point);
public static native int icvStereoCalibration( int numImages,
                            IntPointer nums,
                            @ByVal CvSize imageSize,
                            CvPoint2D32f imagePoints1,
                            CvPoint2D32f imagePoints2,
                            CvPoint3D32f objectPoints,
                            CvStereoCamera stereoparams
                           );
public static native int icvStereoCalibration( int numImages,
                            IntBuffer nums,
                            @ByVal CvSize imageSize,
                            CvPoint2D32f imagePoints1,
                            CvPoint2D32f imagePoints2,
                            CvPoint3D32f objectPoints,
                            CvStereoCamera stereoparams
                           );
public static native int icvStereoCalibration( int numImages,
                            int[] nums,
                            @ByVal CvSize imageSize,
                            CvPoint2D32f imagePoints1,
                            CvPoint2D32f imagePoints2,
                            CvPoint3D32f objectPoints,
                            CvStereoCamera stereoparams
                           );


public static native int icvComputeRestStereoParams(CvStereoCamera stereoparams);

public static native void cvComputePerspectiveMap( @Cast("const double(*)[3]") DoublePointer coeffs, CvArr rectMapX, CvArr rectMapY );
public static native void cvComputePerspectiveMap( @Cast("const double(*)[3]") DoubleBuffer coeffs, CvArr rectMapX, CvArr rectMapY );
public static native void cvComputePerspectiveMap( @Cast("const double(*)[3]") double[] coeffs, CvArr rectMapX, CvArr rectMapY );

public static native int icvComCoeffForLine(   @ByVal CvPoint2D64f point1,
                            @ByVal CvPoint2D64f point2,
                            @ByVal CvPoint2D64f point3,
                            @ByVal CvPoint2D64f point4,
                            DoublePointer camMatr1,
                            DoublePointer rotMatr1,
                            DoublePointer transVect1,
                            DoublePointer camMatr2,
                            DoublePointer rotMatr2,
                            DoublePointer transVect2,
                            CvStereoLineCoeff coeffs,
                            IntPointer needSwapCameras);
public static native int icvComCoeffForLine(   @ByVal CvPoint2D64f point1,
                            @ByVal CvPoint2D64f point2,
                            @ByVal CvPoint2D64f point3,
                            @ByVal CvPoint2D64f point4,
                            DoubleBuffer camMatr1,
                            DoubleBuffer rotMatr1,
                            DoubleBuffer transVect1,
                            DoubleBuffer camMatr2,
                            DoubleBuffer rotMatr2,
                            DoubleBuffer transVect2,
                            CvStereoLineCoeff coeffs,
                            IntBuffer needSwapCameras);
public static native int icvComCoeffForLine(   @ByVal CvPoint2D64f point1,
                            @ByVal CvPoint2D64f point2,
                            @ByVal CvPoint2D64f point3,
                            @ByVal CvPoint2D64f point4,
                            double[] camMatr1,
                            double[] rotMatr1,
                            double[] transVect1,
                            double[] camMatr2,
                            double[] rotMatr2,
                            double[] transVect2,
                            CvStereoLineCoeff coeffs,
                            int[] needSwapCameras);

public static native int icvGetDirectionForPoint(  @ByVal CvPoint2D64f point,
                                DoublePointer camMatr,
                                CvPoint3D64f direct);
public static native int icvGetDirectionForPoint(  @ByVal CvPoint2D64f point,
                                DoubleBuffer camMatr,
                                CvPoint3D64f direct);
public static native int icvGetDirectionForPoint(  @ByVal CvPoint2D64f point,
                                double[] camMatr,
                                CvPoint3D64f direct);

public static native int icvGetCrossLines(@ByVal CvPoint3D64f point11,@ByVal CvPoint3D64f point12,
                       @ByVal CvPoint3D64f point21,@ByVal CvPoint3D64f point22,
                       CvPoint3D64f midPoint);

public static native int icvComputeStereoLineCoeffs(   @ByVal CvPoint3D64f pointA,
                                    @ByVal CvPoint3D64f pointB,
                                    @ByVal CvPoint3D64f pointCam1,
                                    double gamma,
                                    CvStereoLineCoeff coeffs);

/*CVAPI(int) icvComputeFundMatrEpipoles ( double* camMatr1,
                                    double*     rotMatr1,
                                    double*     transVect1,
                                    double*     camMatr2,
                                    double*     rotMatr2,
                                    double*     transVect2,
                                    CvPoint2D64f* epipole1,
                                    CvPoint2D64f* epipole2,
                                    double*     fundMatr);*/

public static native int icvGetAngleLine( @ByVal CvPoint2D64f startPoint, @ByVal CvSize imageSize,CvPoint2D64f point1,CvPoint2D64f point2);

public static native void icvGetCoefForPiece(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                        DoublePointer a,DoublePointer b,DoublePointer c,
                        IntPointer result);
public static native void icvGetCoefForPiece(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                        DoubleBuffer a,DoubleBuffer b,DoubleBuffer c,
                        IntBuffer result);
public static native void icvGetCoefForPiece(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                        double[] a,double[] b,double[] c,
                        int[] result);

/*CVAPI(void) icvGetCommonArea( CvSize imageSize,
                    CvPoint2D64f epipole1,CvPoint2D64f epipole2,
                    double* fundMatr,
                    double* coeff11,double* coeff12,
                    double* coeff21,double* coeff22,
                    int* result);*/

public static native void icvComputeeInfiniteProject1(DoublePointer rotMatr,
                                     DoublePointer camMatr1,
                                     DoublePointer camMatr2,
                                     @ByVal CvPoint2D32f point1,
                                     CvPoint2D32f point2);
public static native void icvComputeeInfiniteProject1(DoubleBuffer rotMatr,
                                     DoubleBuffer camMatr1,
                                     DoubleBuffer camMatr2,
                                     @ByVal CvPoint2D32f point1,
                                     CvPoint2D32f point2);
public static native void icvComputeeInfiniteProject1(double[] rotMatr,
                                     double[] camMatr1,
                                     double[] camMatr2,
                                     @ByVal CvPoint2D32f point1,
                                     CvPoint2D32f point2);

public static native void icvComputeeInfiniteProject2(DoublePointer rotMatr,
                                     DoublePointer camMatr1,
                                     DoublePointer camMatr2,
                                     CvPoint2D32f point1,
                                     @ByVal CvPoint2D32f point2);
public static native void icvComputeeInfiniteProject2(DoubleBuffer rotMatr,
                                     DoubleBuffer camMatr1,
                                     DoubleBuffer camMatr2,
                                     CvPoint2D32f point1,
                                     @ByVal CvPoint2D32f point2);
public static native void icvComputeeInfiniteProject2(double[] rotMatr,
                                     double[] camMatr1,
                                     double[] camMatr2,
                                     CvPoint2D32f point1,
                                     @ByVal CvPoint2D32f point2);

public static native void icvGetCrossDirectDirect(  DoublePointer direct1,DoublePointer direct2,
                            CvPoint2D64f cross,IntPointer result);
public static native void icvGetCrossDirectDirect(  DoubleBuffer direct1,DoubleBuffer direct2,
                            CvPoint2D64f cross,IntBuffer result);
public static native void icvGetCrossDirectDirect(  double[] direct1,double[] direct2,
                            CvPoint2D64f cross,int[] result);

public static native void icvGetCrossPieceDirect(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                            double a,double b,double c,
                            CvPoint2D64f cross,IntPointer result);
public static native void icvGetCrossPieceDirect(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                            double a,double b,double c,
                            CvPoint2D64f cross,IntBuffer result);
public static native void icvGetCrossPieceDirect(   @ByVal CvPoint2D64f p_start,@ByVal CvPoint2D64f p_end,
                            double a,double b,double c,
                            CvPoint2D64f cross,int[] result);

public static native void icvGetCrossPiecePiece( @ByVal CvPoint2D64f p1_start,@ByVal CvPoint2D64f p1_end,
                            @ByVal CvPoint2D64f p2_start,@ByVal CvPoint2D64f p2_end,
                            CvPoint2D64f cross,
                            IntPointer result);
public static native void icvGetCrossPiecePiece( @ByVal CvPoint2D64f p1_start,@ByVal CvPoint2D64f p1_end,
                            @ByVal CvPoint2D64f p2_start,@ByVal CvPoint2D64f p2_end,
                            CvPoint2D64f cross,
                            IntBuffer result);
public static native void icvGetCrossPiecePiece( @ByVal CvPoint2D64f p1_start,@ByVal CvPoint2D64f p1_end,
                            @ByVal CvPoint2D64f p2_start,@ByVal CvPoint2D64f p2_end,
                            CvPoint2D64f cross,
                            int[] result);

public static native void icvGetPieceLength(@ByVal CvPoint2D64f point1,@ByVal CvPoint2D64f point2,DoublePointer dist);
public static native void icvGetPieceLength(@ByVal CvPoint2D64f point1,@ByVal CvPoint2D64f point2,DoubleBuffer dist);
public static native void icvGetPieceLength(@ByVal CvPoint2D64f point1,@ByVal CvPoint2D64f point2,double[] dist);

public static native void icvGetCrossRectDirect(    @ByVal CvSize imageSize,
                            double a,double b,double c,
                            CvPoint2D64f start,CvPoint2D64f end,
                            IntPointer result);
public static native void icvGetCrossRectDirect(    @ByVal CvSize imageSize,
                            double a,double b,double c,
                            CvPoint2D64f start,CvPoint2D64f end,
                            IntBuffer result);
public static native void icvGetCrossRectDirect(    @ByVal CvSize imageSize,
                            double a,double b,double c,
                            CvPoint2D64f start,CvPoint2D64f end,
                            int[] result);

public static native void icvProjectPointToImage(   @ByVal CvPoint3D64f point,
                            DoublePointer camMatr,DoublePointer rotMatr,DoublePointer transVect,
                            CvPoint2D64f projPoint);
public static native void icvProjectPointToImage(   @ByVal CvPoint3D64f point,
                            DoubleBuffer camMatr,DoubleBuffer rotMatr,DoubleBuffer transVect,
                            CvPoint2D64f projPoint);
public static native void icvProjectPointToImage(   @ByVal CvPoint3D64f point,
                            double[] camMatr,double[] rotMatr,double[] transVect,
                            CvPoint2D64f projPoint);

public static native void icvGetQuadsTransform( @ByVal CvSize imageSize,
                        DoublePointer camMatr1,
                        DoublePointer rotMatr1,
                        DoublePointer transVect1,
                        DoublePointer camMatr2,
                        DoublePointer rotMatr2,
                        DoublePointer transVect2,
                        CvSize warpSize,
                        @Cast("double(*)[2]") DoublePointer quad1,
                        @Cast("double(*)[2]") DoublePointer quad2,
                        DoublePointer fundMatr,
                        CvPoint3D64f epipole1,
                        CvPoint3D64f epipole2
                        );
public static native void icvGetQuadsTransform( @ByVal CvSize imageSize,
                        DoubleBuffer camMatr1,
                        DoubleBuffer rotMatr1,
                        DoubleBuffer transVect1,
                        DoubleBuffer camMatr2,
                        DoubleBuffer rotMatr2,
                        DoubleBuffer transVect2,
                        CvSize warpSize,
                        @Cast("double(*)[2]") DoubleBuffer quad1,
                        @Cast("double(*)[2]") DoubleBuffer quad2,
                        DoubleBuffer fundMatr,
                        CvPoint3D64f epipole1,
                        CvPoint3D64f epipole2
                        );
public static native void icvGetQuadsTransform( @ByVal CvSize imageSize,
                        double[] camMatr1,
                        double[] rotMatr1,
                        double[] transVect1,
                        double[] camMatr2,
                        double[] rotMatr2,
                        double[] transVect2,
                        CvSize warpSize,
                        @Cast("double(*)[2]") double[] quad1,
                        @Cast("double(*)[2]") double[] quad2,
                        double[] fundMatr,
                        CvPoint3D64f epipole1,
                        CvPoint3D64f epipole2
                        );

public static native void icvGetQuadsTransformStruct(  CvStereoCamera stereoCamera);

public static native void icvComputeStereoParamsForCameras(CvStereoCamera stereoCamera);

public static native void icvGetCutPiece(   DoublePointer areaLineCoef1,DoublePointer areaLineCoef2,
                    @ByVal CvPoint2D64f epipole,
                    @ByVal CvSize imageSize,
                    CvPoint2D64f point11,CvPoint2D64f point12,
                    CvPoint2D64f point21,CvPoint2D64f point22,
                    IntPointer result);
public static native void icvGetCutPiece(   DoubleBuffer areaLineCoef1,DoubleBuffer areaLineCoef2,
                    @ByVal CvPoint2D64f epipole,
                    @ByVal CvSize imageSize,
                    CvPoint2D64f point11,CvPoint2D64f point12,
                    CvPoint2D64f point21,CvPoint2D64f point22,
                    IntBuffer result);
public static native void icvGetCutPiece(   double[] areaLineCoef1,double[] areaLineCoef2,
                    @ByVal CvPoint2D64f epipole,
                    @ByVal CvSize imageSize,
                    CvPoint2D64f point11,CvPoint2D64f point12,
                    CvPoint2D64f point21,CvPoint2D64f point22,
                    int[] result);

public static native void icvGetMiddleAnglePoint(   @ByVal CvPoint2D64f basePoint,
                            @ByVal CvPoint2D64f point1,@ByVal CvPoint2D64f point2,
                            CvPoint2D64f midPoint);

public static native void icvGetNormalDirect(DoublePointer direct,@ByVal CvPoint2D64f point,DoublePointer normDirect);
public static native void icvGetNormalDirect(DoubleBuffer direct,@ByVal CvPoint2D64f point,DoubleBuffer normDirect);
public static native void icvGetNormalDirect(double[] direct,@ByVal CvPoint2D64f point,double[] normDirect);

public static native double icvGetVect(@ByVal CvPoint2D64f basePoint,@ByVal CvPoint2D64f point1,@ByVal CvPoint2D64f point2);

public static native void icvProjectPointToDirect(  @ByVal CvPoint2D64f point,DoublePointer lineCoeff,
                            CvPoint2D64f projectPoint);
public static native void icvProjectPointToDirect(  @ByVal CvPoint2D64f point,DoubleBuffer lineCoeff,
                            CvPoint2D64f projectPoint);
public static native void icvProjectPointToDirect(  @ByVal CvPoint2D64f point,double[] lineCoeff,
                            CvPoint2D64f projectPoint);

public static native void icvGetDistanceFromPointToDirect( @ByVal CvPoint2D64f point,DoublePointer lineCoef,DoublePointer dist);
public static native void icvGetDistanceFromPointToDirect( @ByVal CvPoint2D64f point,DoubleBuffer lineCoef,DoubleBuffer dist);
public static native void icvGetDistanceFromPointToDirect( @ByVal CvPoint2D64f point,double[] lineCoef,double[] dist);

public static native IplImage icvCreateIsometricImage( IplImage src, IplImage dst,
                              int desired_depth, int desired_num_channels );

public static native void cvDeInterlace( @Const CvArr frame, CvArr fieldEven, CvArr fieldOdd );

/*CVAPI(int) icvSelectBestRt(           int           numImages,
                                    int*          numPoints,
                                    CvSize        imageSize,
                                    CvPoint2D32f* imagePoints1,
                                    CvPoint2D32f* imagePoints2,
                                    CvPoint3D32f* objectPoints,

                                    CvMatr32f     cameraMatrix1,
                                    CvVect32f     distortion1,
                                    CvMatr32f     rotMatrs1,
                                    CvVect32f     transVects1,

                                    CvMatr32f     cameraMatrix2,
                                    CvVect32f     distortion2,
                                    CvMatr32f     rotMatrs2,
                                    CvVect32f     transVects2,

                                    CvMatr32f     bestRotMatr,
                                    CvVect32f     bestTransVect
                                    );*/


/****************************************************************************************\
*                                     Contour Tree                                       *
\****************************************************************************************/

/* Contour tree header */
public static class CvContourTree extends CvSeq {
    static { Loader.load(); }
    public CvContourTree() { allocate(); }
    public CvContourTree(int size) { allocateArray(size); }
    public CvContourTree(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvContourTree position(int position) {
        return (CvContourTree)super.position(position);
    }

    public native int flags(); public native CvContourTree flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvContourTree header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvContourTree h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvContourTree h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvContourTree v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvContourTree v_next(CvSeq v_next);                                           
    public native int total(); public native CvContourTree total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvContourTree elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvContourTree block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvContourTree ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvContourTree delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvContourTree storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvContourTree free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvContourTree first(CvSeqBlock first);        /* Pointer to the first sequence block. */
    public native @ByVal CvPoint p1(); public native CvContourTree p1(CvPoint p1);            /* the first point of the binary tree root segment */
    public native @ByVal CvPoint p2(); public native CvContourTree p2(CvPoint p2);            /* the last point of the binary tree root segment */
}

/* Builds hierarhical representation of a contour */
public static native CvContourTree cvCreateContourTree( @Const CvSeq contour,
                                            CvMemStorage storage,
                                            double threshold );

/* Reconstruct (completelly or partially) contour a from contour tree */
public static native CvSeq cvContourFromContourTree( @Const CvContourTree tree,
                                         CvMemStorage storage,
                                         @ByVal CvTermCriteria criteria );

/* Compares two contour trees */
/** enum  */
public static final int CV_CONTOUR_TREES_MATCH_I1 = 1;

public static native double cvMatchContourTrees( @Const CvContourTree tree1,
                                    @Const CvContourTree tree2,
                                    int method, double threshold );

/****************************************************************************************\
*                                   Contour Morphing                                     *
\****************************************************************************************/

/* finds correspondence between two contours */
public static native CvSeq cvCalcContoursCorrespondence( @Const CvSeq contour1,
                                     @Const CvSeq contour2,
                                     CvMemStorage storage);

/* morphs contours using the pre-calculated correspondence:
   alpha=0 ~ contour1, alpha=1 ~ contour2 */
public static native CvSeq cvMorphContours( @Const CvSeq contour1, @Const CvSeq contour2,
                        CvSeq corr, double alpha,
                        CvMemStorage storage );


/****************************************************************************************\
*                                   Active Contours                                      *
\****************************************************************************************/

public static final int CV_VALUE =  1;
public static final int CV_ARRAY =  2;
/* Updates active contour in order to minimize its cummulative
   (internal and external) energy. */
public static native void cvSnakeImage( @Const IplImage image, CvPoint points,
                           int length, FloatPointer alpha,
                           FloatPointer beta, FloatPointer gamma,
                           int coeff_usage, @ByVal CvSize win,
                           @ByVal CvTermCriteria criteria, int calc_gradient/*CV_DEFAULT(1)*/);
public static native void cvSnakeImage( @Const IplImage image, CvPoint points,
                           int length, FloatBuffer alpha,
                           FloatBuffer beta, FloatBuffer gamma,
                           int coeff_usage, @ByVal CvSize win,
                           @ByVal CvTermCriteria criteria, int calc_gradient/*CV_DEFAULT(1)*/);
public static native void cvSnakeImage( @Const IplImage image, CvPoint points,
                           int length, float[] alpha,
                           float[] beta, float[] gamma,
                           int coeff_usage, @ByVal CvSize win,
                           @ByVal CvTermCriteria criteria, int calc_gradient/*CV_DEFAULT(1)*/);

/****************************************************************************************\
*                                    Texture Descriptors                                 *
\****************************************************************************************/

public static final int CV_GLCM_OPTIMIZATION_NONE =                   -2;
public static final int CV_GLCM_OPTIMIZATION_LUT =                    -1;
public static final int CV_GLCM_OPTIMIZATION_HISTOGRAM =              0;

public static final int CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST =    10;
public static final int CV_GLCMDESC_OPTIMIZATION_ALLOWTRIPLENEST =    11;
public static final int CV_GLCMDESC_OPTIMIZATION_HISTOGRAM =          4;

public static final int CV_GLCMDESC_ENTROPY =                         0;
public static final int CV_GLCMDESC_ENERGY =                          1;
public static final int CV_GLCMDESC_HOMOGENITY =                      2;
public static final int CV_GLCMDESC_CONTRAST =                        3;
public static final int CV_GLCMDESC_CLUSTERTENDENCY =                 4;
public static final int CV_GLCMDESC_CLUSTERSHADE =                    5;
public static final int CV_GLCMDESC_CORRELATION =                     6;
public static final int CV_GLCMDESC_CORRELATIONINFO1 =                7;
public static final int CV_GLCMDESC_CORRELATIONINFO2 =                8;
public static final int CV_GLCMDESC_MAXIMUMPROBABILITY =              9;

public static final int CV_GLCM_ALL =                                 0;
public static final int CV_GLCM_GLCM =                                1;
public static final int CV_GLCM_DESC =                                2;

@Opaque public static class CvGLCM extends Pointer {
    public CvGLCM() { }
    public CvGLCM(Pointer p) { super(p); }
}

public static native CvGLCM cvCreateGLCM( @Const IplImage srcImage,
                                int stepMagnitude,
                                @Const IntPointer stepDirections/*CV_DEFAULT(0)*/,
                                int numStepDirections/*CV_DEFAULT(0)*/,
                                int optimizationType/*CV_DEFAULT(CV_GLCM_OPTIMIZATION_NONE)*/);
public static native CvGLCM cvCreateGLCM( @Const IplImage srcImage,
                                int stepMagnitude,
                                @Const IntBuffer stepDirections/*CV_DEFAULT(0)*/,
                                int numStepDirections/*CV_DEFAULT(0)*/,
                                int optimizationType/*CV_DEFAULT(CV_GLCM_OPTIMIZATION_NONE)*/);
public static native CvGLCM cvCreateGLCM( @Const IplImage srcImage,
                                int stepMagnitude,
                                @Const int[] stepDirections/*CV_DEFAULT(0)*/,
                                int numStepDirections/*CV_DEFAULT(0)*/,
                                int optimizationType/*CV_DEFAULT(CV_GLCM_OPTIMIZATION_NONE)*/);

public static native void cvReleaseGLCM( @Cast("CvGLCM**") PointerPointer GLCM, int flag/*CV_DEFAULT(CV_GLCM_ALL)*/);
public static native void cvReleaseGLCM( @ByPtrPtr CvGLCM GLCM, int flag/*CV_DEFAULT(CV_GLCM_ALL)*/);

public static native void cvCreateGLCMDescriptors( CvGLCM destGLCM,
                                        int descriptorOptimizationType/*CV_DEFAULT(CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST)*/);

public static native double cvGetGLCMDescriptor( CvGLCM GLCM, int step, int descriptor );

public static native void cvGetGLCMDescriptorStatistics( CvGLCM GLCM, int descriptor,
                                              DoublePointer average, DoublePointer standardDeviation );
public static native void cvGetGLCMDescriptorStatistics( CvGLCM GLCM, int descriptor,
                                              DoubleBuffer average, DoubleBuffer standardDeviation );
public static native void cvGetGLCMDescriptorStatistics( CvGLCM GLCM, int descriptor,
                                              double[] average, double[] standardDeviation );

public static native IplImage cvCreateGLCMImage( CvGLCM GLCM, int step );

/****************************************************************************************\
*                                  Face eyes&mouth tracking                              *
\****************************************************************************************/


@Opaque public static class CvFaceTracker extends Pointer {
    public CvFaceTracker() { }
    public CvFaceTracker(Pointer p) { super(p); }
}

public static final int CV_NUM_FACE_ELEMENTS =    3;
/** enum CV_FACE_ELEMENTS */
public static final int
    CV_FACE_MOUTH = 0,
    CV_FACE_LEFT_EYE = 1,
    CV_FACE_RIGHT_EYE = 2;

public static native CvFaceTracker cvInitFaceTracker(CvFaceTracker pFaceTracking, @Const IplImage imgGray,
                                                CvRect pRects, int nRects);
public static native int cvTrackFace( CvFaceTracker pFaceTracker, IplImage imgGray,
                              CvRect pRects, int nRects,
                              CvPoint ptRotate, DoublePointer dbAngleRotate);
public static native int cvTrackFace( CvFaceTracker pFaceTracker, IplImage imgGray,
                              CvRect pRects, int nRects,
                              CvPoint ptRotate, DoubleBuffer dbAngleRotate);
public static native int cvTrackFace( CvFaceTracker pFaceTracker, IplImage imgGray,
                              CvRect pRects, int nRects,
                              CvPoint ptRotate, double[] dbAngleRotate);
public static native void cvReleaseFaceTracker(@Cast("CvFaceTracker**") PointerPointer ppFaceTracker);
public static native void cvReleaseFaceTracker(@ByPtrPtr CvFaceTracker ppFaceTracker);


public static class CvFaceData extends Pointer {
    static { Loader.load(); }
    public CvFaceData() { allocate(); }
    public CvFaceData(int size) { allocateArray(size); }
    public CvFaceData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvFaceData position(int position) {
        return (CvFaceData)super.position(position);
    }

    public native @ByVal CvRect MouthRect(); public native CvFaceData MouthRect(CvRect MouthRect);
    public native @ByVal CvRect LeftEyeRect(); public native CvFaceData LeftEyeRect(CvRect LeftEyeRect);
    public native @ByVal CvRect RightEyeRect(); public native CvFaceData RightEyeRect(CvRect RightEyeRect);
}

public static native CvSeq cvFindFace(IplImage Image,CvMemStorage storage);
public static native CvSeq cvPostBoostingFindFace(IplImage Image,CvMemStorage storage);


/****************************************************************************************\
*                                         3D Tracker                                     *
\****************************************************************************************/

public static class Cv3dTracker2dTrackedObject extends Pointer {
    static { Loader.load(); }
    public Cv3dTracker2dTrackedObject() { allocate(); }
    public Cv3dTracker2dTrackedObject(int size) { allocateArray(size); }
    public Cv3dTracker2dTrackedObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv3dTracker2dTrackedObject position(int position) {
        return (Cv3dTracker2dTrackedObject)super.position(position);
    }

    public native int id(); public native Cv3dTracker2dTrackedObject id(int id);
    public native @ByVal CvPoint2D32f p(); public native Cv3dTracker2dTrackedObject p(CvPoint2D32f p); // pgruebele: So we do not loose precision, this needs to be float
}

public static native @ByVal Cv3dTracker2dTrackedObject cv3dTracker2dTrackedObject(int id, @ByVal CvPoint2D32f p);

public static class Cv3dTrackerTrackedObject extends Pointer {
    static { Loader.load(); }
    public Cv3dTrackerTrackedObject() { allocate(); }
    public Cv3dTrackerTrackedObject(int size) { allocateArray(size); }
    public Cv3dTrackerTrackedObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv3dTrackerTrackedObject position(int position) {
        return (Cv3dTrackerTrackedObject)super.position(position);
    }

    public native int id(); public native Cv3dTrackerTrackedObject id(int id);
    public native @ByVal CvPoint3D32f p(); public native Cv3dTrackerTrackedObject p(CvPoint3D32f p);             // location of the tracked object
}

public static native @ByVal Cv3dTrackerTrackedObject cv3dTrackerTrackedObject(int id, @ByVal CvPoint3D32f p);

public static class Cv3dTrackerCameraInfo extends Pointer {
    static { Loader.load(); }
    public Cv3dTrackerCameraInfo() { allocate(); }
    public Cv3dTrackerCameraInfo(int size) { allocateArray(size); }
    public Cv3dTrackerCameraInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv3dTrackerCameraInfo position(int position) {
        return (Cv3dTrackerCameraInfo)super.position(position);
    }

    public native @Cast("CvBool") byte valid(); public native Cv3dTrackerCameraInfo valid(byte valid);
    public native float mat(int i, int j); public native Cv3dTrackerCameraInfo mat(int i, int j, float mat);
    @MemberGetter public native @Cast("float(*)[4]") FloatPointer mat();              /* maps camera coordinates to world coordinates */
    public native @ByVal CvPoint2D32f principal_point(); public native Cv3dTrackerCameraInfo principal_point(CvPoint2D32f principal_point); /* copied from intrinsics so this structure */
                                  /* has all the info we need */
}

public static class Cv3dTrackerCameraIntrinsics extends Pointer {
    static { Loader.load(); }
    public Cv3dTrackerCameraIntrinsics() { allocate(); }
    public Cv3dTrackerCameraIntrinsics(int size) { allocateArray(size); }
    public Cv3dTrackerCameraIntrinsics(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public Cv3dTrackerCameraIntrinsics position(int position) {
        return (Cv3dTrackerCameraIntrinsics)super.position(position);
    }

    public native @ByVal CvPoint2D32f principal_point(); public native Cv3dTrackerCameraIntrinsics principal_point(CvPoint2D32f principal_point);
    public native float focal_length(int i); public native Cv3dTrackerCameraIntrinsics focal_length(int i, float focal_length);
    @MemberGetter public native FloatPointer focal_length();
    public native float distortion(int i); public native Cv3dTrackerCameraIntrinsics distortion(int i, float distortion);
    @MemberGetter public native FloatPointer distortion();
}

public static native @Cast("CvBool") byte cv3dTrackerCalibrateCameras(int num_cameras,
                     @Const Cv3dTrackerCameraIntrinsics camera_intrinsics,
                     @ByVal CvSize etalon_size,
                     float square_size,
                     @Cast("IplImage**") PointerPointer samples,
                     Cv3dTrackerCameraInfo camera_info);
public static native @Cast("CvBool") byte cv3dTrackerCalibrateCameras(int num_cameras,
                     @Const Cv3dTrackerCameraIntrinsics camera_intrinsics,
                     @ByVal CvSize etalon_size,
                     float square_size,
                     @ByPtrPtr IplImage samples,
                     Cv3dTrackerCameraInfo camera_info);                  /* size is num_cameras */

public static native int cv3dTrackerLocateObjects(int num_cameras, int num_objects,
                   @Const Cv3dTrackerCameraInfo camera_info,
                   @Const Cv3dTracker2dTrackedObject tracking_info,
                   Cv3dTrackerTrackedObject tracked_objects);      /* size is num_objects */
/****************************************************************************************
 tracking_info is a rectangular array; one row per camera, num_objects elements per row.
 The id field of any unused slots must be -1. Ids need not be ordered or consecutive. On
 completion, the return value is the number of objects located; i.e., the number of objects
 visible by more than one camera. The id field of any unused slots in tracked objects is
 set to -1.
****************************************************************************************/


/****************************************************************************************\
*                           Skeletons and Linear-Contour Models                          *
\****************************************************************************************/

/** enum CvLeeParameters */
public static final int
    CV_LEE_INT = 0,
    CV_LEE_FLOAT = 1,
    CV_LEE_DOUBLE = 2,
    CV_LEE_AUTO = -1,
    CV_LEE_ERODE = 0,
    CV_LEE_ZOOM = 1,
    CV_LEE_NON = 2;

// #define CV_NEXT_VORONOISITE2D( SITE ) ((SITE)->edge[0]->site[((SITE)->edge[0]->site[0] == (SITE))])
// #define CV_PREV_VORONOISITE2D( SITE ) ((SITE)->edge[1]->site[((SITE)->edge[1]->site[0] == (SITE))])
// #define CV_FIRST_VORONOIEDGE2D( SITE ) ((SITE)->edge[0])
// #define CV_LAST_VORONOIEDGE2D( SITE ) ((SITE)->edge[1])
// #define CV_NEXT_VORONOIEDGE2D( EDGE, SITE ) ((EDGE)->next[(EDGE)->site[0] != (SITE)])
// #define CV_PREV_VORONOIEDGE2D( EDGE, SITE ) ((EDGE)->next[2 + ((EDGE)->site[0] != (SITE))])
// #define CV_VORONOIEDGE2D_BEGINNODE( EDGE, SITE ) ((EDGE)->node[((EDGE)->site[0] != (SITE))])
// #define CV_VORONOIEDGE2D_ENDNODE( EDGE, SITE ) ((EDGE)->node[((EDGE)->site[0] == (SITE))])
// #define CV_TWIN_VORONOISITE2D( SITE, EDGE ) ( (EDGE)->site[((EDGE)->site[0] == (SITE))])

// #define CV_VORONOISITE2D_FIELDS()
//     struct CvVoronoiNode2D *node[2];
//     struct CvVoronoiEdge2D *edge[2];

public static class CvVoronoiSite2D extends Pointer {
    static { Loader.load(); }
    public CvVoronoiSite2D() { allocate(); }
    public CvVoronoiSite2D(int size) { allocateArray(size); }
    public CvVoronoiSite2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvVoronoiSite2D position(int position) {
        return (CvVoronoiSite2D)super.position(position);
    }

    public native CvVoronoiNode2D node(int i); public native CvVoronoiSite2D node(int i, CvVoronoiNode2D node);
    @MemberGetter public native @Cast("CvVoronoiNode2D**") PointerPointer node(); 
    public native CvVoronoiEdge2D edge(int i); public native CvVoronoiSite2D edge(int i, CvVoronoiEdge2D edge);
    @MemberGetter public native @Cast("CvVoronoiEdge2D**") PointerPointer edge();
    public native CvVoronoiSite2D next(int i); public native CvVoronoiSite2D next(int i, CvVoronoiSite2D next);
    @MemberGetter public native @Cast("CvVoronoiSite2D**") PointerPointer next();
}

// #define CV_VORONOIEDGE2D_FIELDS()
//     struct CvVoronoiNode2D *node[2];
//     struct CvVoronoiSite2D *site[2];
//     struct CvVoronoiEdge2D *next[4];

public static class CvVoronoiEdge2D extends Pointer {
    static { Loader.load(); }
    public CvVoronoiEdge2D() { allocate(); }
    public CvVoronoiEdge2D(int size) { allocateArray(size); }
    public CvVoronoiEdge2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvVoronoiEdge2D position(int position) {
        return (CvVoronoiEdge2D)super.position(position);
    }

    public native CvVoronoiNode2D node(int i); public native CvVoronoiEdge2D node(int i, CvVoronoiNode2D node);
    @MemberGetter public native @Cast("CvVoronoiNode2D**") PointerPointer node(); 
    public native CvVoronoiSite2D site(int i); public native CvVoronoiEdge2D site(int i, CvVoronoiSite2D site);
    @MemberGetter public native @Cast("CvVoronoiSite2D**") PointerPointer site(); 
    public native CvVoronoiEdge2D next(int i); public native CvVoronoiEdge2D next(int i, CvVoronoiEdge2D next);
    @MemberGetter public native @Cast("CvVoronoiEdge2D**") PointerPointer next();
}

// #define CV_VORONOINODE2D_FIELDS()
//     CV_SET_ELEM_FIELDS(CvVoronoiNode2D)
//     CvPoint2D32f pt;
//     float radius;

public static class CvVoronoiNode2D extends Pointer {
    static { Loader.load(); }
    public CvVoronoiNode2D() { allocate(); }
    public CvVoronoiNode2D(int size) { allocateArray(size); }
    public CvVoronoiNode2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvVoronoiNode2D position(int position) {
        return (CvVoronoiNode2D)super.position(position);
    }

    public native int flags(); public native CvVoronoiNode2D flags(int flags);                         
    public native CvVoronoiNode2D next_free(); public native CvVoronoiNode2D next_free(CvVoronoiNode2D next_free); 
    public native @ByVal CvPoint2D32f pt(); public native CvVoronoiNode2D pt(CvPoint2D32f pt);                    
    public native float radius(); public native CvVoronoiNode2D radius(float radius);
}

// #define CV_VORONOIDIAGRAM2D_FIELDS()
//     CV_GRAPH_FIELDS()
//     CvSet *sites;

public static class CvVoronoiDiagram2D extends Pointer {
    static { Loader.load(); }
    public CvVoronoiDiagram2D() { allocate(); }
    public CvVoronoiDiagram2D(int size) { allocateArray(size); }
    public CvVoronoiDiagram2D(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvVoronoiDiagram2D position(int position) {
        return (CvVoronoiDiagram2D)super.position(position);
    }

    public native int flags(); public native CvVoronoiDiagram2D flags(int flags);             /* Miscellaneous flags.     */      
    public native int header_size(); public native CvVoronoiDiagram2D header_size(int header_size);       /* Size of sequence header. */      
    public native CvSeq h_prev(); public native CvVoronoiDiagram2D h_prev(CvSeq h_prev); /* Previous sequence.       */      
    public native CvSeq h_next(); public native CvVoronoiDiagram2D h_next(CvSeq h_next); /* Next sequence.           */      
    public native CvSeq v_prev(); public native CvVoronoiDiagram2D v_prev(CvSeq v_prev); /* 2nd previous sequence.   */      
    public native CvSeq v_next(); public native CvVoronoiDiagram2D v_next(CvSeq v_next);                                           
    public native int total(); public native CvVoronoiDiagram2D total(int total);          /* Total number of elements.            */  
    public native int elem_size(); public native CvVoronoiDiagram2D elem_size(int elem_size);      /* Size of sequence element in bytes.   */  
    public native @Cast("schar*") BytePointer block_max(); public native CvVoronoiDiagram2D block_max(BytePointer block_max);      /* Maximal bound of the last block.     */  
    public native @Cast("schar*") BytePointer ptr(); public native CvVoronoiDiagram2D ptr(BytePointer ptr);            /* Current write pointer.               */  
    public native int delta_elems(); public native CvVoronoiDiagram2D delta_elems(int delta_elems);    /* Grow seq this many at a time.        */  
    public native CvMemStorage storage(); public native CvVoronoiDiagram2D storage(CvMemStorage storage);    /* Where the seq is stored.             */  
    public native CvSeqBlock free_blocks(); public native CvVoronoiDiagram2D free_blocks(CvSeqBlock free_blocks);  /* Free blocks list.                    */  
    public native CvSeqBlock first(); public native CvVoronoiDiagram2D first(CvSeqBlock first);        /* Pointer to the first sequence block. */     
    public native CvSetElem free_elems(); public native CvVoronoiDiagram2D free_elems(CvSetElem free_elems);   
    public native int active_count(); public native CvVoronoiDiagram2D active_count(int active_count);          
    public native CvSet edges(); public native CvVoronoiDiagram2D edges(CvSet edges);                
    public native CvSet sites(); public native CvVoronoiDiagram2D sites(CvSet sites);
}

/* Computes Voronoi Diagram for given polygons with holes */
public static native int cvVoronoiDiagramFromContour(CvSeq ContourSeq,
                                           @Cast("CvVoronoiDiagram2D**") PointerPointer VoronoiDiagram,
                                           CvMemStorage VoronoiStorage,
                                           @Cast("CvLeeParameters") int contour_type/*CV_DEFAULT(CV_LEE_INT)*/,
                                           int contour_orientation/*CV_DEFAULT(-1)*/,
                                           int attempt_number/*CV_DEFAULT(10)*/);
public static native int cvVoronoiDiagramFromContour(CvSeq ContourSeq,
                                           @ByPtrPtr CvVoronoiDiagram2D VoronoiDiagram,
                                           CvMemStorage VoronoiStorage,
                                           @Cast("CvLeeParameters") int contour_type/*CV_DEFAULT(CV_LEE_INT)*/,
                                           int contour_orientation/*CV_DEFAULT(-1)*/,
                                           int attempt_number/*CV_DEFAULT(10)*/);

/* Computes Voronoi Diagram for domains in given image */
public static native int cvVoronoiDiagramFromImage(IplImage pImage,
                                         @Cast("CvSeq**") PointerPointer ContourSeq,
                                         @Cast("CvVoronoiDiagram2D**") PointerPointer VoronoiDiagram,
                                         CvMemStorage VoronoiStorage,
                                         @Cast("CvLeeParameters") int regularization_method/*CV_DEFAULT(CV_LEE_NON)*/,
                                         float approx_precision/*CV_DEFAULT(CV_LEE_AUTO)*/);
public static native int cvVoronoiDiagramFromImage(IplImage pImage,
                                         @ByPtrPtr CvSeq ContourSeq,
                                         @ByPtrPtr CvVoronoiDiagram2D VoronoiDiagram,
                                         CvMemStorage VoronoiStorage,
                                         @Cast("CvLeeParameters") int regularization_method/*CV_DEFAULT(CV_LEE_NON)*/,
                                         float approx_precision/*CV_DEFAULT(CV_LEE_AUTO)*/);

/* Deallocates the storage */
public static native void cvReleaseVoronoiStorage(CvVoronoiDiagram2D VoronoiDiagram,
                                          @Cast("CvMemStorage**") PointerPointer pVoronoiStorage);
public static native void cvReleaseVoronoiStorage(CvVoronoiDiagram2D VoronoiDiagram,
                                          @ByPtrPtr CvMemStorage pVoronoiStorage);

/*********************** Linear-Contour Model ****************************/

public static class CvLCMEdge extends Pointer {
    static { Loader.load(); }
    public CvLCMEdge() { allocate(); }
    public CvLCMEdge(int size) { allocateArray(size); }
    public CvLCMEdge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLCMEdge position(int position) {
        return (CvLCMEdge)super.position(position);
    }

    public native int flags(); public native CvLCMEdge flags(int flags);                      
    public native float weight(); public native CvLCMEdge weight(float weight);                   
    public native CvGraphEdge next(int i); public native CvLCMEdge next(int i, CvGraphEdge next);
    @MemberGetter public native @Cast("CvGraphEdge**") PointerPointer next();    
    public native CvGraphVtx vtx(int i); public native CvLCMEdge vtx(int i, CvGraphVtx vtx);
    @MemberGetter public native @Cast("CvGraphVtx**") PointerPointer vtx();
    public native CvSeq chain(); public native CvLCMEdge chain(CvSeq chain);
    public native float width(); public native CvLCMEdge width(float width);
    public native int index1(); public native CvLCMEdge index1(int index1);
    public native int index2(); public native CvLCMEdge index2(int index2);
}

public static class CvLCMNode extends Pointer {
    static { Loader.load(); }
    public CvLCMNode() { allocate(); }
    public CvLCMNode(int size) { allocateArray(size); }
    public CvLCMNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvLCMNode position(int position) {
        return (CvLCMNode)super.position(position);
    }

    public native int flags(); public native CvLCMNode flags(int flags);                      
    public native CvGraphEdge first(); public native CvLCMNode first(CvGraphEdge first);
    public native CvContour contour(); public native CvLCMNode contour(CvContour contour);
}


/* Computes hybrid model from Voronoi Diagram */
public static native CvGraph cvLinearContorModelFromVoronoiDiagram(CvVoronoiDiagram2D VoronoiDiagram,
                                                         float maxWidth);

/* Releases hybrid model storage */
public static native int cvReleaseLinearContorModelStorage(@Cast("CvGraph**") PointerPointer Graph);
public static native int cvReleaseLinearContorModelStorage(@ByPtrPtr CvGraph Graph);


/* two stereo-related functions */

public static native void cvInitPerspectiveTransform( @ByVal CvSize size, @Const CvPoint2D32f vertex, @Cast("double(*)[3]") DoublePointer matrix,
                                              CvArr rectMap );
public static native void cvInitPerspectiveTransform( @ByVal CvSize size, @Const CvPoint2D32f vertex, @Cast("double(*)[3]") DoubleBuffer matrix,
                                              CvArr rectMap );
public static native void cvInitPerspectiveTransform( @ByVal CvSize size, @Const CvPoint2D32f vertex, @Cast("double(*)[3]") double[] matrix,
                                              CvArr rectMap );

/*CVAPI(void) cvInitStereoRectification( CvStereoCamera* params,
                                             CvArr* rectMap1, CvArr* rectMap2,
                                             int do_undistortion );*/

/*************************** View Morphing Functions ************************/

public static class CvMatrix3 extends Pointer {
    static { Loader.load(); }
    public CvMatrix3() { allocate(); }
    public CvMatrix3(int size) { allocateArray(size); }
    public CvMatrix3(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvMatrix3 position(int position) {
        return (CvMatrix3)super.position(position);
    }

    public native float m(int i, int j); public native CvMatrix3 m(int i, int j, float m);
    @MemberGetter public native @Cast("float(*)[3]") FloatPointer m();
}

/* The order of the function corresponds to the order they should appear in
   the view morphing pipeline */

/* Finds ending points of scanlines on left and right images of stereo-pair */
public static native void cvMakeScanlines( @Const CvMatrix3 matrix, @ByVal CvSize img_size,
                              IntPointer scanlines1, IntPointer scanlines2,
                              IntPointer lengths1, IntPointer lengths2,
                              IntPointer line_count );
public static native void cvMakeScanlines( @Const CvMatrix3 matrix, @ByVal CvSize img_size,
                              IntBuffer scanlines1, IntBuffer scanlines2,
                              IntBuffer lengths1, IntBuffer lengths2,
                              IntBuffer line_count );
public static native void cvMakeScanlines( @Const CvMatrix3 matrix, @ByVal CvSize img_size,
                              int[] scanlines1, int[] scanlines2,
                              int[] lengths1, int[] lengths2,
                              int[] line_count );

/* Grab pixel values from scanlines and stores them sequentially
   (some sort of perspective image transform) */
public static native void cvPreWarpImage( int line_count,
                             IplImage img,
                             @Cast("uchar*") BytePointer dst,
                             IntPointer dst_nums,
                             IntPointer scanlines);
public static native void cvPreWarpImage( int line_count,
                             IplImage img,
                             @Cast("uchar*") ByteBuffer dst,
                             IntBuffer dst_nums,
                             IntBuffer scanlines);
public static native void cvPreWarpImage( int line_count,
                             IplImage img,
                             @Cast("uchar*") byte[] dst,
                             int[] dst_nums,
                             int[] scanlines);

/* Approximate each grabbed scanline by a sequence of runs
   (lossy run-length compression) */
public static native void cvFindRuns( int line_count,
                         @Cast("uchar*") BytePointer prewarp1,
                         @Cast("uchar*") BytePointer prewarp2,
                         IntPointer line_lengths1,
                         IntPointer line_lengths2,
                         IntPointer runs1,
                         IntPointer runs2,
                         IntPointer num_runs1,
                         IntPointer num_runs2);
public static native void cvFindRuns( int line_count,
                         @Cast("uchar*") ByteBuffer prewarp1,
                         @Cast("uchar*") ByteBuffer prewarp2,
                         IntBuffer line_lengths1,
                         IntBuffer line_lengths2,
                         IntBuffer runs1,
                         IntBuffer runs2,
                         IntBuffer num_runs1,
                         IntBuffer num_runs2);
public static native void cvFindRuns( int line_count,
                         @Cast("uchar*") byte[] prewarp1,
                         @Cast("uchar*") byte[] prewarp2,
                         int[] line_lengths1,
                         int[] line_lengths2,
                         int[] runs1,
                         int[] runs2,
                         int[] num_runs1,
                         int[] num_runs2);

/* Compares two sets of compressed scanlines */
public static native void cvDynamicCorrespondMulti( int line_count,
                                       IntPointer first,
                                       IntPointer first_runs,
                                       IntPointer second,
                                       IntPointer second_runs,
                                       IntPointer first_corr,
                                       IntPointer second_corr);
public static native void cvDynamicCorrespondMulti( int line_count,
                                       IntBuffer first,
                                       IntBuffer first_runs,
                                       IntBuffer second,
                                       IntBuffer second_runs,
                                       IntBuffer first_corr,
                                       IntBuffer second_corr);
public static native void cvDynamicCorrespondMulti( int line_count,
                                       int[] first,
                                       int[] first_runs,
                                       int[] second,
                                       int[] second_runs,
                                       int[] first_corr,
                                       int[] second_corr);

/* Finds scanline ending coordinates for some intermediate "virtual" camera position */
public static native void cvMakeAlphaScanlines( IntPointer scanlines1,
                                   IntPointer scanlines2,
                                   IntPointer scanlinesA,
                                   IntPointer lengths,
                                   int line_count,
                                   float alpha);
public static native void cvMakeAlphaScanlines( IntBuffer scanlines1,
                                   IntBuffer scanlines2,
                                   IntBuffer scanlinesA,
                                   IntBuffer lengths,
                                   int line_count,
                                   float alpha);
public static native void cvMakeAlphaScanlines( int[] scanlines1,
                                   int[] scanlines2,
                                   int[] scanlinesA,
                                   int[] lengths,
                                   int line_count,
                                   float alpha);

/* Blends data of the left and right image scanlines to get
   pixel values of "virtual" image scanlines */
public static native void cvMorphEpilinesMulti( int line_count,
                                   @Cast("uchar*") BytePointer first_pix,
                                   IntPointer first_num,
                                   @Cast("uchar*") BytePointer second_pix,
                                   IntPointer second_num,
                                   @Cast("uchar*") BytePointer dst_pix,
                                   IntPointer dst_num,
                                   float alpha,
                                   IntPointer first,
                                   IntPointer first_runs,
                                   IntPointer second,
                                   IntPointer second_runs,
                                   IntPointer first_corr,
                                   IntPointer second_corr);
public static native void cvMorphEpilinesMulti( int line_count,
                                   @Cast("uchar*") ByteBuffer first_pix,
                                   IntBuffer first_num,
                                   @Cast("uchar*") ByteBuffer second_pix,
                                   IntBuffer second_num,
                                   @Cast("uchar*") ByteBuffer dst_pix,
                                   IntBuffer dst_num,
                                   float alpha,
                                   IntBuffer first,
                                   IntBuffer first_runs,
                                   IntBuffer second,
                                   IntBuffer second_runs,
                                   IntBuffer first_corr,
                                   IntBuffer second_corr);
public static native void cvMorphEpilinesMulti( int line_count,
                                   @Cast("uchar*") byte[] first_pix,
                                   int[] first_num,
                                   @Cast("uchar*") byte[] second_pix,
                                   int[] second_num,
                                   @Cast("uchar*") byte[] dst_pix,
                                   int[] dst_num,
                                   float alpha,
                                   int[] first,
                                   int[] first_runs,
                                   int[] second,
                                   int[] second_runs,
                                   int[] first_corr,
                                   int[] second_corr);

/* Does reverse warping of the morphing result to make
   it fill the destination image rectangle */
public static native void cvPostWarpImage( int line_count,
                              @Cast("uchar*") BytePointer src,
                              IntPointer src_nums,
                              IplImage img,
                              IntPointer scanlines);
public static native void cvPostWarpImage( int line_count,
                              @Cast("uchar*") ByteBuffer src,
                              IntBuffer src_nums,
                              IplImage img,
                              IntBuffer scanlines);
public static native void cvPostWarpImage( int line_count,
                              @Cast("uchar*") byte[] src,
                              int[] src_nums,
                              IplImage img,
                              int[] scanlines);

/* Deletes Moire (missed pixels that appear due to discretization) */
public static native void cvDeleteMoire( IplImage img );


public static class CvConDensation extends Pointer {
    static { Loader.load(); }
    public CvConDensation() { allocate(); }
    public CvConDensation(int size) { allocateArray(size); }
    public CvConDensation(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvConDensation position(int position) {
        return (CvConDensation)super.position(position);
    }

    public native int MP(); public native CvConDensation MP(int MP);
    public native int DP(); public native CvConDensation DP(int DP);
    public native FloatPointer DynamMatr(); public native CvConDensation DynamMatr(FloatPointer DynamMatr);       /* Matrix of the linear Dynamics system  */
    public native FloatPointer State(); public native CvConDensation State(FloatPointer State);           /* Vector of State                       */
    public native int SamplesNum(); public native CvConDensation SamplesNum(int SamplesNum);         /* Number of the Samples                 */
    public native FloatPointer flSamples(int i); public native CvConDensation flSamples(int i, FloatPointer flSamples);
    @MemberGetter public native @Cast("float**") PointerPointer flSamples();      /* arr of the Sample Vectors             */
    public native FloatPointer flNewSamples(int i); public native CvConDensation flNewSamples(int i, FloatPointer flNewSamples);
    @MemberGetter public native @Cast("float**") PointerPointer flNewSamples();   /* temporary array of the Sample Vectors */
    public native FloatPointer flConfidence(); public native CvConDensation flConfidence(FloatPointer flConfidence);    /* Confidence for each Sample            */
    public native FloatPointer flCumulative(); public native CvConDensation flCumulative(FloatPointer flCumulative);    /* Cumulative confidence                 */
    public native FloatPointer Temp(); public native CvConDensation Temp(FloatPointer Temp);            /* Temporary vector                      */
    public native FloatPointer RandomSample(); public native CvConDensation RandomSample(FloatPointer RandomSample);    /* RandomVector to update sample set     */
    public native CvRandState RandS(); public native CvConDensation RandS(CvRandState RandS); /* Array of structures to generate random vectors */
}

/* Creates ConDensation filter state */
public static native CvConDensation cvCreateConDensation( int dynam_params,
                                             int measure_params,
                                             int sample_count );

/* Releases ConDensation filter state */
public static native void cvReleaseConDensation( @Cast("CvConDensation**") PointerPointer condens );
public static native void cvReleaseConDensation( @ByPtrPtr CvConDensation condens );

/* Updates ConDensation filter by time (predict future state of the system) */
public static native void cvConDensUpdateByTime( CvConDensation condens);

/* Initializes ConDensation filter samples  */
public static native void cvConDensInitSampleSet( CvConDensation condens, CvMat lower_bound, CvMat upper_bound );

public static native int iplWidth( @Const IplImage img );

public static native int iplHeight( @Const IplImage img );

// #ifdef __cplusplus
// #endif

// #ifdef __cplusplus

// #endif

// #ifdef __cplusplus
// #endif

/* Splits color or grayscale image into multiple connected components
 of nearly the same color/brightness using modification of Burt algorithm.
 comp with contain a pointer to sequence (CvSeq)
 of connected components (CvConnectedComp) */
public static native void cvPyrSegmentation( IplImage src, IplImage dst,
                              CvMemStorage storage, @Cast("CvSeq**") PointerPointer comp,
                              int level, double threshold1,
                              double threshold2 );
public static native void cvPyrSegmentation( IplImage src, IplImage dst,
                              CvMemStorage storage, @ByPtrPtr CvSeq comp,
                              int level, double threshold1,
                              double threshold2 );

/****************************************************************************************\
*                              Planar subdivisions                                       *
\****************************************************************************************/

/* Initializes Delaunay triangulation */
public static native void cvInitSubdivDelaunay2D( CvSubdiv2D subdiv, @ByVal CvRect rect );

/* Creates new subdivision */
public static native CvSubdiv2D cvCreateSubdiv2D( int subdiv_type, int header_size,
                                     int vtx_size, int quadedge_size,
                                     CvMemStorage storage );

/************************* high-level subdivision functions ***************************/

/* Simplified Delaunay diagram creation */
public static native CvSubdiv2D cvCreateSubdivDelaunay2D( @ByVal CvRect rect, CvMemStorage storage );


/* Inserts new point to the Delaunay triangulation */
public static native CvSubdiv2DPoint cvSubdivDelaunay2DInsert( CvSubdiv2D subdiv, @ByVal CvPoint2D32f pt);

/* Locates a point within the Delaunay triangulation (finds the edge
 the point is left to or belongs to, or the triangulation point the given
 point coinsides with */
public static native @Cast("CvSubdiv2DPointLocation") int cvSubdiv2DLocate(
                                                 CvSubdiv2D subdiv, @ByVal CvPoint2D32f pt,
                                                 @Cast("CvSubdiv2DEdge*") SizeTPointer edge,
                                                 @Cast("CvSubdiv2DPoint**") PointerPointer vertex/*CV_DEFAULT(NULL)*/ );
public static native @Cast("CvSubdiv2DPointLocation") int cvSubdiv2DLocate(
                                                 CvSubdiv2D subdiv, @ByVal CvPoint2D32f pt,
                                                 @Cast("CvSubdiv2DEdge*") SizeTPointer edge,
                                                 @ByPtrPtr CvSubdiv2DPoint vertex/*CV_DEFAULT(NULL)*/ );

/* Calculates Voronoi tesselation (i.e. coordinates of Voronoi points) */
public static native void cvCalcSubdivVoronoi2D( CvSubdiv2D subdiv );


/* Removes all Voronoi points from the tesselation */
public static native void cvClearSubdivVoronoi2D( CvSubdiv2D subdiv );


/* Finds the nearest to the given point vertex in subdivision. */
public static native CvSubdiv2DPoint cvFindNearestPoint2D( CvSubdiv2D subdiv, @ByVal CvPoint2D32f pt );


/************ Basic quad-edge navigation and operations ************/

public static native @Cast("CvSubdiv2DEdge") long cvSubdiv2DNextEdge( @Cast("CvSubdiv2DEdge") long edge );


public static native @Cast("CvSubdiv2DEdge") long cvSubdiv2DRotateEdge( @Cast("CvSubdiv2DEdge") long edge, int rotate );

public static native @Cast("CvSubdiv2DEdge") long cvSubdiv2DSymEdge( @Cast("CvSubdiv2DEdge") long edge );

public static native @Cast("CvSubdiv2DEdge") long cvSubdiv2DGetEdge( @Cast("CvSubdiv2DEdge") long edge, @Cast("CvNextEdgeType") int type );


public static native CvSubdiv2DPoint cvSubdiv2DEdgeOrg( @Cast("CvSubdiv2DEdge") long edge );


public static native CvSubdiv2DPoint cvSubdiv2DEdgeDst( @Cast("CvSubdiv2DEdge") long edge );

/****************************************************************************************\
*                           Additional operations on Subdivisions                        *
\****************************************************************************************/

// paints voronoi diagram: just demo function
public static native void icvDrawMosaic( CvSubdiv2D subdiv, IplImage src, IplImage dst );

// checks planar subdivision for correctness. It is not an absolute check,
// but it verifies some relations between quad-edges
public static native int icvSubdiv2DCheck( CvSubdiv2D subdiv );

// returns squared distance between two 2D points with floating-point coordinates.
public static native double icvSqDist2D32f( @ByVal CvPoint2D32f pt1, @ByVal CvPoint2D32f pt2 );




public static native double cvTriangleArea( @ByVal CvPoint2D32f a, @ByVal CvPoint2D32f b, @ByVal CvPoint2D32f c );


/* Constructs kd-tree from set of feature descriptors */
public static native CvFeatureTree cvCreateKDTree(CvMat desc);

/* Constructs spill-tree from set of feature descriptors */
public static native CvFeatureTree cvCreateSpillTree( @Const CvMat raw_data,
                                               int naive/*CV_DEFAULT(50)*/,
                                               double rho/*CV_DEFAULT(.7)*/,
                                               double tau/*CV_DEFAULT(.1)*/ );

/* Release feature tree */
public static native void cvReleaseFeatureTree(CvFeatureTree tr);

/* Searches feature tree for k nearest neighbors of given reference points,
 searching (in case of kd-tree/bbf) at most emax leaves. */
public static native void cvFindFeatures(CvFeatureTree tr, @Const CvMat query_points,
                           CvMat indices, CvMat dist, int k, int emax/*CV_DEFAULT(20)*/);

/* Search feature tree for all points that are inlier to given rect region.
 Only implemented for kd trees */
public static native int cvFindFeaturesBoxed(CvFeatureTree tr,
                               CvMat bounds_min, CvMat bounds_max,
                               CvMat out_indices);


/* Construct a Locality Sensitive Hash (LSH) table, for indexing d-dimensional vectors of
 given type. Vectors will be hashed L times with k-dimensional p-stable (p=2) functions. */
public static native CvLSH cvCreateLSH(CvLSHOperations ops, int d,
                                 int L/*CV_DEFAULT(10)*/, int k/*CV_DEFAULT(10)*/,
                                 int type/*CV_DEFAULT(CV_64FC1)*/, double r/*CV_DEFAULT(4)*/,
                                 @Cast("int64") long seed/*CV_DEFAULT(-1)*/);

/* Construct in-memory LSH table, with n bins. */
public static native CvLSH cvCreateMemoryLSH(int d, int n, int L/*CV_DEFAULT(10)*/, int k/*CV_DEFAULT(10)*/,
                                       int type/*CV_DEFAULT(CV_64FC1)*/, double r/*CV_DEFAULT(4)*/,
                                       @Cast("int64") long seed/*CV_DEFAULT(-1)*/);

/* Free the given LSH structure. */
public static native void cvReleaseLSH(@Cast("CvLSH**") PointerPointer lsh);
public static native void cvReleaseLSH(@ByPtrPtr CvLSH lsh);

/* Return the number of vectors in the LSH. */
public static native @Cast("unsigned int") int LSHSize(CvLSH lsh);

/* Add vectors to the LSH structure, optionally returning indices. */
public static native void cvLSHAdd(CvLSH lsh, @Const CvMat data, CvMat indices/*CV_DEFAULT(0)*/);

/* Remove vectors from LSH, as addressed by given indices. */
public static native void cvLSHRemove(CvLSH lsh, @Const CvMat indices);

/* Query the LSH n times for at most k nearest points; data is n x d,
 indices and dist are n x k. At most emax stored points will be accessed. */
public static native void cvLSHQuery(CvLSH lsh, @Const CvMat query_points,
                       CvMat indices, CvMat dist, int k, int emax);

/* Kolmogorov-Zabin stereo-correspondence algorithm (a.k.a. KZ1) */
public static native @MemberGetter int CV_STEREO_GC_OCCLUDED();
public static final int CV_STEREO_GC_OCCLUDED = CV_STEREO_GC_OCCLUDED();

public static class CvStereoGCState extends Pointer {
    static { Loader.load(); }
    public CvStereoGCState() { allocate(); }
    public CvStereoGCState(int size) { allocateArray(size); }
    public CvStereoGCState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvStereoGCState position(int position) {
        return (CvStereoGCState)super.position(position);
    }

    public native int Ithreshold(); public native CvStereoGCState Ithreshold(int Ithreshold);
    public native int interactionRadius(); public native CvStereoGCState interactionRadius(int interactionRadius);
    public native float K(); public native CvStereoGCState K(float K);
    public native float lambda(); public native CvStereoGCState lambda(float lambda);
    public native float lambda1(); public native CvStereoGCState lambda1(float lambda1);
    public native float lambda2(); public native CvStereoGCState lambda2(float lambda2);
    public native int occlusionCost(); public native CvStereoGCState occlusionCost(int occlusionCost);
    public native int minDisparity(); public native CvStereoGCState minDisparity(int minDisparity);
    public native int numberOfDisparities(); public native CvStereoGCState numberOfDisparities(int numberOfDisparities);
    public native int maxIters(); public native CvStereoGCState maxIters(int maxIters);

    public native CvMat left(); public native CvStereoGCState left(CvMat left);
    public native CvMat right(); public native CvStereoGCState right(CvMat right);
    public native CvMat dispLeft(); public native CvStereoGCState dispLeft(CvMat dispLeft);
    public native CvMat dispRight(); public native CvStereoGCState dispRight(CvMat dispRight);
    public native CvMat ptrLeft(); public native CvStereoGCState ptrLeft(CvMat ptrLeft);
    public native CvMat ptrRight(); public native CvStereoGCState ptrRight(CvMat ptrRight);
    public native CvMat vtxBuf(); public native CvStereoGCState vtxBuf(CvMat vtxBuf);
    public native CvMat edgeBuf(); public native CvStereoGCState edgeBuf(CvMat edgeBuf);
}

public static native CvStereoGCState cvCreateStereoGCState( int numberOfDisparities, int maxIters );
public static native void cvReleaseStereoGCState( @Cast("CvStereoGCState**") PointerPointer state );
public static native void cvReleaseStereoGCState( @ByPtrPtr CvStereoGCState state );

public static native void cvFindStereoCorrespondenceGC( @Const CvArr left, @Const CvArr right,
                                         CvArr disparityLeft, CvArr disparityRight,
                                         CvStereoGCState state,
                                         int useDisparityGuess/*CV_DEFAULT(0)*/ );

/* Calculates optical flow for 2 images using classical Lucas & Kanade algorithm */
public static native void cvCalcOpticalFlowLK( @Const CvArr prev, @Const CvArr curr,
                                 @ByVal CvSize win_size, CvArr velx, CvArr vely );

/* Calculates optical flow for 2 images using block matching algorithm */
public static native void cvCalcOpticalFlowBM( @Const CvArr prev, @Const CvArr curr,
                                 @ByVal CvSize block_size, @ByVal CvSize shift_size,
                                 @ByVal CvSize max_range, int use_previous,
                                 CvArr velx, CvArr vely );

/* Calculates Optical flow for 2 images using Horn & Schunck algorithm */
public static native void cvCalcOpticalFlowHS( @Const CvArr prev, @Const CvArr curr,
                                 int use_previous, CvArr velx, CvArr vely,
                                 double lambda, @ByVal CvTermCriteria criteria );


/****************************************************************************************\
*                           Background/foreground segmentation                           *
\****************************************************************************************/

/* We discriminate between foreground and background pixels
 * by building and maintaining a model of the background.
 * Any pixel which does not fit this model is then deemed
 * to be foreground.
 *
 * At present we support two core background models,
 * one of which has two variations:
 *
 *  o CV_BG_MODEL_FGD: latest and greatest algorithm, described in
 *
 *	 Foreground Object Detection from Videos Containing Complex Background.
 *	 Liyuan Li, Weimin Huang, Irene Y.H. Gu, and Qi Tian.
 *	 ACM MM2003 9p
 *
 *  o CV_BG_MODEL_FGD_SIMPLE:
 *       A code comment describes this as a simplified version of the above,
 *       but the code is in fact currently identical
 *
 *  o CV_BG_MODEL_MOG: "Mixture of Gaussians", older algorithm, described in
 *
 *       Moving target classification and tracking from real-time video.
 *       A Lipton, H Fujijoshi, R Patil
 *       Proceedings IEEE Workshop on Application of Computer Vision pp 8-14 1998
 *
 *       Learning patterns of activity using real-time tracking
 *       C Stauffer and W Grimson  August 2000
 *       IEEE Transactions on Pattern Analysis and Machine Intelligence 22(8):747-757
 */


public static final int CV_BG_MODEL_FGD =		0;
public static final int CV_BG_MODEL_MOG =		1;			/* "Mixture of Gaussians".	*/
public static final int CV_BG_MODEL_FGD_SIMPLE =	2;

public static class CvReleaseBGStatModel extends FunctionPointer {
    static { Loader.load(); }
    public    CvReleaseBGStatModel(Pointer p) { super(p); }
    protected CvReleaseBGStatModel() { allocate(); }
    private native void allocate();
    public native void call( @ByPtrPtr CvBGStatModel bg_model );
}
public static class CvUpdateBGStatModel extends FunctionPointer {
    static { Loader.load(); }
    public    CvUpdateBGStatModel(Pointer p) { super(p); }
    protected CvUpdateBGStatModel() { allocate(); }
    private native void allocate();
    public native int call( IplImage curr_frame, CvBGStatModel bg_model,
                                             double learningRate );
}

// #define CV_BG_STAT_MODEL_FIELDS()
// int             type; /*type of BG model*/
// CvReleaseBGStatModel release;
// CvUpdateBGStatModel update;
// IplImage*       background;   /*8UC3 reference background image*/
// IplImage*       foreground;   /*8UC1 foreground image*/
// IplImage**      layers;       /*8UC3 reference background image, can be null */
// int             layer_count;  /* can be zero */
// CvMemStorage*   storage;      /*storage for foreground_regions*/
// CvSeq*          foreground_regions /*foreground object contours*/

public static class CvBGStatModel extends Pointer {
    static { Loader.load(); }
    public CvBGStatModel() { allocate(); }
    public CvBGStatModel(int size) { allocateArray(size); }
    public CvBGStatModel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGStatModel position(int position) {
        return (CvBGStatModel)super.position(position);
    }

    public native int type(); public native CvBGStatModel type(int type); /*type of BG model*/                                      
public native CvReleaseBGStatModel release(); public native CvBGStatModel release(CvReleaseBGStatModel release);                                                   
public native CvUpdateBGStatModel update(); public native CvBGStatModel update(CvUpdateBGStatModel update);                                                     
public native IplImage background(); public native CvBGStatModel background(IplImage background);   /*8UC3 reference background image*/               
public native IplImage foreground(); public native CvBGStatModel foreground(IplImage foreground);   /*8UC1 foreground image*/                         
public native IplImage layers(int i); public native CvBGStatModel layers(int i, IplImage layers);
@MemberGetter public native @Cast("IplImage**") PointerPointer layers();       /*8UC3 reference background image, can be null */ 
public native int layer_count(); public native CvBGStatModel layer_count(int layer_count);  /* can be zero */                                 
public native CvMemStorage storage(); public native CvBGStatModel storage(CvMemStorage storage);      /*storage for foreground_regions*/                
public native CvSeq foreground_regions(); public native CvBGStatModel foreground_regions(CvSeq foreground_regions);
}

//

// Releases memory used by BGStatModel
public static native void cvReleaseBGStatModel( @Cast("CvBGStatModel**") PointerPointer bg_model );
public static native void cvReleaseBGStatModel( @ByPtrPtr CvBGStatModel bg_model );

// Updates statistical model and returns number of found foreground regions
public static native int cvUpdateBGStatModel( IplImage current_frame, CvBGStatModel bg_model,
                               double learningRate/*CV_DEFAULT(-1)*/);

// Performs FG post-processing using segmentation
// (all pixels of a region will be classified as foreground if majority of pixels of the region are FG).
// parameters:
//      segments - pointer to result of segmentation (for example MeanShiftSegmentation)
//      bg_model - pointer to CvBGStatModel structure
public static native void cvRefineForegroundMaskBySegm( CvSeq segments, CvBGStatModel bg_model );

/* Common use change detection function */
public static native int cvChangeDetection( IplImage prev_frame,
                              IplImage curr_frame,
                              IplImage change_mask );

/*
 Interface of ACM MM2003 algorithm
 */

/* Default parameters of foreground detection algorithm: */
public static final int CV_BGFG_FGD_LC =              128;
public static final int CV_BGFG_FGD_N1C =             15;
public static final int CV_BGFG_FGD_N2C =             25;

public static final int CV_BGFG_FGD_LCC =             64;
public static final int CV_BGFG_FGD_N1CC =            25;
public static final int CV_BGFG_FGD_N2CC =            40;

/* Background reference image update parameter: */
public static final double CV_BGFG_FGD_ALPHA_1 =         0.1f;

/* stat model update parameter
 * 0.002f ~ 1K frame(~45sec), 0.005 ~ 18sec (if 25fps and absolutely static BG)
 */
public static final double CV_BGFG_FGD_ALPHA_2 =         0.005f;

/* start value for alpha parameter (to fast initiate statistic model) */
public static final double CV_BGFG_FGD_ALPHA_3 =         0.1f;

public static final int CV_BGFG_FGD_DELTA =           2;

public static final double CV_BGFG_FGD_T =               0.9f;

public static final double CV_BGFG_FGD_MINAREA =         15.f;

public static final double CV_BGFG_FGD_BG_UPDATE_TRESH = 0.5f;

/* See the above-referenced Li/Huang/Gu/Tian paper
 * for a full description of these background-model
 * tuning parameters.
 *
 * Nomenclature:  'c'  == "color", a three-component red/green/blue vector.
 *                         We use histograms of these to model the range of
 *                         colors we've seen at a given background pixel.
 *
 *                'cc' == "color co-occurrence", a six-component vector giving
 *                         RGB color for both this frame and preceding frame.
 *                             We use histograms of these to model the range of
 *                         color CHANGES we've seen at a given background pixel.
 */
public static class CvFGDStatModelParams extends Pointer {
    static { Loader.load(); }
    public CvFGDStatModelParams() { allocate(); }
    public CvFGDStatModelParams(int size) { allocateArray(size); }
    public CvFGDStatModelParams(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvFGDStatModelParams position(int position) {
        return (CvFGDStatModelParams)super.position(position);
    }

    public native int Lc(); public native CvFGDStatModelParams Lc(int Lc);			/* Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.				*/
    public native int N1c(); public native CvFGDStatModelParams N1c(int N1c);			/* Number of color vectors used to model normal background color variation at a given pixel.			*/
    public native int N2c(); public native CvFGDStatModelParams N2c(int N2c);			/* Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5/3 of N1c.			*/
    /* Used to allow the first N1c vectors to adapt over time to changing background.				*/

    public native int Lcc(); public native CvFGDStatModelParams Lcc(int Lcc);			/* Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.			*/
    public native int N1cc(); public native CvFGDStatModelParams N1cc(int N1cc);		/* Number of color co-occurrence vectors used to model normal background color variation at a given pixel.	*/
    public native int N2cc(); public native CvFGDStatModelParams N2cc(int N2cc);		/* Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5/3 of N1cc.	*/
    /* Used to allow the first N1cc vectors to adapt over time to changing background.				*/

    public native int is_obj_without_holes(); public native CvFGDStatModelParams is_obj_without_holes(int is_obj_without_holes);/* If TRUE we ignore holes within foreground blobs. Defaults to TRUE.						*/
    public native int perform_morphing(); public native CvFGDStatModelParams perform_morphing(int perform_morphing);	/* Number of erode-dilate-erode foreground-blob cleanup iterations.						*/
    /* These erase one-pixel junk blobs and merge almost-touching blobs. Default value is 1.			*/

    public native float alpha1(); public native CvFGDStatModelParams alpha1(float alpha1);		/* How quickly we forget old background pixel values seen.  Typically set to 0.1  				*/
    public native float alpha2(); public native CvFGDStatModelParams alpha2(float alpha2);		/* "Controls speed of feature learning". Depends on T. Typical value circa 0.005. 				*/
    public native float alpha3(); public native CvFGDStatModelParams alpha3(float alpha3);		/* Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.				*/

    public native float delta(); public native CvFGDStatModelParams delta(float delta);		/* Affects color and color co-occurrence quantization, typically set to 2.					*/
    public native float T(); public native CvFGDStatModelParams T(float T);			/* "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).*/
    public native float minArea(); public native CvFGDStatModelParams minArea(float minArea);		/* Discard foreground blobs whose bounding box is smaller than this threshold.					*/
}

public static class CvBGPixelCStatTable extends Pointer {
    static { Loader.load(); }
    public CvBGPixelCStatTable() { allocate(); }
    public CvBGPixelCStatTable(int size) { allocateArray(size); }
    public CvBGPixelCStatTable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGPixelCStatTable position(int position) {
        return (CvBGPixelCStatTable)super.position(position);
    }

    public native float Pv(); public native CvBGPixelCStatTable Pv(float Pv);
    public native float Pvb(); public native CvBGPixelCStatTable Pvb(float Pvb);
    public native @Cast("uchar") byte v(int i); public native CvBGPixelCStatTable v(int i, byte v);
    @MemberGetter public native @Cast("uchar*") BytePointer v();
}

public static class CvBGPixelCCStatTable extends Pointer {
    static { Loader.load(); }
    public CvBGPixelCCStatTable() { allocate(); }
    public CvBGPixelCCStatTable(int size) { allocateArray(size); }
    public CvBGPixelCCStatTable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGPixelCCStatTable position(int position) {
        return (CvBGPixelCCStatTable)super.position(position);
    }

    public native float Pv(); public native CvBGPixelCCStatTable Pv(float Pv);
    public native float Pvb(); public native CvBGPixelCCStatTable Pvb(float Pvb);
    public native @Cast("uchar") byte v(int i); public native CvBGPixelCCStatTable v(int i, byte v);
    @MemberGetter public native @Cast("uchar*") BytePointer v();
}

public static class CvBGPixelStat extends Pointer {
    static { Loader.load(); }
    public CvBGPixelStat() { allocate(); }
    public CvBGPixelStat(int size) { allocateArray(size); }
    public CvBGPixelStat(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGPixelStat position(int position) {
        return (CvBGPixelStat)super.position(position);
    }

    public native float Pbc(); public native CvBGPixelStat Pbc(float Pbc);
    public native float Pbcc(); public native CvBGPixelStat Pbcc(float Pbcc);
    public native CvBGPixelCStatTable ctable(); public native CvBGPixelStat ctable(CvBGPixelCStatTable ctable);
    public native CvBGPixelCCStatTable cctable(); public native CvBGPixelStat cctable(CvBGPixelCCStatTable cctable);
    public native @Cast("uchar") byte is_trained_st_model(); public native CvBGPixelStat is_trained_st_model(byte is_trained_st_model);
    public native @Cast("uchar") byte is_trained_dyn_model(); public native CvBGPixelStat is_trained_dyn_model(byte is_trained_dyn_model);
}


public static class CvFGDStatModel extends Pointer {
    static { Loader.load(); }
    public CvFGDStatModel() { allocate(); }
    public CvFGDStatModel(int size) { allocateArray(size); }
    public CvFGDStatModel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvFGDStatModel position(int position) {
        return (CvFGDStatModel)super.position(position);
    }

    public native int type(); public native CvFGDStatModel type(int type); /*type of BG model*/                                      
public native CvReleaseBGStatModel release(); public native CvFGDStatModel release(CvReleaseBGStatModel release);                                                   
public native CvUpdateBGStatModel update(); public native CvFGDStatModel update(CvUpdateBGStatModel update);                                                     
public native IplImage background(); public native CvFGDStatModel background(IplImage background);   /*8UC3 reference background image*/               
public native IplImage foreground(); public native CvFGDStatModel foreground(IplImage foreground);   /*8UC1 foreground image*/                         
public native IplImage layers(int i); public native CvFGDStatModel layers(int i, IplImage layers);
@MemberGetter public native @Cast("IplImage**") PointerPointer layers();       /*8UC3 reference background image, can be null */ 
public native int layer_count(); public native CvFGDStatModel layer_count(int layer_count);  /* can be zero */                                 
public native CvMemStorage storage(); public native CvFGDStatModel storage(CvMemStorage storage);      /*storage for foreground_regions*/                
public native CvSeq foreground_regions(); public native CvFGDStatModel foreground_regions(CvSeq foreground_regions);
    public native CvBGPixelStat pixel_stat(); public native CvFGDStatModel pixel_stat(CvBGPixelStat pixel_stat);
    public native IplImage Ftd(); public native CvFGDStatModel Ftd(IplImage Ftd);
    public native IplImage Fbd(); public native CvFGDStatModel Fbd(IplImage Fbd);
    public native IplImage prev_frame(); public native CvFGDStatModel prev_frame(IplImage prev_frame);
    public native @ByVal CvFGDStatModelParams params(); public native CvFGDStatModel params(CvFGDStatModelParams params);
}

/* Creates FGD model */
public static native CvBGStatModel cvCreateFGDStatModel( IplImage first_frame,
                                           CvFGDStatModelParams parameters/*CV_DEFAULT(NULL)*/);

/*
 Interface of Gaussian mixture algorithm

 "An improved adaptive background mixture model for real-time tracking with shadow detection"
 P. KadewTraKuPong and R. Bowden,
 Proc. 2nd European Workshp on Advanced Video-Based Surveillance Systems, 2001."
 http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf
 */

/* Note:  "MOG" == "Mixture Of Gaussians": */

public static final int CV_BGFG_MOG_MAX_NGAUSSIANS = 500;

/* default parameters of gaussian background detection algorithm */
public static final double CV_BGFG_MOG_BACKGROUND_THRESHOLD =     0.7;     /* threshold sum of weights for background test */
public static final double CV_BGFG_MOG_STD_THRESHOLD =            2.5;     /* lambda=2.5 is 99% */
public static final int CV_BGFG_MOG_WINDOW_SIZE =              200;     /* Learning rate; alpha = 1/CV_GBG_WINDOW_SIZE */
public static final int CV_BGFG_MOG_NGAUSSIANS =               5;       /* = K = number of Gaussians in mixture */
public static final double CV_BGFG_MOG_WEIGHT_INIT =              0.05;
public static final int CV_BGFG_MOG_SIGMA_INIT =               30;
public static final double CV_BGFG_MOG_MINAREA =                  15.f;


public static final int CV_BGFG_MOG_NCOLORS =                  3;

public static class CvGaussBGStatModelParams extends Pointer {
    static { Loader.load(); }
    public CvGaussBGStatModelParams() { allocate(); }
    public CvGaussBGStatModelParams(int size) { allocateArray(size); }
    public CvGaussBGStatModelParams(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGaussBGStatModelParams position(int position) {
        return (CvGaussBGStatModelParams)super.position(position);
    }

    public native int win_size(); public native CvGaussBGStatModelParams win_size(int win_size);               /* = 1/alpha */
    public native int n_gauss(); public native CvGaussBGStatModelParams n_gauss(int n_gauss);
    public native double bg_threshold(); public native CvGaussBGStatModelParams bg_threshold(double bg_threshold);
    public native double std_threshold(); public native CvGaussBGStatModelParams std_threshold(double std_threshold);
    public native double minArea(); public native CvGaussBGStatModelParams minArea(double minArea);
    public native double weight_init(); public native CvGaussBGStatModelParams weight_init(double weight_init);
    public native double variance_init(); public native CvGaussBGStatModelParams variance_init(double variance_init);
}

public static class CvGaussBGValues extends Pointer {
    static { Loader.load(); }
    public CvGaussBGValues() { allocate(); }
    public CvGaussBGValues(int size) { allocateArray(size); }
    public CvGaussBGValues(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGaussBGValues position(int position) {
        return (CvGaussBGValues)super.position(position);
    }

    public native int match_sum(); public native CvGaussBGValues match_sum(int match_sum);
    public native double weight(); public native CvGaussBGValues weight(double weight);
    public native double variance(int i); public native CvGaussBGValues variance(int i, double variance);
    @MemberGetter public native DoublePointer variance();
    public native double mean(int i); public native CvGaussBGValues mean(int i, double mean);
    @MemberGetter public native DoublePointer mean();
}

public static class CvGaussBGPoint extends Pointer {
    static { Loader.load(); }
    public CvGaussBGPoint() { allocate(); }
    public CvGaussBGPoint(int size) { allocateArray(size); }
    public CvGaussBGPoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGaussBGPoint position(int position) {
        return (CvGaussBGPoint)super.position(position);
    }

    public native CvGaussBGValues g_values(); public native CvGaussBGPoint g_values(CvGaussBGValues g_values);
}


public static class CvGaussBGModel extends Pointer {
    static { Loader.load(); }
    public CvGaussBGModel() { allocate(); }
    public CvGaussBGModel(int size) { allocateArray(size); }
    public CvGaussBGModel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvGaussBGModel position(int position) {
        return (CvGaussBGModel)super.position(position);
    }

    public native int type(); public native CvGaussBGModel type(int type); /*type of BG model*/                                      
public native CvReleaseBGStatModel release(); public native CvGaussBGModel release(CvReleaseBGStatModel release);                                                   
public native CvUpdateBGStatModel update(); public native CvGaussBGModel update(CvUpdateBGStatModel update);                                                     
public native IplImage background(); public native CvGaussBGModel background(IplImage background);   /*8UC3 reference background image*/               
public native IplImage foreground(); public native CvGaussBGModel foreground(IplImage foreground);   /*8UC1 foreground image*/                         
public native IplImage layers(int i); public native CvGaussBGModel layers(int i, IplImage layers);
@MemberGetter public native @Cast("IplImage**") PointerPointer layers();       /*8UC3 reference background image, can be null */ 
public native int layer_count(); public native CvGaussBGModel layer_count(int layer_count);  /* can be zero */                                 
public native CvMemStorage storage(); public native CvGaussBGModel storage(CvMemStorage storage);      /*storage for foreground_regions*/                
public native CvSeq foreground_regions(); public native CvGaussBGModel foreground_regions(CvSeq foreground_regions);
    public native @ByVal CvGaussBGStatModelParams params(); public native CvGaussBGModel params(CvGaussBGStatModelParams params);
    public native CvGaussBGPoint g_point(); public native CvGaussBGModel g_point(CvGaussBGPoint g_point);
    public native int countFrames(); public native CvGaussBGModel countFrames(int countFrames);
    public native Pointer mog(); public native CvGaussBGModel mog(Pointer mog);
}


/* Creates Gaussian mixture background model */
public static native CvBGStatModel cvCreateGaussianBGModel( IplImage first_frame,
                                              CvGaussBGStatModelParams parameters/*CV_DEFAULT(NULL)*/);


public static class CvBGCodeBookElem extends Pointer {
    static { Loader.load(); }
    public CvBGCodeBookElem() { allocate(); }
    public CvBGCodeBookElem(int size) { allocateArray(size); }
    public CvBGCodeBookElem(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGCodeBookElem position(int position) {
        return (CvBGCodeBookElem)super.position(position);
    }

    public native CvBGCodeBookElem next(); public native CvBGCodeBookElem next(CvBGCodeBookElem next);
    public native int tLastUpdate(); public native CvBGCodeBookElem tLastUpdate(int tLastUpdate);
    public native int stale(); public native CvBGCodeBookElem stale(int stale);
    public native @Cast("uchar") byte boxMin(int i); public native CvBGCodeBookElem boxMin(int i, byte boxMin);
    @MemberGetter public native @Cast("uchar*") BytePointer boxMin();
    public native @Cast("uchar") byte boxMax(int i); public native CvBGCodeBookElem boxMax(int i, byte boxMax);
    @MemberGetter public native @Cast("uchar*") BytePointer boxMax();
    public native @Cast("uchar") byte learnMin(int i); public native CvBGCodeBookElem learnMin(int i, byte learnMin);
    @MemberGetter public native @Cast("uchar*") BytePointer learnMin();
    public native @Cast("uchar") byte learnMax(int i); public native CvBGCodeBookElem learnMax(int i, byte learnMax);
    @MemberGetter public native @Cast("uchar*") BytePointer learnMax();
}

public static class CvBGCodeBookModel extends Pointer {
    static { Loader.load(); }
    public CvBGCodeBookModel() { allocate(); }
    public CvBGCodeBookModel(int size) { allocateArray(size); }
    public CvBGCodeBookModel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(int size);
    @Override public CvBGCodeBookModel position(int position) {
        return (CvBGCodeBookModel)super.position(position);
    }

    public native @ByVal CvSize size(); public native CvBGCodeBookModel size(CvSize size);
    public native int t(); public native CvBGCodeBookModel t(int t);
    public native @Cast("uchar") byte cbBounds(int i); public native CvBGCodeBookModel cbBounds(int i, byte cbBounds);
    @MemberGetter public native @Cast("uchar*") BytePointer cbBounds();
    public native @Cast("uchar") byte modMin(int i); public native CvBGCodeBookModel modMin(int i, byte modMin);
    @MemberGetter public native @Cast("uchar*") BytePointer modMin();
    public native @Cast("uchar") byte modMax(int i); public native CvBGCodeBookModel modMax(int i, byte modMax);
    @MemberGetter public native @Cast("uchar*") BytePointer modMax();
    public native CvBGCodeBookElem cbmap(int i); public native CvBGCodeBookModel cbmap(int i, CvBGCodeBookElem cbmap);
    @MemberGetter public native @Cast("CvBGCodeBookElem**") PointerPointer cbmap();
    public native CvMemStorage storage(); public native CvBGCodeBookModel storage(CvMemStorage storage);
    public native CvBGCodeBookElem freeList(); public native CvBGCodeBookModel freeList(CvBGCodeBookElem freeList);
}

public static native CvBGCodeBookModel cvCreateBGCodeBookModel( );
public static native void cvReleaseBGCodeBookModel( @Cast("CvBGCodeBookModel**") PointerPointer model );
public static native void cvReleaseBGCodeBookModel( @ByPtrPtr CvBGCodeBookModel model );

public static native void cvBGCodeBookUpdate( CvBGCodeBookModel model, @Const CvArr image,
                               @ByVal CvRect roi/*CV_DEFAULT(cvRect(0,0,0,0))*/,
                               @Const CvArr mask/*CV_DEFAULT(0)*/ );

public static native int cvBGCodeBookDiff( @Const CvBGCodeBookModel model, @Const CvArr image,
                            CvArr fgmask, @ByVal CvRect roi/*CV_DEFAULT(cvRect(0,0,0,0))*/ );

public static native void cvBGCodeBookClearStale( CvBGCodeBookModel model, int staleThresh,
                                   @ByVal CvRect roi/*CV_DEFAULT(cvRect(0,0,0,0))*/,
                                   @Const CvArr mask/*CV_DEFAULT(0)*/ );

public static native CvSeq cvSegmentFGMask( CvArr fgmask, int poly1Hull0/*CV_DEFAULT(1)*/,
                              float perimScale/*CV_DEFAULT(4.f)*/,
                              CvMemStorage storage/*CV_DEFAULT(0)*/,
                              @ByVal CvPoint offset/*CV_DEFAULT(cvPoint(0,0))*/);

// #ifdef __cplusplus
// #endif

// #endif

/* End of file. */


}
